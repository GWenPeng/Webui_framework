#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    EFAST thift 管理接口

    """
    def EFAST_Start(self):
        """
        启动 EFAST 服务, 启动服务后才能获取端口和处理池信息

        @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                               2. 底层其他异常转抛

        """
        pass

    def EFAST_Stop(self):
        """
        停止 EFAST 服务, 停止服务后才能设置端口和处理池信息

        @throw EThriftException.ncTException : 停止时出现异常

        """
        pass

    def EFAST_GetServiceState(self):
        """
        获取 EFAST 服务状态

        @return ncTSynServiceState : 获取 EFAST 数据服务状态, 当 EFAST 服务是启动状态，返回 NCT_SERVICE_RUN_STATE;
                                     当 EFAST 服务是停止状态，返回 NCT_SERVICE_STOP_STATE

        """
        pass

    def EFSHttp_SetPort(self, port):
        """
        设置 EFAST EFSHttp 数据端口号

        @param port : 端口号配置, 默认为 9123，范围[9122, 9140],不能和 EFAST 设置的数据端口号一样

        @throw EThriftException.ncTException : 1. 底层其他异常转抛
                                               2. EFAST 服务为启动状态抛错
                                               3. 与 EFAST 数据服务已经设置的端口重复

        Parameters:
         - port

        """
        pass

    def EFSHttp_GetPort(self):
        """
        获取 EFAST EFSHttp 数据端口号

        @return i32: 端口编号
        @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                               2. 底层其他异常转抛
                                               3. EFAST 服务为停止状态抛错

        """
        pass

    def EFSHttp_SetMaxConcurrency(self, processPoolCount):
        """
        设置 EFAST EFSHttp 的处理池数目.

        @param poolCount : 同步服务处理池数目, 默认为100 ，范围为 [1, 200]

        @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                               2. 底层其他异常转抛
                                               3. EFAST 服务为启动状态抛错

        Parameters:
         - processPoolCount

        """
        pass

    def EFSHttp_GetMaxConcurrency(self):
        """
         获取 EFAST EFSHttp 的处理池数目.

        @return i32 : 启动处理池中处理器个数

         @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                                2. 底层其他异常转抛
                                                3. EFAST 服务为停止状态抛错

        """
        pass

    def EFAST_AddUserDoc(self, userId, totalQuotaBytes, responsiblePersonId):
        """
        创建个人文档

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - totalQuotaBytes
         - responsiblePersonId

        """
        pass

    def EFAST_AddCustomDoc(self, info):
        """
        新建自定义文档库

        @ret: 返回创建成功后的id
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        pass

    def EFAST_AddCustomDocEx(self, info):
        """
        新建自定义文档库，指定objId

        @ret: 返回创建成功后的id
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        pass

    def EFAST_EditCustomDoc(self, info):
        """
        编辑自定义文档库

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        pass

    def EFAST_EditCustomDocManager(self, docId, userId):
        """
        设置自定义文档库的管理员

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - docId
         - userId

        """
        pass

    def EFAST_DeleteCustomDoc(self, info):
        """
        删除自定义文档库

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        pass

    def EFAST_GetCustomDocCnt(self, userId):
        """
        获取自定义文档库总数
        @param userId: 用户id
        @ret: 自定义文档库总数
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EFAST_GetCustomDocByObjId(self, objId):
        """
        根据文档库的对象id获取文档库信息

        @ret: 返回文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - objId

        """
        pass

    def EFAST_GetCustomDocByDocId(self, docId):
        """
        根据文档库id获取文档库信息

        @ret: 返回文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - docId

        """
        pass

    def EFAST_GetCustomDocInfosByPage(self, start, limit, userId):
        """
        分页获取自定义文档库信息
        @param start: 起始索引
        @param limit: 获取文档数
        @param userId: 用户id
        @ret: 文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - start
         - limit
         - userId

        """
        pass

    def EFAST_CheckDocSpace(self, userId, docIds, quota):
        """
        批量编辑文档库配额前检查空间是否足够
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - docIds
         - quota

        """
        pass

    def EFAST_SetQuotaInfo(self, userId, docId, quota):
        """
        编辑文档库配额
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - docId
         - quota

        """
        pass

    def EFAST_SearchCustomDocInfos(self, param):
        """
        搜索用户自定义文档库信息

        Parameters:
         - param

        """
        pass

    def EFAST_GetSearchCustomDocCnt(self, param):
        """
        获取搜索用户自定义文档库信息条目数量

        Parameters:
         - param

        """
        pass

    def EFAST_EditDocLibrarySiteId(self, docId, siteId):
        """
        设置文档库归属站点(限制个人文档)

        @throw EThriftException.ncTException

        Parameters:
         - docId
         - siteId

        """
        pass

    def EFAST_BatchAddCustomDocs(self, param):
        """
        创建批量新建自定义文档库任务

        @ret: 返回创建的任务id
        @throw EThriftException.ncTException

        Parameters:
         - param

        """
        pass

    def EFAST_GetBatchAddCustomDocsResult(self, taskId):
        """
        查询批量新建自定义文档库结果

        @ret: 返回创建的结果
        @throw EThriftException.ncTException

        Parameters:
         - taskId

        """
        pass

    def EFAST_SearchAvailableCustomDocInfos(self, param):
        """
        搜索用户自定义文档库信息 (组织管理员的结果中包含有所有者权限的文档库信息)

        Parameters:
         - param

        """
        pass

    def EFAST_GetSearchAvailableCustomDocCnt(self, param):
        """
        获取搜索用户自定义文档库信息条目数量 (组织管理员的结果中包含有所有者权限的文档库)

        Parameters:
         - param

        """
        pass

    def EFAST_EditDisplayOrder(self, docId, userId, displayOrder):
        """
        修改自定义文档库的显示顺序

        Parameters:
         - docId
         - userId
         - displayOrder

        """
        pass

    def EFAST_MoveUserDoc(self, adminId, userId, docId):
        """
        移动个人文档

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - adminId
         - userId
         - docId

        """
        pass

    def EFAST_MoveEntryDoc(self, adminId, sourceDocId, targetDocId):
        """
        移动个人文档（文档库恢复使用）

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - adminId
         - sourceDocId
         - targetDocId

        """
        pass

    def EFAST_DeleteUserDoc(self, userId, deleterId):
        """
        删除个人文档

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - deleterId

        """
        pass

    def EFAST_GetUserTotalQuota(self, userId):
        """
        获取个人总配额，bytes

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EFAST_GetUserUsedQuota(self, userId):
        """
        获取个人已使用配额空间，bytes

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EFAST_EditUserTotalQuota(self, userId, totalQuotaBytes):
        """
        编辑个人总配额，bytes

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - totalQuotaBytes

        """
        pass

    def EFAST_GetAllUserDocById(self, userId):
        """
        检查用户是否有文档数据（包括个人文档）
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EFAST_ConfictWithLibName(self, name):
        """
        检测用户显示名是否和自定义文档库、归档库名称冲突

        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - name

        """
        pass

    def EFAST_GetSpaceQuotaInfo(self, userId):
        """
        获取用户配额空间信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EFAST_GetAllCustomDocTypeName(self):
        """
        获取所有文档库类型名
        @throw EThriftException.ncTException

        """
        pass

    def EFAST_GetUserGns(self, userId):
        """
        根据用户id获取gns路径
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EFAST_SysRecycle_RestoreCustomDoc(self, docId, name, adminId):
        """
        根据自定义文档库docId和adminId恢复自定义文档库

        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - docId
         - name
         - adminId

        """
        pass

    def EFAST_SysRecycle_RestoreUserDoc(self, docId, responsiblePersonId):
        """
        Parameters:
         - docId
         - responsiblePersonId

        """
        pass

    def EFAST_SysRecycle_GetEntryDocInfos(self, start, limit, searchKey):
        """
        获取系统回收站的入口文档信息
        @param start: 起始索引
        @param limit: 获取文档数
        @param searchKey: 搜索关键字, 为空时查找所有
        @ret: 文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - start
         - limit
         - searchKey

        """
        pass

    def EFAST_SysRecycle_GetEntryDocInfoByDocId(self, docId):
        """
        根据docId(cid)获取系统回收站的入口文档信息
        @param docId: 文档id
        @ret: 文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - docId

        """
        pass

    def EFAST_OnDeleteDepartment(self, departmentIds):
        """
        删除部门时通知efast删除文档库的关联部门

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - departmentIds

        """
        pass


class Client(Iface):
    """
    EFAST thift 管理接口

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def EFAST_Start(self):
        """
        启动 EFAST 服务, 启动服务后才能获取端口和处理池信息

        @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                               2. 底层其他异常转抛

        """
        self.send_EFAST_Start()
        self.recv_EFAST_Start()

    def send_EFAST_Start(self):
        self._oprot.writeMessageBegin('EFAST_Start', TMessageType.CALL, self._seqid)
        args = EFAST_Start_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_Start(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_Start_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_Stop(self):
        """
        停止 EFAST 服务, 停止服务后才能设置端口和处理池信息

        @throw EThriftException.ncTException : 停止时出现异常

        """
        self.send_EFAST_Stop()
        self.recv_EFAST_Stop()

    def send_EFAST_Stop(self):
        self._oprot.writeMessageBegin('EFAST_Stop', TMessageType.CALL, self._seqid)
        args = EFAST_Stop_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_Stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_Stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_GetServiceState(self):
        """
        获取 EFAST 服务状态

        @return ncTSynServiceState : 获取 EFAST 数据服务状态, 当 EFAST 服务是启动状态，返回 NCT_SERVICE_RUN_STATE;
                                     当 EFAST 服务是停止状态，返回 NCT_SERVICE_STOP_STATE

        """
        self.send_EFAST_GetServiceState()
        return self.recv_EFAST_GetServiceState()

    def send_EFAST_GetServiceState(self):
        self._oprot.writeMessageBegin('EFAST_GetServiceState', TMessageType.CALL, self._seqid)
        args = EFAST_GetServiceState_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetServiceState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetServiceState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetServiceState failed: unknown result")

    def EFSHttp_SetPort(self, port):
        """
        设置 EFAST EFSHttp 数据端口号

        @param port : 端口号配置, 默认为 9123，范围[9122, 9140],不能和 EFAST 设置的数据端口号一样

        @throw EThriftException.ncTException : 1. 底层其他异常转抛
                                               2. EFAST 服务为启动状态抛错
                                               3. 与 EFAST 数据服务已经设置的端口重复

        Parameters:
         - port

        """
        self.send_EFSHttp_SetPort(port)
        self.recv_EFSHttp_SetPort()

    def send_EFSHttp_SetPort(self, port):
        self._oprot.writeMessageBegin('EFSHttp_SetPort', TMessageType.CALL, self._seqid)
        args = EFSHttp_SetPort_args()
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFSHttp_SetPort(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFSHttp_SetPort_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFSHttp_GetPort(self):
        """
        获取 EFAST EFSHttp 数据端口号

        @return i32: 端口编号
        @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                               2. 底层其他异常转抛
                                               3. EFAST 服务为停止状态抛错

        """
        self.send_EFSHttp_GetPort()
        return self.recv_EFSHttp_GetPort()

    def send_EFSHttp_GetPort(self):
        self._oprot.writeMessageBegin('EFSHttp_GetPort', TMessageType.CALL, self._seqid)
        args = EFSHttp_GetPort_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFSHttp_GetPort(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFSHttp_GetPort_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFSHttp_GetPort failed: unknown result")

    def EFSHttp_SetMaxConcurrency(self, processPoolCount):
        """
        设置 EFAST EFSHttp 的处理池数目.

        @param poolCount : 同步服务处理池数目, 默认为100 ，范围为 [1, 200]

        @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                               2. 底层其他异常转抛
                                               3. EFAST 服务为启动状态抛错

        Parameters:
         - processPoolCount

        """
        self.send_EFSHttp_SetMaxConcurrency(processPoolCount)
        self.recv_EFSHttp_SetMaxConcurrency()

    def send_EFSHttp_SetMaxConcurrency(self, processPoolCount):
        self._oprot.writeMessageBegin('EFSHttp_SetMaxConcurrency', TMessageType.CALL, self._seqid)
        args = EFSHttp_SetMaxConcurrency_args()
        args.processPoolCount = processPoolCount
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFSHttp_SetMaxConcurrency(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFSHttp_SetMaxConcurrency_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFSHttp_GetMaxConcurrency(self):
        """
         获取 EFAST EFSHttp 的处理池数目.

        @return i32 : 启动处理池中处理器个数

         @throw EThriftException.ncTException : 1. 转抛底层转抛的输入参数错误
                                                2. 底层其他异常转抛
                                                3. EFAST 服务为停止状态抛错

        """
        self.send_EFSHttp_GetMaxConcurrency()
        return self.recv_EFSHttp_GetMaxConcurrency()

    def send_EFSHttp_GetMaxConcurrency(self):
        self._oprot.writeMessageBegin('EFSHttp_GetMaxConcurrency', TMessageType.CALL, self._seqid)
        args = EFSHttp_GetMaxConcurrency_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFSHttp_GetMaxConcurrency(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFSHttp_GetMaxConcurrency_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFSHttp_GetMaxConcurrency failed: unknown result")

    def EFAST_AddUserDoc(self, userId, totalQuotaBytes, responsiblePersonId):
        """
        创建个人文档

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - totalQuotaBytes
         - responsiblePersonId

        """
        self.send_EFAST_AddUserDoc(userId, totalQuotaBytes, responsiblePersonId)
        self.recv_EFAST_AddUserDoc()

    def send_EFAST_AddUserDoc(self, userId, totalQuotaBytes, responsiblePersonId):
        self._oprot.writeMessageBegin('EFAST_AddUserDoc', TMessageType.CALL, self._seqid)
        args = EFAST_AddUserDoc_args()
        args.userId = userId
        args.totalQuotaBytes = totalQuotaBytes
        args.responsiblePersonId = responsiblePersonId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_AddUserDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_AddUserDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_AddCustomDoc(self, info):
        """
        新建自定义文档库

        @ret: 返回创建成功后的id
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        self.send_EFAST_AddCustomDoc(info)
        return self.recv_EFAST_AddCustomDoc()

    def send_EFAST_AddCustomDoc(self, info):
        self._oprot.writeMessageBegin('EFAST_AddCustomDoc', TMessageType.CALL, self._seqid)
        args = EFAST_AddCustomDoc_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_AddCustomDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_AddCustomDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_AddCustomDoc failed: unknown result")

    def EFAST_AddCustomDocEx(self, info):
        """
        新建自定义文档库，指定objId

        @ret: 返回创建成功后的id
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        self.send_EFAST_AddCustomDocEx(info)
        return self.recv_EFAST_AddCustomDocEx()

    def send_EFAST_AddCustomDocEx(self, info):
        self._oprot.writeMessageBegin('EFAST_AddCustomDocEx', TMessageType.CALL, self._seqid)
        args = EFAST_AddCustomDocEx_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_AddCustomDocEx(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_AddCustomDocEx_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_AddCustomDocEx failed: unknown result")

    def EFAST_EditCustomDoc(self, info):
        """
        编辑自定义文档库

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        self.send_EFAST_EditCustomDoc(info)
        self.recv_EFAST_EditCustomDoc()

    def send_EFAST_EditCustomDoc(self, info):
        self._oprot.writeMessageBegin('EFAST_EditCustomDoc', TMessageType.CALL, self._seqid)
        args = EFAST_EditCustomDoc_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_EditCustomDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_EditCustomDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_EditCustomDocManager(self, docId, userId):
        """
        设置自定义文档库的管理员

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - docId
         - userId

        """
        self.send_EFAST_EditCustomDocManager(docId, userId)
        self.recv_EFAST_EditCustomDocManager()

    def send_EFAST_EditCustomDocManager(self, docId, userId):
        self._oprot.writeMessageBegin('EFAST_EditCustomDocManager', TMessageType.CALL, self._seqid)
        args = EFAST_EditCustomDocManager_args()
        args.docId = docId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_EditCustomDocManager(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_EditCustomDocManager_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_DeleteCustomDoc(self, info):
        """
        删除自定义文档库

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - info

        """
        self.send_EFAST_DeleteCustomDoc(info)
        self.recv_EFAST_DeleteCustomDoc()

    def send_EFAST_DeleteCustomDoc(self, info):
        self._oprot.writeMessageBegin('EFAST_DeleteCustomDoc', TMessageType.CALL, self._seqid)
        args = EFAST_DeleteCustomDoc_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_DeleteCustomDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_DeleteCustomDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_GetCustomDocCnt(self, userId):
        """
        获取自定义文档库总数
        @param userId: 用户id
        @ret: 自定义文档库总数
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EFAST_GetCustomDocCnt(userId)
        return self.recv_EFAST_GetCustomDocCnt()

    def send_EFAST_GetCustomDocCnt(self, userId):
        self._oprot.writeMessageBegin('EFAST_GetCustomDocCnt', TMessageType.CALL, self._seqid)
        args = EFAST_GetCustomDocCnt_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetCustomDocCnt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetCustomDocCnt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetCustomDocCnt failed: unknown result")

    def EFAST_GetCustomDocByObjId(self, objId):
        """
        根据文档库的对象id获取文档库信息

        @ret: 返回文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - objId

        """
        self.send_EFAST_GetCustomDocByObjId(objId)
        return self.recv_EFAST_GetCustomDocByObjId()

    def send_EFAST_GetCustomDocByObjId(self, objId):
        self._oprot.writeMessageBegin('EFAST_GetCustomDocByObjId', TMessageType.CALL, self._seqid)
        args = EFAST_GetCustomDocByObjId_args()
        args.objId = objId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetCustomDocByObjId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetCustomDocByObjId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetCustomDocByObjId failed: unknown result")

    def EFAST_GetCustomDocByDocId(self, docId):
        """
        根据文档库id获取文档库信息

        @ret: 返回文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - docId

        """
        self.send_EFAST_GetCustomDocByDocId(docId)
        return self.recv_EFAST_GetCustomDocByDocId()

    def send_EFAST_GetCustomDocByDocId(self, docId):
        self._oprot.writeMessageBegin('EFAST_GetCustomDocByDocId', TMessageType.CALL, self._seqid)
        args = EFAST_GetCustomDocByDocId_args()
        args.docId = docId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetCustomDocByDocId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetCustomDocByDocId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetCustomDocByDocId failed: unknown result")

    def EFAST_GetCustomDocInfosByPage(self, start, limit, userId):
        """
        分页获取自定义文档库信息
        @param start: 起始索引
        @param limit: 获取文档数
        @param userId: 用户id
        @ret: 文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - start
         - limit
         - userId

        """
        self.send_EFAST_GetCustomDocInfosByPage(start, limit, userId)
        return self.recv_EFAST_GetCustomDocInfosByPage()

    def send_EFAST_GetCustomDocInfosByPage(self, start, limit, userId):
        self._oprot.writeMessageBegin('EFAST_GetCustomDocInfosByPage', TMessageType.CALL, self._seqid)
        args = EFAST_GetCustomDocInfosByPage_args()
        args.start = start
        args.limit = limit
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetCustomDocInfosByPage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetCustomDocInfosByPage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetCustomDocInfosByPage failed: unknown result")

    def EFAST_CheckDocSpace(self, userId, docIds, quota):
        """
        批量编辑文档库配额前检查空间是否足够
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - docIds
         - quota

        """
        self.send_EFAST_CheckDocSpace(userId, docIds, quota)
        self.recv_EFAST_CheckDocSpace()

    def send_EFAST_CheckDocSpace(self, userId, docIds, quota):
        self._oprot.writeMessageBegin('EFAST_CheckDocSpace', TMessageType.CALL, self._seqid)
        args = EFAST_CheckDocSpace_args()
        args.userId = userId
        args.docIds = docIds
        args.quota = quota
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_CheckDocSpace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_CheckDocSpace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_SetQuotaInfo(self, userId, docId, quota):
        """
        编辑文档库配额
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - docId
         - quota

        """
        self.send_EFAST_SetQuotaInfo(userId, docId, quota)
        self.recv_EFAST_SetQuotaInfo()

    def send_EFAST_SetQuotaInfo(self, userId, docId, quota):
        self._oprot.writeMessageBegin('EFAST_SetQuotaInfo', TMessageType.CALL, self._seqid)
        args = EFAST_SetQuotaInfo_args()
        args.userId = userId
        args.docId = docId
        args.quota = quota
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SetQuotaInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SetQuotaInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_SearchCustomDocInfos(self, param):
        """
        搜索用户自定义文档库信息

        Parameters:
         - param

        """
        self.send_EFAST_SearchCustomDocInfos(param)
        return self.recv_EFAST_SearchCustomDocInfos()

    def send_EFAST_SearchCustomDocInfos(self, param):
        self._oprot.writeMessageBegin('EFAST_SearchCustomDocInfos', TMessageType.CALL, self._seqid)
        args = EFAST_SearchCustomDocInfos_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SearchCustomDocInfos(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SearchCustomDocInfos_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_SearchCustomDocInfos failed: unknown result")

    def EFAST_GetSearchCustomDocCnt(self, param):
        """
        获取搜索用户自定义文档库信息条目数量

        Parameters:
         - param

        """
        self.send_EFAST_GetSearchCustomDocCnt(param)
        return self.recv_EFAST_GetSearchCustomDocCnt()

    def send_EFAST_GetSearchCustomDocCnt(self, param):
        self._oprot.writeMessageBegin('EFAST_GetSearchCustomDocCnt', TMessageType.CALL, self._seqid)
        args = EFAST_GetSearchCustomDocCnt_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetSearchCustomDocCnt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetSearchCustomDocCnt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetSearchCustomDocCnt failed: unknown result")

    def EFAST_EditDocLibrarySiteId(self, docId, siteId):
        """
        设置文档库归属站点(限制个人文档)

        @throw EThriftException.ncTException

        Parameters:
         - docId
         - siteId

        """
        self.send_EFAST_EditDocLibrarySiteId(docId, siteId)
        self.recv_EFAST_EditDocLibrarySiteId()

    def send_EFAST_EditDocLibrarySiteId(self, docId, siteId):
        self._oprot.writeMessageBegin('EFAST_EditDocLibrarySiteId', TMessageType.CALL, self._seqid)
        args = EFAST_EditDocLibrarySiteId_args()
        args.docId = docId
        args.siteId = siteId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_EditDocLibrarySiteId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_EditDocLibrarySiteId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_BatchAddCustomDocs(self, param):
        """
        创建批量新建自定义文档库任务

        @ret: 返回创建的任务id
        @throw EThriftException.ncTException

        Parameters:
         - param

        """
        self.send_EFAST_BatchAddCustomDocs(param)
        return self.recv_EFAST_BatchAddCustomDocs()

    def send_EFAST_BatchAddCustomDocs(self, param):
        self._oprot.writeMessageBegin('EFAST_BatchAddCustomDocs', TMessageType.CALL, self._seqid)
        args = EFAST_BatchAddCustomDocs_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_BatchAddCustomDocs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_BatchAddCustomDocs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_BatchAddCustomDocs failed: unknown result")

    def EFAST_GetBatchAddCustomDocsResult(self, taskId):
        """
        查询批量新建自定义文档库结果

        @ret: 返回创建的结果
        @throw EThriftException.ncTException

        Parameters:
         - taskId

        """
        self.send_EFAST_GetBatchAddCustomDocsResult(taskId)
        return self.recv_EFAST_GetBatchAddCustomDocsResult()

    def send_EFAST_GetBatchAddCustomDocsResult(self, taskId):
        self._oprot.writeMessageBegin('EFAST_GetBatchAddCustomDocsResult', TMessageType.CALL, self._seqid)
        args = EFAST_GetBatchAddCustomDocsResult_args()
        args.taskId = taskId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetBatchAddCustomDocsResult(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetBatchAddCustomDocsResult_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetBatchAddCustomDocsResult failed: unknown result")

    def EFAST_SearchAvailableCustomDocInfos(self, param):
        """
        搜索用户自定义文档库信息 (组织管理员的结果中包含有所有者权限的文档库信息)

        Parameters:
         - param

        """
        self.send_EFAST_SearchAvailableCustomDocInfos(param)
        return self.recv_EFAST_SearchAvailableCustomDocInfos()

    def send_EFAST_SearchAvailableCustomDocInfos(self, param):
        self._oprot.writeMessageBegin('EFAST_SearchAvailableCustomDocInfos', TMessageType.CALL, self._seqid)
        args = EFAST_SearchAvailableCustomDocInfos_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SearchAvailableCustomDocInfos(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SearchAvailableCustomDocInfos_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_SearchAvailableCustomDocInfos failed: unknown result")

    def EFAST_GetSearchAvailableCustomDocCnt(self, param):
        """
        获取搜索用户自定义文档库信息条目数量 (组织管理员的结果中包含有所有者权限的文档库)

        Parameters:
         - param

        """
        self.send_EFAST_GetSearchAvailableCustomDocCnt(param)
        return self.recv_EFAST_GetSearchAvailableCustomDocCnt()

    def send_EFAST_GetSearchAvailableCustomDocCnt(self, param):
        self._oprot.writeMessageBegin('EFAST_GetSearchAvailableCustomDocCnt', TMessageType.CALL, self._seqid)
        args = EFAST_GetSearchAvailableCustomDocCnt_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetSearchAvailableCustomDocCnt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetSearchAvailableCustomDocCnt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetSearchAvailableCustomDocCnt failed: unknown result")

    def EFAST_EditDisplayOrder(self, docId, userId, displayOrder):
        """
        修改自定义文档库的显示顺序

        Parameters:
         - docId
         - userId
         - displayOrder

        """
        self.send_EFAST_EditDisplayOrder(docId, userId, displayOrder)
        self.recv_EFAST_EditDisplayOrder()

    def send_EFAST_EditDisplayOrder(self, docId, userId, displayOrder):
        self._oprot.writeMessageBegin('EFAST_EditDisplayOrder', TMessageType.CALL, self._seqid)
        args = EFAST_EditDisplayOrder_args()
        args.docId = docId
        args.userId = userId
        args.displayOrder = displayOrder
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_EditDisplayOrder(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_EditDisplayOrder_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_MoveUserDoc(self, adminId, userId, docId):
        """
        移动个人文档

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - adminId
         - userId
         - docId

        """
        self.send_EFAST_MoveUserDoc(adminId, userId, docId)
        return self.recv_EFAST_MoveUserDoc()

    def send_EFAST_MoveUserDoc(self, adminId, userId, docId):
        self._oprot.writeMessageBegin('EFAST_MoveUserDoc', TMessageType.CALL, self._seqid)
        args = EFAST_MoveUserDoc_args()
        args.adminId = adminId
        args.userId = userId
        args.docId = docId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_MoveUserDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_MoveUserDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_MoveUserDoc failed: unknown result")

    def EFAST_MoveEntryDoc(self, adminId, sourceDocId, targetDocId):
        """
        移动个人文档（文档库恢复使用）

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - adminId
         - sourceDocId
         - targetDocId

        """
        self.send_EFAST_MoveEntryDoc(adminId, sourceDocId, targetDocId)
        return self.recv_EFAST_MoveEntryDoc()

    def send_EFAST_MoveEntryDoc(self, adminId, sourceDocId, targetDocId):
        self._oprot.writeMessageBegin('EFAST_MoveEntryDoc', TMessageType.CALL, self._seqid)
        args = EFAST_MoveEntryDoc_args()
        args.adminId = adminId
        args.sourceDocId = sourceDocId
        args.targetDocId = targetDocId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_MoveEntryDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_MoveEntryDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_MoveEntryDoc failed: unknown result")

    def EFAST_DeleteUserDoc(self, userId, deleterId):
        """
        删除个人文档

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - deleterId

        """
        self.send_EFAST_DeleteUserDoc(userId, deleterId)
        return self.recv_EFAST_DeleteUserDoc()

    def send_EFAST_DeleteUserDoc(self, userId, deleterId):
        self._oprot.writeMessageBegin('EFAST_DeleteUserDoc', TMessageType.CALL, self._seqid)
        args = EFAST_DeleteUserDoc_args()
        args.userId = userId
        args.deleterId = deleterId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_DeleteUserDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_DeleteUserDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_DeleteUserDoc failed: unknown result")

    def EFAST_GetUserTotalQuota(self, userId):
        """
        获取个人总配额，bytes

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EFAST_GetUserTotalQuota(userId)
        return self.recv_EFAST_GetUserTotalQuota()

    def send_EFAST_GetUserTotalQuota(self, userId):
        self._oprot.writeMessageBegin('EFAST_GetUserTotalQuota', TMessageType.CALL, self._seqid)
        args = EFAST_GetUserTotalQuota_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetUserTotalQuota(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetUserTotalQuota_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetUserTotalQuota failed: unknown result")

    def EFAST_GetUserUsedQuota(self, userId):
        """
        获取个人已使用配额空间，bytes

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EFAST_GetUserUsedQuota(userId)
        return self.recv_EFAST_GetUserUsedQuota()

    def send_EFAST_GetUserUsedQuota(self, userId):
        self._oprot.writeMessageBegin('EFAST_GetUserUsedQuota', TMessageType.CALL, self._seqid)
        args = EFAST_GetUserUsedQuota_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetUserUsedQuota(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetUserUsedQuota_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetUserUsedQuota failed: unknown result")

    def EFAST_EditUserTotalQuota(self, userId, totalQuotaBytes):
        """
        编辑个人总配额，bytes

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - totalQuotaBytes

        """
        self.send_EFAST_EditUserTotalQuota(userId, totalQuotaBytes)
        self.recv_EFAST_EditUserTotalQuota()

    def send_EFAST_EditUserTotalQuota(self, userId, totalQuotaBytes):
        self._oprot.writeMessageBegin('EFAST_EditUserTotalQuota', TMessageType.CALL, self._seqid)
        args = EFAST_EditUserTotalQuota_args()
        args.userId = userId
        args.totalQuotaBytes = totalQuotaBytes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_EditUserTotalQuota(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_EditUserTotalQuota_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_GetAllUserDocById(self, userId):
        """
        检查用户是否有文档数据（包括个人文档）
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EFAST_GetAllUserDocById(userId)
        return self.recv_EFAST_GetAllUserDocById()

    def send_EFAST_GetAllUserDocById(self, userId):
        self._oprot.writeMessageBegin('EFAST_GetAllUserDocById', TMessageType.CALL, self._seqid)
        args = EFAST_GetAllUserDocById_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetAllUserDocById(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetAllUserDocById_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetAllUserDocById failed: unknown result")

    def EFAST_ConfictWithLibName(self, name):
        """
        检测用户显示名是否和自定义文档库、归档库名称冲突

        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - name

        """
        self.send_EFAST_ConfictWithLibName(name)
        return self.recv_EFAST_ConfictWithLibName()

    def send_EFAST_ConfictWithLibName(self, name):
        self._oprot.writeMessageBegin('EFAST_ConfictWithLibName', TMessageType.CALL, self._seqid)
        args = EFAST_ConfictWithLibName_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_ConfictWithLibName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_ConfictWithLibName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_ConfictWithLibName failed: unknown result")

    def EFAST_GetSpaceQuotaInfo(self, userId):
        """
        获取用户配额空间信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EFAST_GetSpaceQuotaInfo(userId)
        return self.recv_EFAST_GetSpaceQuotaInfo()

    def send_EFAST_GetSpaceQuotaInfo(self, userId):
        self._oprot.writeMessageBegin('EFAST_GetSpaceQuotaInfo', TMessageType.CALL, self._seqid)
        args = EFAST_GetSpaceQuotaInfo_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetSpaceQuotaInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetSpaceQuotaInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetSpaceQuotaInfo failed: unknown result")

    def EFAST_GetAllCustomDocTypeName(self):
        """
        获取所有文档库类型名
        @throw EThriftException.ncTException

        """
        self.send_EFAST_GetAllCustomDocTypeName()
        return self.recv_EFAST_GetAllCustomDocTypeName()

    def send_EFAST_GetAllCustomDocTypeName(self):
        self._oprot.writeMessageBegin('EFAST_GetAllCustomDocTypeName', TMessageType.CALL, self._seqid)
        args = EFAST_GetAllCustomDocTypeName_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetAllCustomDocTypeName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetAllCustomDocTypeName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetAllCustomDocTypeName failed: unknown result")

    def EFAST_GetUserGns(self, userId):
        """
        根据用户id获取gns路径
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EFAST_GetUserGns(userId)
        return self.recv_EFAST_GetUserGns()

    def send_EFAST_GetUserGns(self, userId):
        self._oprot.writeMessageBegin('EFAST_GetUserGns', TMessageType.CALL, self._seqid)
        args = EFAST_GetUserGns_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_GetUserGns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_GetUserGns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_GetUserGns failed: unknown result")

    def EFAST_SysRecycle_RestoreCustomDoc(self, docId, name, adminId):
        """
        根据自定义文档库docId和adminId恢复自定义文档库

        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - docId
         - name
         - adminId

        """
        self.send_EFAST_SysRecycle_RestoreCustomDoc(docId, name, adminId)
        self.recv_EFAST_SysRecycle_RestoreCustomDoc()

    def send_EFAST_SysRecycle_RestoreCustomDoc(self, docId, name, adminId):
        self._oprot.writeMessageBegin('EFAST_SysRecycle_RestoreCustomDoc', TMessageType.CALL, self._seqid)
        args = EFAST_SysRecycle_RestoreCustomDoc_args()
        args.docId = docId
        args.name = name
        args.adminId = adminId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SysRecycle_RestoreCustomDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SysRecycle_RestoreCustomDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_SysRecycle_RestoreUserDoc(self, docId, responsiblePersonId):
        """
        Parameters:
         - docId
         - responsiblePersonId

        """
        self.send_EFAST_SysRecycle_RestoreUserDoc(docId, responsiblePersonId)
        self.recv_EFAST_SysRecycle_RestoreUserDoc()

    def send_EFAST_SysRecycle_RestoreUserDoc(self, docId, responsiblePersonId):
        self._oprot.writeMessageBegin('EFAST_SysRecycle_RestoreUserDoc', TMessageType.CALL, self._seqid)
        args = EFAST_SysRecycle_RestoreUserDoc_args()
        args.docId = docId
        args.responsiblePersonId = responsiblePersonId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SysRecycle_RestoreUserDoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SysRecycle_RestoreUserDoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EFAST_SysRecycle_GetEntryDocInfos(self, start, limit, searchKey):
        """
        获取系统回收站的入口文档信息
        @param start: 起始索引
        @param limit: 获取文档数
        @param searchKey: 搜索关键字, 为空时查找所有
        @ret: 文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - start
         - limit
         - searchKey

        """
        self.send_EFAST_SysRecycle_GetEntryDocInfos(start, limit, searchKey)
        return self.recv_EFAST_SysRecycle_GetEntryDocInfos()

    def send_EFAST_SysRecycle_GetEntryDocInfos(self, start, limit, searchKey):
        self._oprot.writeMessageBegin('EFAST_SysRecycle_GetEntryDocInfos', TMessageType.CALL, self._seqid)
        args = EFAST_SysRecycle_GetEntryDocInfos_args()
        args.start = start
        args.limit = limit
        args.searchKey = searchKey
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SysRecycle_GetEntryDocInfos(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SysRecycle_GetEntryDocInfos_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_SysRecycle_GetEntryDocInfos failed: unknown result")

    def EFAST_SysRecycle_GetEntryDocInfoByDocId(self, docId):
        """
        根据docId(cid)获取系统回收站的入口文档信息
        @param docId: 文档id
        @ret: 文档库信息
        @throw EThriftException.ncTException

        Parameters:
         - docId

        """
        self.send_EFAST_SysRecycle_GetEntryDocInfoByDocId(docId)
        return self.recv_EFAST_SysRecycle_GetEntryDocInfoByDocId()

    def send_EFAST_SysRecycle_GetEntryDocInfoByDocId(self, docId):
        self._oprot.writeMessageBegin('EFAST_SysRecycle_GetEntryDocInfoByDocId', TMessageType.CALL, self._seqid)
        args = EFAST_SysRecycle_GetEntryDocInfoByDocId_args()
        args.docId = docId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_SysRecycle_GetEntryDocInfoByDocId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_SysRecycle_GetEntryDocInfoByDocId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EFAST_SysRecycle_GetEntryDocInfoByDocId failed: unknown result")

    def EFAST_OnDeleteDepartment(self, departmentIds):
        """
        删除部门时通知efast删除文档库的关联部门

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - departmentIds

        """
        self.send_EFAST_OnDeleteDepartment(departmentIds)
        self.recv_EFAST_OnDeleteDepartment()

    def send_EFAST_OnDeleteDepartment(self, departmentIds):
        self._oprot.writeMessageBegin('EFAST_OnDeleteDepartment', TMessageType.CALL, self._seqid)
        args = EFAST_OnDeleteDepartment_args()
        args.departmentIds = departmentIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EFAST_OnDeleteDepartment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EFAST_OnDeleteDepartment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["EFAST_Start"] = Processor.process_EFAST_Start
        self._processMap["EFAST_Stop"] = Processor.process_EFAST_Stop
        self._processMap["EFAST_GetServiceState"] = Processor.process_EFAST_GetServiceState
        self._processMap["EFSHttp_SetPort"] = Processor.process_EFSHttp_SetPort
        self._processMap["EFSHttp_GetPort"] = Processor.process_EFSHttp_GetPort
        self._processMap["EFSHttp_SetMaxConcurrency"] = Processor.process_EFSHttp_SetMaxConcurrency
        self._processMap["EFSHttp_GetMaxConcurrency"] = Processor.process_EFSHttp_GetMaxConcurrency
        self._processMap["EFAST_AddUserDoc"] = Processor.process_EFAST_AddUserDoc
        self._processMap["EFAST_AddCustomDoc"] = Processor.process_EFAST_AddCustomDoc
        self._processMap["EFAST_AddCustomDocEx"] = Processor.process_EFAST_AddCustomDocEx
        self._processMap["EFAST_EditCustomDoc"] = Processor.process_EFAST_EditCustomDoc
        self._processMap["EFAST_EditCustomDocManager"] = Processor.process_EFAST_EditCustomDocManager
        self._processMap["EFAST_DeleteCustomDoc"] = Processor.process_EFAST_DeleteCustomDoc
        self._processMap["EFAST_GetCustomDocCnt"] = Processor.process_EFAST_GetCustomDocCnt
        self._processMap["EFAST_GetCustomDocByObjId"] = Processor.process_EFAST_GetCustomDocByObjId
        self._processMap["EFAST_GetCustomDocByDocId"] = Processor.process_EFAST_GetCustomDocByDocId
        self._processMap["EFAST_GetCustomDocInfosByPage"] = Processor.process_EFAST_GetCustomDocInfosByPage
        self._processMap["EFAST_CheckDocSpace"] = Processor.process_EFAST_CheckDocSpace
        self._processMap["EFAST_SetQuotaInfo"] = Processor.process_EFAST_SetQuotaInfo
        self._processMap["EFAST_SearchCustomDocInfos"] = Processor.process_EFAST_SearchCustomDocInfos
        self._processMap["EFAST_GetSearchCustomDocCnt"] = Processor.process_EFAST_GetSearchCustomDocCnt
        self._processMap["EFAST_EditDocLibrarySiteId"] = Processor.process_EFAST_EditDocLibrarySiteId
        self._processMap["EFAST_BatchAddCustomDocs"] = Processor.process_EFAST_BatchAddCustomDocs
        self._processMap["EFAST_GetBatchAddCustomDocsResult"] = Processor.process_EFAST_GetBatchAddCustomDocsResult
        self._processMap["EFAST_SearchAvailableCustomDocInfos"] = Processor.process_EFAST_SearchAvailableCustomDocInfos
        self._processMap["EFAST_GetSearchAvailableCustomDocCnt"] = Processor.process_EFAST_GetSearchAvailableCustomDocCnt
        self._processMap["EFAST_EditDisplayOrder"] = Processor.process_EFAST_EditDisplayOrder
        self._processMap["EFAST_MoveUserDoc"] = Processor.process_EFAST_MoveUserDoc
        self._processMap["EFAST_MoveEntryDoc"] = Processor.process_EFAST_MoveEntryDoc
        self._processMap["EFAST_DeleteUserDoc"] = Processor.process_EFAST_DeleteUserDoc
        self._processMap["EFAST_GetUserTotalQuota"] = Processor.process_EFAST_GetUserTotalQuota
        self._processMap["EFAST_GetUserUsedQuota"] = Processor.process_EFAST_GetUserUsedQuota
        self._processMap["EFAST_EditUserTotalQuota"] = Processor.process_EFAST_EditUserTotalQuota
        self._processMap["EFAST_GetAllUserDocById"] = Processor.process_EFAST_GetAllUserDocById
        self._processMap["EFAST_ConfictWithLibName"] = Processor.process_EFAST_ConfictWithLibName
        self._processMap["EFAST_GetSpaceQuotaInfo"] = Processor.process_EFAST_GetSpaceQuotaInfo
        self._processMap["EFAST_GetAllCustomDocTypeName"] = Processor.process_EFAST_GetAllCustomDocTypeName
        self._processMap["EFAST_GetUserGns"] = Processor.process_EFAST_GetUserGns
        self._processMap["EFAST_SysRecycle_RestoreCustomDoc"] = Processor.process_EFAST_SysRecycle_RestoreCustomDoc
        self._processMap["EFAST_SysRecycle_RestoreUserDoc"] = Processor.process_EFAST_SysRecycle_RestoreUserDoc
        self._processMap["EFAST_SysRecycle_GetEntryDocInfos"] = Processor.process_EFAST_SysRecycle_GetEntryDocInfos
        self._processMap["EFAST_SysRecycle_GetEntryDocInfoByDocId"] = Processor.process_EFAST_SysRecycle_GetEntryDocInfoByDocId
        self._processMap["EFAST_OnDeleteDepartment"] = Processor.process_EFAST_OnDeleteDepartment
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_EFAST_Start(self, seqid, iprot, oprot):
        args = EFAST_Start_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_Start_result()
        try:
            self._handler.EFAST_Start()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_Start", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_Stop(self, seqid, iprot, oprot):
        args = EFAST_Stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_Stop_result()
        try:
            self._handler.EFAST_Stop()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_Stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetServiceState(self, seqid, iprot, oprot):
        args = EFAST_GetServiceState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetServiceState_result()
        try:
            result.success = self._handler.EFAST_GetServiceState()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetServiceState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFSHttp_SetPort(self, seqid, iprot, oprot):
        args = EFSHttp_SetPort_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFSHttp_SetPort_result()
        try:
            self._handler.EFSHttp_SetPort(args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFSHttp_SetPort", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFSHttp_GetPort(self, seqid, iprot, oprot):
        args = EFSHttp_GetPort_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFSHttp_GetPort_result()
        try:
            result.success = self._handler.EFSHttp_GetPort()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFSHttp_GetPort", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFSHttp_SetMaxConcurrency(self, seqid, iprot, oprot):
        args = EFSHttp_SetMaxConcurrency_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFSHttp_SetMaxConcurrency_result()
        try:
            self._handler.EFSHttp_SetMaxConcurrency(args.processPoolCount)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFSHttp_SetMaxConcurrency", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFSHttp_GetMaxConcurrency(self, seqid, iprot, oprot):
        args = EFSHttp_GetMaxConcurrency_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFSHttp_GetMaxConcurrency_result()
        try:
            result.success = self._handler.EFSHttp_GetMaxConcurrency()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFSHttp_GetMaxConcurrency", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_AddUserDoc(self, seqid, iprot, oprot):
        args = EFAST_AddUserDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_AddUserDoc_result()
        try:
            self._handler.EFAST_AddUserDoc(args.userId, args.totalQuotaBytes, args.responsiblePersonId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_AddUserDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_AddCustomDoc(self, seqid, iprot, oprot):
        args = EFAST_AddCustomDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_AddCustomDoc_result()
        try:
            result.success = self._handler.EFAST_AddCustomDoc(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_AddCustomDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_AddCustomDocEx(self, seqid, iprot, oprot):
        args = EFAST_AddCustomDocEx_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_AddCustomDocEx_result()
        try:
            result.success = self._handler.EFAST_AddCustomDocEx(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_AddCustomDocEx", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_EditCustomDoc(self, seqid, iprot, oprot):
        args = EFAST_EditCustomDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_EditCustomDoc_result()
        try:
            self._handler.EFAST_EditCustomDoc(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_EditCustomDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_EditCustomDocManager(self, seqid, iprot, oprot):
        args = EFAST_EditCustomDocManager_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_EditCustomDocManager_result()
        try:
            self._handler.EFAST_EditCustomDocManager(args.docId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_EditCustomDocManager", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_DeleteCustomDoc(self, seqid, iprot, oprot):
        args = EFAST_DeleteCustomDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_DeleteCustomDoc_result()
        try:
            self._handler.EFAST_DeleteCustomDoc(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_DeleteCustomDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetCustomDocCnt(self, seqid, iprot, oprot):
        args = EFAST_GetCustomDocCnt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetCustomDocCnt_result()
        try:
            result.success = self._handler.EFAST_GetCustomDocCnt(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetCustomDocCnt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetCustomDocByObjId(self, seqid, iprot, oprot):
        args = EFAST_GetCustomDocByObjId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetCustomDocByObjId_result()
        try:
            result.success = self._handler.EFAST_GetCustomDocByObjId(args.objId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetCustomDocByObjId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetCustomDocByDocId(self, seqid, iprot, oprot):
        args = EFAST_GetCustomDocByDocId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetCustomDocByDocId_result()
        try:
            result.success = self._handler.EFAST_GetCustomDocByDocId(args.docId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetCustomDocByDocId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetCustomDocInfosByPage(self, seqid, iprot, oprot):
        args = EFAST_GetCustomDocInfosByPage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetCustomDocInfosByPage_result()
        try:
            result.success = self._handler.EFAST_GetCustomDocInfosByPage(args.start, args.limit, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetCustomDocInfosByPage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_CheckDocSpace(self, seqid, iprot, oprot):
        args = EFAST_CheckDocSpace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_CheckDocSpace_result()
        try:
            self._handler.EFAST_CheckDocSpace(args.userId, args.docIds, args.quota)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_CheckDocSpace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SetQuotaInfo(self, seqid, iprot, oprot):
        args = EFAST_SetQuotaInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SetQuotaInfo_result()
        try:
            self._handler.EFAST_SetQuotaInfo(args.userId, args.docId, args.quota)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SetQuotaInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SearchCustomDocInfos(self, seqid, iprot, oprot):
        args = EFAST_SearchCustomDocInfos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SearchCustomDocInfos_result()
        try:
            result.success = self._handler.EFAST_SearchCustomDocInfos(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SearchCustomDocInfos", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetSearchCustomDocCnt(self, seqid, iprot, oprot):
        args = EFAST_GetSearchCustomDocCnt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetSearchCustomDocCnt_result()
        try:
            result.success = self._handler.EFAST_GetSearchCustomDocCnt(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetSearchCustomDocCnt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_EditDocLibrarySiteId(self, seqid, iprot, oprot):
        args = EFAST_EditDocLibrarySiteId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_EditDocLibrarySiteId_result()
        try:
            self._handler.EFAST_EditDocLibrarySiteId(args.docId, args.siteId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_EditDocLibrarySiteId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_BatchAddCustomDocs(self, seqid, iprot, oprot):
        args = EFAST_BatchAddCustomDocs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_BatchAddCustomDocs_result()
        try:
            result.success = self._handler.EFAST_BatchAddCustomDocs(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_BatchAddCustomDocs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetBatchAddCustomDocsResult(self, seqid, iprot, oprot):
        args = EFAST_GetBatchAddCustomDocsResult_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetBatchAddCustomDocsResult_result()
        try:
            result.success = self._handler.EFAST_GetBatchAddCustomDocsResult(args.taskId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetBatchAddCustomDocsResult", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SearchAvailableCustomDocInfos(self, seqid, iprot, oprot):
        args = EFAST_SearchAvailableCustomDocInfos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SearchAvailableCustomDocInfos_result()
        try:
            result.success = self._handler.EFAST_SearchAvailableCustomDocInfos(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SearchAvailableCustomDocInfos", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetSearchAvailableCustomDocCnt(self, seqid, iprot, oprot):
        args = EFAST_GetSearchAvailableCustomDocCnt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetSearchAvailableCustomDocCnt_result()
        try:
            result.success = self._handler.EFAST_GetSearchAvailableCustomDocCnt(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetSearchAvailableCustomDocCnt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_EditDisplayOrder(self, seqid, iprot, oprot):
        args = EFAST_EditDisplayOrder_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_EditDisplayOrder_result()
        try:
            self._handler.EFAST_EditDisplayOrder(args.docId, args.userId, args.displayOrder)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_EditDisplayOrder", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_MoveUserDoc(self, seqid, iprot, oprot):
        args = EFAST_MoveUserDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_MoveUserDoc_result()
        try:
            result.success = self._handler.EFAST_MoveUserDoc(args.adminId, args.userId, args.docId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_MoveUserDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_MoveEntryDoc(self, seqid, iprot, oprot):
        args = EFAST_MoveEntryDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_MoveEntryDoc_result()
        try:
            result.success = self._handler.EFAST_MoveEntryDoc(args.adminId, args.sourceDocId, args.targetDocId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_MoveEntryDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_DeleteUserDoc(self, seqid, iprot, oprot):
        args = EFAST_DeleteUserDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_DeleteUserDoc_result()
        try:
            result.success = self._handler.EFAST_DeleteUserDoc(args.userId, args.deleterId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_DeleteUserDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetUserTotalQuota(self, seqid, iprot, oprot):
        args = EFAST_GetUserTotalQuota_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetUserTotalQuota_result()
        try:
            result.success = self._handler.EFAST_GetUserTotalQuota(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetUserTotalQuota", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetUserUsedQuota(self, seqid, iprot, oprot):
        args = EFAST_GetUserUsedQuota_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetUserUsedQuota_result()
        try:
            result.success = self._handler.EFAST_GetUserUsedQuota(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetUserUsedQuota", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_EditUserTotalQuota(self, seqid, iprot, oprot):
        args = EFAST_EditUserTotalQuota_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_EditUserTotalQuota_result()
        try:
            self._handler.EFAST_EditUserTotalQuota(args.userId, args.totalQuotaBytes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_EditUserTotalQuota", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetAllUserDocById(self, seqid, iprot, oprot):
        args = EFAST_GetAllUserDocById_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetAllUserDocById_result()
        try:
            result.success = self._handler.EFAST_GetAllUserDocById(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetAllUserDocById", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_ConfictWithLibName(self, seqid, iprot, oprot):
        args = EFAST_ConfictWithLibName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_ConfictWithLibName_result()
        try:
            result.success = self._handler.EFAST_ConfictWithLibName(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_ConfictWithLibName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetSpaceQuotaInfo(self, seqid, iprot, oprot):
        args = EFAST_GetSpaceQuotaInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetSpaceQuotaInfo_result()
        try:
            result.success = self._handler.EFAST_GetSpaceQuotaInfo(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetSpaceQuotaInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetAllCustomDocTypeName(self, seqid, iprot, oprot):
        args = EFAST_GetAllCustomDocTypeName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetAllCustomDocTypeName_result()
        try:
            result.success = self._handler.EFAST_GetAllCustomDocTypeName()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetAllCustomDocTypeName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_GetUserGns(self, seqid, iprot, oprot):
        args = EFAST_GetUserGns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_GetUserGns_result()
        try:
            result.success = self._handler.EFAST_GetUserGns(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_GetUserGns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SysRecycle_RestoreCustomDoc(self, seqid, iprot, oprot):
        args = EFAST_SysRecycle_RestoreCustomDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SysRecycle_RestoreCustomDoc_result()
        try:
            self._handler.EFAST_SysRecycle_RestoreCustomDoc(args.docId, args.name, args.adminId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SysRecycle_RestoreCustomDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SysRecycle_RestoreUserDoc(self, seqid, iprot, oprot):
        args = EFAST_SysRecycle_RestoreUserDoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SysRecycle_RestoreUserDoc_result()
        try:
            self._handler.EFAST_SysRecycle_RestoreUserDoc(args.docId, args.responsiblePersonId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SysRecycle_RestoreUserDoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SysRecycle_GetEntryDocInfos(self, seqid, iprot, oprot):
        args = EFAST_SysRecycle_GetEntryDocInfos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SysRecycle_GetEntryDocInfos_result()
        try:
            result.success = self._handler.EFAST_SysRecycle_GetEntryDocInfos(args.start, args.limit, args.searchKey)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SysRecycle_GetEntryDocInfos", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_SysRecycle_GetEntryDocInfoByDocId(self, seqid, iprot, oprot):
        args = EFAST_SysRecycle_GetEntryDocInfoByDocId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_SysRecycle_GetEntryDocInfoByDocId_result()
        try:
            result.success = self._handler.EFAST_SysRecycle_GetEntryDocInfoByDocId(args.docId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_SysRecycle_GetEntryDocInfoByDocId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EFAST_OnDeleteDepartment(self, seqid, iprot, oprot):
        args = EFAST_OnDeleteDepartment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EFAST_OnDeleteDepartment_result()
        try:
            self._handler.EFAST_OnDeleteDepartment(args.departmentIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EFAST_OnDeleteDepartment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class EFAST_Start_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_Start_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_Start_args)
EFAST_Start_args.thrift_spec = (
)


class EFAST_Start_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_Start_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_Start_result)
EFAST_Start_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_Stop_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_Stop_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_Stop_args)
EFAST_Stop_args.thrift_spec = (
)


class EFAST_Stop_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_Stop_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_Stop_result)
EFAST_Stop_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetServiceState_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetServiceState_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetServiceState_args)
EFAST_GetServiceState_args.thrift_spec = (
)


class EFAST_GetServiceState_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetServiceState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetServiceState_result)
EFAST_GetServiceState_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class EFSHttp_SetPort_args(object):
    """
    Attributes:
     - port

    """


    def __init__(self, port=None,):
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_SetPort_args')
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 1)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_SetPort_args)
EFSHttp_SetPort_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'port', None, None, ),  # 1
)


class EFSHttp_SetPort_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_SetPort_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_SetPort_result)
EFSHttp_SetPort_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFSHttp_GetPort_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_GetPort_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_GetPort_args)
EFSHttp_GetPort_args.thrift_spec = (
)


class EFSHttp_GetPort_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_GetPort_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_GetPort_result)
EFSHttp_GetPort_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFSHttp_SetMaxConcurrency_args(object):
    """
    Attributes:
     - processPoolCount

    """


    def __init__(self, processPoolCount=None,):
        self.processPoolCount = processPoolCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.processPoolCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_SetMaxConcurrency_args')
        if self.processPoolCount is not None:
            oprot.writeFieldBegin('processPoolCount', TType.I32, 1)
            oprot.writeI32(self.processPoolCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_SetMaxConcurrency_args)
EFSHttp_SetMaxConcurrency_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'processPoolCount', None, None, ),  # 1
)


class EFSHttp_SetMaxConcurrency_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_SetMaxConcurrency_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_SetMaxConcurrency_result)
EFSHttp_SetMaxConcurrency_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFSHttp_GetMaxConcurrency_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_GetMaxConcurrency_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_GetMaxConcurrency_args)
EFSHttp_GetMaxConcurrency_args.thrift_spec = (
)


class EFSHttp_GetMaxConcurrency_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFSHttp_GetMaxConcurrency_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFSHttp_GetMaxConcurrency_result)
EFSHttp_GetMaxConcurrency_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_AddUserDoc_args(object):
    """
    Attributes:
     - userId
     - totalQuotaBytes
     - responsiblePersonId

    """


    def __init__(self, userId=None, totalQuotaBytes=None, responsiblePersonId=None,):
        self.userId = userId
        self.totalQuotaBytes = totalQuotaBytes
        self.responsiblePersonId = responsiblePersonId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.totalQuotaBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.responsiblePersonId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_AddUserDoc_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.totalQuotaBytes is not None:
            oprot.writeFieldBegin('totalQuotaBytes', TType.I64, 2)
            oprot.writeI64(self.totalQuotaBytes)
            oprot.writeFieldEnd()
        if self.responsiblePersonId is not None:
            oprot.writeFieldBegin('responsiblePersonId', TType.STRING, 3)
            oprot.writeString(self.responsiblePersonId.encode('utf-8') if sys.version_info[0] == 2 else self.responsiblePersonId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_AddUserDoc_args)
EFAST_AddUserDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'totalQuotaBytes', None, None, ),  # 2
    (3, TType.STRING, 'responsiblePersonId', 'UTF8', None, ),  # 3
)


class EFAST_AddUserDoc_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_AddUserDoc_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_AddUserDoc_result)
EFAST_AddUserDoc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_AddCustomDoc_args(object):
    """
    Attributes:
     - info

    """


    def __init__(self, info=None,):
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ncTAddCustomDocParam()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_AddCustomDoc_args')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_AddCustomDoc_args)
EFAST_AddCustomDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [ncTAddCustomDocParam, None], None, ),  # 1
)


class EFAST_AddCustomDoc_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_AddCustomDoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_AddCustomDoc_result)
EFAST_AddCustomDoc_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_AddCustomDocEx_args(object):
    """
    Attributes:
     - info

    """


    def __init__(self, info=None,):
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ncTAddCustomDocParamEx()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_AddCustomDocEx_args')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_AddCustomDocEx_args)
EFAST_AddCustomDocEx_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [ncTAddCustomDocParamEx, None], None, ),  # 1
)


class EFAST_AddCustomDocEx_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_AddCustomDocEx_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_AddCustomDocEx_result)
EFAST_AddCustomDocEx_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_EditCustomDoc_args(object):
    """
    Attributes:
     - info

    """


    def __init__(self, info=None,):
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ncTEditCustomDocParam()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditCustomDoc_args')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditCustomDoc_args)
EFAST_EditCustomDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [ncTEditCustomDocParam, None], None, ),  # 1
)


class EFAST_EditCustomDoc_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditCustomDoc_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditCustomDoc_result)
EFAST_EditCustomDoc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_EditCustomDocManager_args(object):
    """
    Attributes:
     - docId
     - userId

    """


    def __init__(self, docId=None, userId=None,):
        self.docId = docId
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditCustomDocManager_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditCustomDocManager_args)
EFAST_EditCustomDocManager_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class EFAST_EditCustomDocManager_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditCustomDocManager_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditCustomDocManager_result)
EFAST_EditCustomDocManager_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_DeleteCustomDoc_args(object):
    """
    Attributes:
     - info

    """


    def __init__(self, info=None,):
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ncTDeleteCustomDocParam()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_DeleteCustomDoc_args')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_DeleteCustomDoc_args)
EFAST_DeleteCustomDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [ncTDeleteCustomDocParam, None], None, ),  # 1
)


class EFAST_DeleteCustomDoc_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_DeleteCustomDoc_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_DeleteCustomDoc_result)
EFAST_DeleteCustomDoc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetCustomDocCnt_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocCnt_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocCnt_args)
EFAST_GetCustomDocCnt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EFAST_GetCustomDocCnt_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocCnt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocCnt_result)
EFAST_GetCustomDocCnt_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetCustomDocByObjId_args(object):
    """
    Attributes:
     - objId

    """


    def __init__(self, objId=None,):
        self.objId = objId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.objId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocByObjId_args')
        if self.objId is not None:
            oprot.writeFieldBegin('objId', TType.STRING, 1)
            oprot.writeString(self.objId.encode('utf-8') if sys.version_info[0] == 2 else self.objId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocByObjId_args)
EFAST_GetCustomDocByObjId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'objId', 'UTF8', None, ),  # 1
)


class EFAST_GetCustomDocByObjId_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTCustomDocInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocByObjId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocByObjId_result)
EFAST_GetCustomDocByObjId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTCustomDocInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetCustomDocByDocId_args(object):
    """
    Attributes:
     - docId

    """


    def __init__(self, docId=None,):
        self.docId = docId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocByDocId_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocByDocId_args)
EFAST_GetCustomDocByDocId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
)


class EFAST_GetCustomDocByDocId_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTCustomDocInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocByDocId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocByDocId_result)
EFAST_GetCustomDocByDocId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTCustomDocInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetCustomDocInfosByPage_args(object):
    """
    Attributes:
     - start
     - limit
     - userId

    """


    def __init__(self, start=None, limit=None, userId=None,):
        self.start = start
        self.limit = limit
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocInfosByPage_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 1)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 3)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocInfosByPage_args)
EFAST_GetCustomDocInfosByPage_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'start', None, None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
    (3, TType.STRING, 'userId', 'UTF8', None, ),  # 3
)


class EFAST_GetCustomDocInfosByPage_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = ncTCustomDocInfo()
                        _elem82.read(iprot)
                        self.success.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetCustomDocInfosByPage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter83 in self.success:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetCustomDocInfosByPage_result)
EFAST_GetCustomDocInfosByPage_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTCustomDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_CheckDocSpace_args(object):
    """
    Attributes:
     - userId
     - docIds
     - quota

    """


    def __init__(self, userId=None, docIds=None, quota=None,):
        self.userId = userId
        self.docIds = docIds
        self.quota = quota

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.docIds = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.docIds.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.quota = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_CheckDocSpace_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.docIds is not None:
            oprot.writeFieldBegin('docIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.docIds))
            for iter90 in self.docIds:
                oprot.writeString(iter90.encode('utf-8') if sys.version_info[0] == 2 else iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.quota is not None:
            oprot.writeFieldBegin('quota', TType.I64, 3)
            oprot.writeI64(self.quota)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_CheckDocSpace_args)
EFAST_CheckDocSpace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'docIds', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'quota', None, None, ),  # 3
)


class EFAST_CheckDocSpace_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_CheckDocSpace_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_CheckDocSpace_result)
EFAST_CheckDocSpace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SetQuotaInfo_args(object):
    """
    Attributes:
     - userId
     - docId
     - quota

    """


    def __init__(self, userId=None, docId=None, quota=None,):
        self.userId = userId
        self.docId = docId
        self.quota = quota

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.quota = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SetQuotaInfo_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 2)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.quota is not None:
            oprot.writeFieldBegin('quota', TType.I64, 3)
            oprot.writeI64(self.quota)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SetQuotaInfo_args)
EFAST_SetQuotaInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'docId', 'UTF8', None, ),  # 2
    (3, TType.I64, 'quota', None, None, ),  # 3
)


class EFAST_SetQuotaInfo_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SetQuotaInfo_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SetQuotaInfo_result)
EFAST_SetQuotaInfo_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SearchCustomDocInfos_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetPageDocParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SearchCustomDocInfos_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SearchCustomDocInfos_args)
EFAST_SearchCustomDocInfos_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetPageDocParam, None], None, ),  # 1
)


class EFAST_SearchCustomDocInfos_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = ncTCustomDocInfo()
                        _elem96.read(iprot)
                        self.success.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SearchCustomDocInfos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter97 in self.success:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SearchCustomDocInfos_result)
EFAST_SearchCustomDocInfos_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTCustomDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetSearchCustomDocCnt_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetPageDocParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetSearchCustomDocCnt_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetSearchCustomDocCnt_args)
EFAST_GetSearchCustomDocCnt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetPageDocParam, None], None, ),  # 1
)


class EFAST_GetSearchCustomDocCnt_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetSearchCustomDocCnt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetSearchCustomDocCnt_result)
EFAST_GetSearchCustomDocCnt_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_EditDocLibrarySiteId_args(object):
    """
    Attributes:
     - docId
     - siteId

    """


    def __init__(self, docId=None, siteId=None,):
        self.docId = docId
        self.siteId = siteId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.siteId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditDocLibrarySiteId_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.siteId is not None:
            oprot.writeFieldBegin('siteId', TType.STRING, 2)
            oprot.writeString(self.siteId.encode('utf-8') if sys.version_info[0] == 2 else self.siteId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditDocLibrarySiteId_args)
EFAST_EditDocLibrarySiteId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'siteId', 'UTF8', None, ),  # 2
)


class EFAST_EditDocLibrarySiteId_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditDocLibrarySiteId_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditDocLibrarySiteId_result)
EFAST_EditDocLibrarySiteId_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_BatchAddCustomDocs_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTBatchAddCustomDocParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_BatchAddCustomDocs_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_BatchAddCustomDocs_args)
EFAST_BatchAddCustomDocs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTBatchAddCustomDocParam, None], None, ),  # 1
)


class EFAST_BatchAddCustomDocs_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_BatchAddCustomDocs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_BatchAddCustomDocs_result)
EFAST_BatchAddCustomDocs_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetBatchAddCustomDocsResult_args(object):
    """
    Attributes:
     - taskId

    """


    def __init__(self, taskId=None,):
        self.taskId = taskId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.taskId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetBatchAddCustomDocsResult_args')
        if self.taskId is not None:
            oprot.writeFieldBegin('taskId', TType.STRING, 1)
            oprot.writeString(self.taskId.encode('utf-8') if sys.version_info[0] == 2 else self.taskId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetBatchAddCustomDocsResult_args)
EFAST_GetBatchAddCustomDocsResult_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'taskId', 'UTF8', None, ),  # 1
)


class EFAST_GetBatchAddCustomDocsResult_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTBatchAddCustomDocResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetBatchAddCustomDocsResult_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetBatchAddCustomDocsResult_result)
EFAST_GetBatchAddCustomDocsResult_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTBatchAddCustomDocResult, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SearchAvailableCustomDocInfos_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetPageDocParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SearchAvailableCustomDocInfos_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SearchAvailableCustomDocInfos_args)
EFAST_SearchAvailableCustomDocInfos_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetPageDocParam, None], None, ),  # 1
)


class EFAST_SearchAvailableCustomDocInfos_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = ncTCustomDocInfo()
                        _elem103.read(iprot)
                        self.success.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SearchAvailableCustomDocInfos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter104 in self.success:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SearchAvailableCustomDocInfos_result)
EFAST_SearchAvailableCustomDocInfos_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTCustomDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetSearchAvailableCustomDocCnt_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetPageDocParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetSearchAvailableCustomDocCnt_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetSearchAvailableCustomDocCnt_args)
EFAST_GetSearchAvailableCustomDocCnt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetPageDocParam, None], None, ),  # 1
)


class EFAST_GetSearchAvailableCustomDocCnt_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetSearchAvailableCustomDocCnt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetSearchAvailableCustomDocCnt_result)
EFAST_GetSearchAvailableCustomDocCnt_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_EditDisplayOrder_args(object):
    """
    Attributes:
     - docId
     - userId
     - displayOrder

    """


    def __init__(self, docId=None, userId=None, displayOrder=None,):
        self.docId = docId
        self.userId = userId
        self.displayOrder = displayOrder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.displayOrder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditDisplayOrder_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.displayOrder is not None:
            oprot.writeFieldBegin('displayOrder', TType.I32, 3)
            oprot.writeI32(self.displayOrder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditDisplayOrder_args)
EFAST_EditDisplayOrder_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'displayOrder', None, None, ),  # 3
)


class EFAST_EditDisplayOrder_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditDisplayOrder_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditDisplayOrder_result)
EFAST_EditDisplayOrder_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_MoveUserDoc_args(object):
    """
    Attributes:
     - adminId
     - userId
     - docId

    """


    def __init__(self, adminId=None, userId=None, docId=None,):
        self.adminId = adminId
        self.userId = userId
        self.docId = docId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_MoveUserDoc_args')
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 1)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 3)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_MoveUserDoc_args)
EFAST_MoveUserDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'adminId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'docId', 'UTF8', None, ),  # 3
)


class EFAST_MoveUserDoc_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = ncTCustomDocInfo()
                        _elem110.read(iprot)
                        self.success.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_MoveUserDoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter111 in self.success:
                iter111.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_MoveUserDoc_result)
EFAST_MoveUserDoc_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTCustomDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_MoveEntryDoc_args(object):
    """
    Attributes:
     - adminId
     - sourceDocId
     - targetDocId

    """


    def __init__(self, adminId=None, sourceDocId=None, targetDocId=None,):
        self.adminId = adminId
        self.sourceDocId = sourceDocId
        self.targetDocId = targetDocId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sourceDocId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.targetDocId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_MoveEntryDoc_args')
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 1)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        if self.sourceDocId is not None:
            oprot.writeFieldBegin('sourceDocId', TType.STRING, 2)
            oprot.writeString(self.sourceDocId.encode('utf-8') if sys.version_info[0] == 2 else self.sourceDocId)
            oprot.writeFieldEnd()
        if self.targetDocId is not None:
            oprot.writeFieldBegin('targetDocId', TType.STRING, 3)
            oprot.writeString(self.targetDocId.encode('utf-8') if sys.version_info[0] == 2 else self.targetDocId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_MoveEntryDoc_args)
EFAST_MoveEntryDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'adminId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sourceDocId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'targetDocId', 'UTF8', None, ),  # 3
)


class EFAST_MoveEntryDoc_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = ncTCustomDocInfo()
                        _elem117.read(iprot)
                        self.success.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_MoveEntryDoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter118 in self.success:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_MoveEntryDoc_result)
EFAST_MoveEntryDoc_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTCustomDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_DeleteUserDoc_args(object):
    """
    Attributes:
     - userId
     - deleterId

    """


    def __init__(self, userId=None, deleterId=None,):
        self.userId = userId
        self.deleterId = deleterId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.deleterId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_DeleteUserDoc_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.deleterId is not None:
            oprot.writeFieldBegin('deleterId', TType.STRING, 2)
            oprot.writeString(self.deleterId.encode('utf-8') if sys.version_info[0] == 2 else self.deleterId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_DeleteUserDoc_args)
EFAST_DeleteUserDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'deleterId', 'UTF8', None, ),  # 2
)


class EFAST_DeleteUserDoc_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = ncTCustomDocInfo()
                        _elem124.read(iprot)
                        self.success.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_DeleteUserDoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter125 in self.success:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_DeleteUserDoc_result)
EFAST_DeleteUserDoc_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTCustomDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetUserTotalQuota_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetUserTotalQuota_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetUserTotalQuota_args)
EFAST_GetUserTotalQuota_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EFAST_GetUserTotalQuota_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetUserTotalQuota_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetUserTotalQuota_result)
EFAST_GetUserTotalQuota_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetUserUsedQuota_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetUserUsedQuota_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetUserUsedQuota_args)
EFAST_GetUserUsedQuota_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EFAST_GetUserUsedQuota_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetUserUsedQuota_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetUserUsedQuota_result)
EFAST_GetUserUsedQuota_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_EditUserTotalQuota_args(object):
    """
    Attributes:
     - userId
     - totalQuotaBytes

    """


    def __init__(self, userId=None, totalQuotaBytes=None,):
        self.userId = userId
        self.totalQuotaBytes = totalQuotaBytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.totalQuotaBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditUserTotalQuota_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.totalQuotaBytes is not None:
            oprot.writeFieldBegin('totalQuotaBytes', TType.I64, 2)
            oprot.writeI64(self.totalQuotaBytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditUserTotalQuota_args)
EFAST_EditUserTotalQuota_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'totalQuotaBytes', None, None, ),  # 2
)


class EFAST_EditUserTotalQuota_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_EditUserTotalQuota_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_EditUserTotalQuota_result)
EFAST_EditUserTotalQuota_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetAllUserDocById_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetAllUserDocById_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetAllUserDocById_args)
EFAST_GetAllUserDocById_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EFAST_GetAllUserDocById_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetAllUserDocById_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter132 in self.success:
                oprot.writeString(iter132.encode('utf-8') if sys.version_info[0] == 2 else iter132)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetAllUserDocById_result)
EFAST_GetAllUserDocById_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_ConfictWithLibName_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_ConfictWithLibName_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_ConfictWithLibName_args)
EFAST_ConfictWithLibName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class EFAST_ConfictWithLibName_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_ConfictWithLibName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_ConfictWithLibName_result)
EFAST_ConfictWithLibName_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetSpaceQuotaInfo_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetSpaceQuotaInfo_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetSpaceQuotaInfo_args)
EFAST_GetSpaceQuotaInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EFAST_GetSpaceQuotaInfo_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTSpaceQuotaInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetSpaceQuotaInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetSpaceQuotaInfo_result)
EFAST_GetSpaceQuotaInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTSpaceQuotaInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetAllCustomDocTypeName_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetAllCustomDocTypeName_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetAllCustomDocTypeName_args)
EFAST_GetAllCustomDocTypeName_args.thrift_spec = (
)


class EFAST_GetAllCustomDocTypeName_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetAllCustomDocTypeName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter139 in self.success:
                oprot.writeString(iter139.encode('utf-8') if sys.version_info[0] == 2 else iter139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetAllCustomDocTypeName_result)
EFAST_GetAllCustomDocTypeName_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_GetUserGns_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetUserGns_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetUserGns_args)
EFAST_GetUserGns_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EFAST_GetUserGns_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_GetUserGns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_GetUserGns_result)
EFAST_GetUserGns_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SysRecycle_RestoreCustomDoc_args(object):
    """
    Attributes:
     - docId
     - name
     - adminId

    """


    def __init__(self, docId=None, name=None, adminId=None,):
        self.docId = docId
        self.name = name
        self.adminId = adminId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_RestoreCustomDoc_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 3)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_RestoreCustomDoc_args)
EFAST_SysRecycle_RestoreCustomDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'adminId', 'UTF8', None, ),  # 3
)


class EFAST_SysRecycle_RestoreCustomDoc_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_RestoreCustomDoc_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_RestoreCustomDoc_result)
EFAST_SysRecycle_RestoreCustomDoc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SysRecycle_RestoreUserDoc_args(object):
    """
    Attributes:
     - docId
     - responsiblePersonId

    """


    def __init__(self, docId=None, responsiblePersonId=None,):
        self.docId = docId
        self.responsiblePersonId = responsiblePersonId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.responsiblePersonId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_RestoreUserDoc_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.responsiblePersonId is not None:
            oprot.writeFieldBegin('responsiblePersonId', TType.STRING, 2)
            oprot.writeString(self.responsiblePersonId.encode('utf-8') if sys.version_info[0] == 2 else self.responsiblePersonId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_RestoreUserDoc_args)
EFAST_SysRecycle_RestoreUserDoc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'responsiblePersonId', 'UTF8', None, ),  # 2
)


class EFAST_SysRecycle_RestoreUserDoc_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_RestoreUserDoc_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_RestoreUserDoc_result)
EFAST_SysRecycle_RestoreUserDoc_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SysRecycle_GetEntryDocInfos_args(object):
    """
    Attributes:
     - start
     - limit
     - searchKey

    """


    def __init__(self, start=None, limit=None, searchKey=None,):
        self.start = start
        self.limit = limit
        self.searchKey = searchKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.searchKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_GetEntryDocInfos_args')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 1)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.searchKey is not None:
            oprot.writeFieldBegin('searchKey', TType.STRING, 3)
            oprot.writeString(self.searchKey.encode('utf-8') if sys.version_info[0] == 2 else self.searchKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_GetEntryDocInfos_args)
EFAST_SysRecycle_GetEntryDocInfos_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'start', None, None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
    (3, TType.STRING, 'searchKey', 'UTF8', None, ),  # 3
)


class EFAST_SysRecycle_GetEntryDocInfos_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = ncTSysRecycleEntryDocInfo()
                        _elem145.read(iprot)
                        self.success.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_GetEntryDocInfos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter146 in self.success:
                iter146.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_GetEntryDocInfos_result)
EFAST_SysRecycle_GetEntryDocInfos_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTSysRecycleEntryDocInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_SysRecycle_GetEntryDocInfoByDocId_args(object):
    """
    Attributes:
     - docId

    """


    def __init__(self, docId=None,):
        self.docId = docId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_GetEntryDocInfoByDocId_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_GetEntryDocInfoByDocId_args)
EFAST_SysRecycle_GetEntryDocInfoByDocId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
)


class EFAST_SysRecycle_GetEntryDocInfoByDocId_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTSysRecycleEntryDocInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_SysRecycle_GetEntryDocInfoByDocId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_SysRecycle_GetEntryDocInfoByDocId_result)
EFAST_SysRecycle_GetEntryDocInfoByDocId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTSysRecycleEntryDocInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EFAST_OnDeleteDepartment_args(object):
    """
    Attributes:
     - departmentIds

    """


    def __init__(self, departmentIds=None,):
        self.departmentIds = departmentIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.departmentIds = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.departmentIds.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_OnDeleteDepartment_args')
        if self.departmentIds is not None:
            oprot.writeFieldBegin('departmentIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.departmentIds))
            for iter153 in self.departmentIds:
                oprot.writeString(iter153.encode('utf-8') if sys.version_info[0] == 2 else iter153)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_OnDeleteDepartment_args)
EFAST_OnDeleteDepartment_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'departmentIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class EFAST_OnDeleteDepartment_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EFAST_OnDeleteDepartment_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EFAST_OnDeleteDepartment_result)
EFAST_OnDeleteDepartment_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

