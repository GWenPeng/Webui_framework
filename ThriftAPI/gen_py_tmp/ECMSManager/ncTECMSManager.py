#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    ECMSManager thift 管理接口

    """
    def is_node_dirty(self, host, port, user, passwd):
        """
        节点环境是否干净
        @param   <string>    host    节点 IP 地址
        @param   <i32>       port    SSH 端口
        @param   <string>    user    SSH 用户
        @param   <string>    passwd  SSH 密码
        @return  <bool>                          True:   节点环境不干净
                                                 False:  节点环境干净

        Parameters:
         - host
         - port
         - user
         - passwd

        """
        pass

    def is_env_dirty(self, node_ipaddr):
        """
        检查节点环境是否干净
        前提：可以连通被检查节点，开放了集群管理服务的访问端口
        @param   <string>    node_ipaddr    节点 IP 地址
        @return  <bool>                          True:   节点环境不干净
                                                 False:  节点环境干净

        Parameters:
         - node_ipaddr

        """
        pass

    def clear_node(self, node_ipaddr):
        """
        清理节点
        @param   <string>    node_ipaddr         节点 IP 地址

        Parameters:
         - node_ipaddr

        """
        pass

    def active_cluster(self, node_ipaddr):
        """
        激活集群
        @param   <string>    node_ipaddr         节点 IP 地址
        @return  <string>                        集群 UUID

        Parameters:
         - node_ipaddr

        """
        pass

    def add_node(self, host):
        """
        添加节点
        @param   <string>    host    节点 IP 地址
        @return  <string>            节点 UUID

        Parameters:
         - host

        """
        pass

    def del_node(self, node_uuid):
        """
        移除节点
        @param   <string>    node_uuid   节点 UUID

        Parameters:
         - node_uuid

        """
        pass

    def get_module_status(self, module_name):
        """
        获取模块状态
        @param   <string>    module_name  模块名

        Parameters:
         - module_name

        """
        pass

    def enable_module(self, module_name):
        """
        启用模块
        @param   <string>    module_name  模块名

        Parameters:
         - module_name

        """
        pass

    def disable_module(self, module_name):
        """
        禁用模块
        @param   <string>    module_name  模块名

        Parameters:
         - module_name

        """
        pass

    def create_ecms_db(self):
        """
        创建ecms集群管理数据库

        """
        pass

    def get_db_node_info(self):
        """
        获取数据库节点信息
        @return list<ncTDBNodeInfo> 数据库节点信息列表

        """
        pass

    def set_db_master(self, node_uuid):
        """
        设置数据库主库
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        pass

    def set_db_slave(self, node_uuid):
        """
        设置数据库备份从节点
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        pass

    def set_db_slave_by_xtrabackup(self, node_uuid, slave_ssh_info):
        """
        设置数据库备份从节点,根据空间大小自动判断使用xtrabackup备份方式或者mysqldump
        @param <string>      node_uuid 节点ID
        @param ECMSAgent.ncTSSHInfo slave_ssh_info  数据库高可用备份从节点 ssh 信息
               ncTSSHInfo.host     : 主机地址
               ncTSSHInfo.port     : 连接端口
               ncTSSHInfo.user     : ssh 用户
               ncTSSHInfo.password : ssh 密码

        Parameters:
         - node_uuid
         - slave_ssh_info

        """
        pass

    def cancel_db_node(self, node_uuid):
        """
        移出数据库节点
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        pass

    def update_deployment_mode(self, mode):
        """
        更新集群部署模式
        @param <string>   mode 部署模式 NCT_STANDARD_MODE
                                        NCT_PROFESSIONAL_MODE

        Parameters:
         - mode

        """
        pass

    def get_deployment_mode(self):
        """
        获取集群部署模式

        """
        pass

    def dump_databases_to_path(self, host, port, db_name, path):
        """
        使用mysqldump导出数据到指定目录
        @param <string> host 数据库地址
        @param <int> port 数据库端口
        @param <string> db_name 数据库名
        @param <string> path 导出目录绝对路径

        Parameters:
         - host
         - port
         - db_name
         - path

        """
        pass

    def get_databases_name(self, host, port):
        """
        获取数据库名
        注:过滤了"information_schema", "mysql", "performance_schema", "sys"数据库
        @param <string> host 数据库地址
        @param <int> port 数据库端口
        @return list<string> 数据库名称列表

        Parameters:
         - host
         - port

        """
        pass

    def purge_binlogs(self, node_uuid):
        """
        移除指定数据库节点的binlog文件
        @param <string> 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def update_external_db_info(self, info):
        """
        更新第三方数据库信息
        @param ncTExternalDBInfo info 第三方数据库信息
               ncTExternalDBInfo.db_host:第三方数据库地址,
               ncTExternalDBInfo.db_port:第三方数据库端口,
               ncTExternalDBInfo.db_user:第三方数据库用户,
               ncTExternalDBInfo.db_password:第三方数据库密码

        Parameters:
         - info

        """
        pass

    def get_external_db_info(self):
        """
        获取第三方数据库信息
        @return <ncTExternalDBInfo> 第三方数据库连接结构,结构属性同上

        """
        pass

    def is_external_db(self):
        """
        判断是否使用第三方数据库

        """
        pass

    def is_available_external_db(self, info):
        """
        测试第三方数据库是否可用
        @return <bool> True:可用 | False 不可用

        Parameters:
         - info

        """
        pass

    def add_firewall_rule(self, firewall_info):
        """
        添加防火墙规则
        @param <ncTFirewallInfo> firewall_info 待添加防火墙信息结构

        Parameters:
         - firewall_info

        """
        pass

    def del_firewall_rule(self, firewall_info):
        """
        删除防火墙规则
        @param <ncTFirewallInfo> firewall_info 待删除防火墙信息结构

        Parameters:
         - firewall_info

        """
        pass

    def update_firewall_rule(self, old_info, new_info):
        """
        修改防火墙规则
        @param <ncTFirewallInfo> old_info 待修改防火墙信息结构
        @param <ncTFirewallInfo> new_info 修改后防火墙信息结构

        Parameters:
         - old_info
         - new_info

        """
        pass

    def get_firewall_rule(self, sys_role):
        """
        获取指定子系统所有防火墙规则
        param <string> sys_role 规则所属的子系统,参数如下
                                db:      数据库子系统
                                app:     应用子系统
                                ecms:    集群管理子系统
                                basic:   基础规则,所有节点应用
                                storage: 存储子系统
        return list<ncTFirewallInfo> 防火墙结构信息列表

        Parameters:
         - sys_role

        """
        pass

    def enable_firewall(self):
        """
        启用集群防火墙

        """
        pass

    def disable_firewall(self):
        """
        禁用集群防火墙

        """
        pass

    def get_firewall_status(self):
        """
        * 获取集群防火墙状态
        * return bool True:  防火墙开启
                      False: 防火墙关闭

        """
        pass

    def enable_sys_service(self, sys_role):
        """
        允许子系统对外服务
        param <string> sys_role 规则所属的子系统,参数及含义如下
                                db:      数据库子系统
                                app:     应用子系统
                                ecms:    集群管理子系统
                                basic:   基础规则,所有节点应用
                                storage: 存储子系统

        Parameters:
         - sys_role

        """
        pass

    def disable_sys_service(self, sys_role):
        """
        禁止子系统对外服务
        param <string> sys_role 规则所属的子系统,参数及含义如下
                                db:      数据库子系统
                                app:     应用子系统
                                ecms:    集群管理子系统
                                basic:   基础规则,所有节点应用
                                storage: 存储子系统

        Parameters:
         - sys_role

        """
        pass

    def get_sys_service_status(self, sys_role):
        """
        * 获取子系统对外服务状态
        * param <string> sys_role 规则所属的子系统,参数及含义如下
        *                         db:      数据库子系统
        *                         app:     应用子系统
        *                         ecms:    集群管理子系统
        *                         basic:   基础规则,所有节点应用
        *                         storage: 存储子系统
        * return bool True:       允许子系统对外服务
                      False:      禁止子系统对外服务

        Parameters:
         - sys_role

        """
        pass

    def add_trusted_ip(self, ip_list):
        """
        Parameters:
         - ip_list

        """
        pass

    def set_storage_trusted_ip(self, firewall_list):
        """
        Parameters:
         - firewall_list

        """
        pass

    def get_asu_node_ip(self):
        pass

    def get_keepalived_status(self):
        """
        获取高可用模块启用状态
        @return  bool    True:   启用
                         False:  禁用


        """
        pass

    def enable_keepalived(self):
        """
        启用高可用模块


        """
        pass

    def disable_keepalived(self):
        """
        禁用高可用模块


        """
        pass

    def get_vip_info(self):
        """
        获取高可用vip信息列表
        @return <ncTVipInfo> vip信息结构

        """
        pass

    def set_vip_info(self, vip_info):
        """
        修改高可用vip信息
        @param <ncTVipInfo> 待设置的vip信息结构
        例: ncTVipInfo(vip='192.168.136.1', nic='ens32', mask='255.255.255.0', sys=ncTHaSys.BASIC)

        Parameters:
         - vip_info

        """
        pass

    def set_ivip_info(self, ivip_info):
        """
        修改高可用ivip信息
        @param <ncTVipInfo> 待设置的ivip信息结构

        Parameters:
         - ivip_info

        """
        pass

    def get_ha_node_info(self):
        """
        获取所有的ha节点信息
        @return list<ncTHaNodeInfo> 高可用节点信息列表

        """
        pass

    def set_ha_master(self, node_uuid, vip_info):
        """
        设置高可用主节点
        @param <string>      node_uuid 节点ID
        @param <ncTVipInfo>  vip_info  vip信息结构
        例1：单vip方案, vip参数如下, sys为标记高可用节点所属子系统
        ncTVipInfo(vip='192.168.136.1', nic='ens32', mask='255.255.255.0', sys=ncTHaSys.BASIC)
        例2：多vip方案，设置应用子系统高可用
        ncTVipInfo(vip='192.168.136.1', nic='ens32', mask='255.255.255.0', sys=ncTHaSys.APP)

        Parameters:
         - node_uuid
         - vip_info

        """
        pass

    def set_ha_slave(self, node_uuid, ha_sys):
        """
        设置高可用从节点
        @param <string>      node_uuid 节点ID
        @param <int>    ha_sys 所属高可用系统标记,参数使用如下值:
                                    ncTHaSys.BASIC   集群使用一个vip方案使用值
                                    ncTHaSys.APP     应用高可用
                                    ncTHaSys.STORAGE 存储高可用

        Parameters:
         - node_uuid
         - ha_sys

        """
        pass

    def cancel_ha_node(self, node_uuid):
        """
        取消高可用节点
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        pass

    def set_db_ha_master(self, ivip_info):
        """
        设置数据库高可用主
        @param <ncTVipInfo>      ivip_info 数据库ivip

        Parameters:
         - ivip_info

        """
        pass

    def set_db_ha_slave(self):
        """
        设置数据库高可用从

        """
        pass

    def cancel_db_ha_node(self, node_uuid):
        """
        取消数据库高可用
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        pass

    def on_lvs_changed(self):
        """
        更新lvs

        """
        pass

    def on_node_entering_master(self):
        """
        高可用节点进入主

        """
        pass

    def on_node_entering_slave(self):
        """
        高可用节点进入从

        """
        pass

    def force_enter_master(self):
        """
        将当前节点临时地强制切换为主节点(慎用！)
        下次keepalived启动时生效，仅一次有效
        PS：强制切换时，会忽略数据库的binlog IO同步状态

        """
        pass

    def get_node_info(self, node_uuid):
        """
        获取指定节点信息
        @param string node_uuid 节点uuid
        @return <ncTNodeInfo> 节点信息

        Parameters:
         - node_uuid

        """
        pass

    def get_all_node_info(self):
        """
        获取所有节点信息
        @return list<ncTNodeInfo> 节点信息列表

        """
        pass

    def set_node_alias(self, node_uuid, node_alias):
        """
        设置节点别名
        @param string node_uuid 节点uuid
        @param string node_alias 节点别名

        Parameters:
         - node_uuid
         - node_alias

        """
        pass

    def restart_eisooapp(self, node_uuid):
        """
        指定节点异步重启eisooapp服务
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def reboot_node(self, node_uuid):
        """
        重启指定节点
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def shutdown_cluster(self):
        """
        关闭集群所有节点

        """
        pass

    def get_cluster_time(self):
        """
        获取集群时间
        @return i64 当前集群系统时间UNIX时间戳

        """
        pass

    def set_cluster_time(self, datetime):
        """
        设置集群时间
        时间格式："yyyy-mm-dd hh:mm:ss"
        @param string datetime 待设置时间

        Parameters:
         - datetime

        """
        pass

    def get_cluster_version(self):
        """
        获取集群版本
        @return string 当前集群使用的 AnyShare Server 包版本号
        如安装的 Server 包名为AnyShare-Server-6.0.1-20170511-81,则返回值为 "6.0.1-20170511-81"

        """
        pass

    def get_cluster_uuid(self):
        """
        获取集群 uuid
        @return string 集群 uuid, 集群唯一标识

        """
        pass

    def add_log_server(self, facility, severity, ip, port, protocol):
        """
        添加一台远程日志服务器,若推送功能开启则立即生效
        @param str facility: 接收规则模块
                   参数: kern, user, mail, daemon, auth, syslog, lpr, news, uucp, authpriv,
                         ftp, cron, local0, local1, local2, local3, local4, local5, local6, local7
        @param str severity: 接收规则等级
                   参数: emerg, alert, crit, err, warn, notice, info, debug
        @param string ip: 远程服务器ip地址
        @param int port: 远程服务器端口
        @param string protocol：传输协议TCP/UDP

        Parameters:
         - facility
         - severity
         - ip
         - port
         - protocol

        """
        pass

    def delete_log_server(self, facility, severity, ip, port, protocol):
        """
        删除一台日志服务器,若推送功能开启则立即生效
        @param str facility: 接收规则模块
        @param str severity: 接收规则等级
        @param string ip: 远程服务器ip地址
        @param int port: 远程服务器端口
        @param string protocol：传输协议TCP/UDP

        Parameters:
         - facility
         - severity
         - ip
         - port
         - protocol

        """
        pass

    def enable_upload_log(self, datetime):
        """
        开启日志推送到日志服务器功能
        @param str datetime 用户日志推送起始时间
         e.g: 2016-06-20 09:00:00

        Parameters:
         - datetime

        """
        pass

    def disable_upload_log(self):
        """
        关闭日志推送到日志服务器功能

        """
        pass

    def get_upload_log_status(self):
        """
        获取日志推送到日志服务器功能状态
        return bool False 日志推送服务关闭
                    True  日志推送服务开启

        """
        pass

    def get_upload_log_server(self):
        """
        获取数据库中日志服务器信息列表
        @return list<ECMSAgent.ncTLogHostInfo>

        """
        pass

    def get_upload_log_time(self):
        """
        获取用户日志推送起始时间的UNIX时间戳
        @return int UNIX时间戳

        """
        pass

    def get_all_nics_name(self, node_uuid):
        """
        获取指定节点的所有网卡名

        Parameters:
         - node_uuid

        """
        pass

    def get_cpu_usage(self, node_uuid):
        """
        获取指定节点cpu使用率
        @param <string> node_uuid 节点uuid
        @return <double> cpu使用率

        Parameters:
         - node_uuid

        """
        pass

    def get_memory_info(self, node_uuid):
        """
        获取指定节点内存使用情况
        @param <string> node_uuid 节点uuid
        @return map<string, i64> {'usage': 已用内存B, 'total': 总共内存B}

        Parameters:
         - node_uuid

        """
        pass

    def get_network_outgoing_rate(self, node_uuid):
        """
        获取网络发送速率
        @param <string> node_uuid 节点uuid
        @return <int> 网络发送速度 B/s

        Parameters:
         - node_uuid

        """
        pass

    def get_network_incoming_rate(self, node_uuid):
        """
        获取网络接收速度
        @param <string> node_uuid 节点uuid
        @return <int> 网络接收速度 B/s

        Parameters:
         - node_uuid

        """
        pass

    def troubleshoot(self):
        """
        对当前节点环境进行故障检测及处理
        故障如：服务停止

        """
        pass

    def consistency_repair(self):
        """
        对当前节点环境进行一致性检测及处理

        """
        pass

    def consistency_check(self):
        """
        对当前节点环境进行一致性检测
        若节点各子模块均与集群保持一致(不需要进行一致性恢复), 返回 True
        若节点各子模块中存在任一模块与集群状态不一致(则需要进行一致性恢复), 返回 False

        """
        pass

    def on_node_heartbeat(self, node_uuid):
        """
        收到节点心跳的处理
        @param <string> node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def on_change_node_ip(self, old_ip, new_ip, update_db_host):
        """
        手动修改节点 ip 后，调用该接口更新相关元数据等信息
        @param <string> old_ip 原 ip
        @param <string> new_ip 新 ip
        @param <bool>   update_db_host 如果待更新的节点原 ip 用于数据库连接，
                                       需要通过该接口更新各节点的 db_host
                                       信息，为 True；否则为 False
                                       调用时，需要能连通各节点的 agent

        Parameters:
         - old_ip
         - new_ip
         - update_db_host

        """
        pass

    def enable_raid_manager(self):
        """
        启用 raid 管理模块, 默认不支持 raid 管理, 只有 eisoo 一体机设备并且指定型号 raid 卡才支持

        """
        pass

    def disable_raid_manager(self):
        """
        禁用 raid 管理模块

        """
        pass

    def get_raid_manager_status(self):
        """
        获取raid管理模块启用状态

        """
        pass

    def is_available_of_raid_manager(self, node_ip):
        """
        是否支持raid管理
        @param string node_ip 节点ip
        @return bool True:  支持raid管理
                     False: 不支持raid管理

        Parameters:
         - node_ip

        """
        pass

    def exist_iscsi_device(self, node_ip):
        """
        判断节点是否存在外挂存储
        @param string node_ip          节点的node_ip

        Parameters:
         - node_ip

        """
        pass

    def get_free_data_disks(self, node_ip):
        """
        获取指定节点上的空闲数据盘
        空闲数据盘：指尚未加入存储池的数据盘

        @param string node_ip                    节点的 node_ip
        @return map<disk_dev_path, data_disk>    空闲数据盘列表

        Parameters:
         - node_ip

        """
        pass

    def init_storage_pool(self, replicas):
        """
        初始化存储池

        @param int replicas 副本数

        Parameters:
         - replicas

        """
        pass

    def is_storage_pool_inited(self):
        """
        判断存储池是否已初始化

        """
        pass

    def get_storage_pool(self, include_used_size):
        """
        获取存储池信息

        @param bool need_used_size       是否包含已用空间
             若为True，则需要从各个节点查询所有磁盘的可用空间情况，当节点数较多时，花费时间将较长

        Parameters:
         - include_used_size

        """
        pass

    def get_storage_pool_devices(self, node_ip):
        """
        获取存储池中指定节点上的设备列表(包含设备对应的数据卷信息)

        @param string node_ip          节点的ip, 若为""，则获取全部节点
        @return map<ECMSAgent.ncTSwiftDevice.dev_id, ncTStoragePoolDevice>

        Parameters:
         - node_ip

        """
        pass

    def get_storage_pool_swift_devices(self):
        """
        获取存储池中swift设备列表(按节点分组，不包含设备对应的数据卷信息)

        @return map<node_ip, map<ECMSAgent.ncTSwiftDevice.dev_id, ncTStoragePoolDevice> >

        """
        pass

    def add_devices_to_pool(self, disk_dev_paths):
        """
        将指定节点上的指定空闲数据盘一次性加入到存储池中

        @param disks(map<node_ip, list<disk_dev_path>>)  空闲数据盘列表，由 get_free_data_disks 可知

        Parameters:
         - disk_dev_paths

        """
        pass

    def add_node_devices_to_pool(self, node_ip):
        """
        将指定某一节点的所有空闲数据盘一次性加入到存储池中

        @param string node_ip      节点 ip

        Parameters:
         - node_ip

        """
        pass

    def get_maintenance_of_devices(self, dev_uuids):
        """
        获取指定存储池设备的维护状态
        @param   list<string>    dev_uuids   指定存储池设备的 UUID 列表
        @return  list<bool>                  True: 处于维护状态
                                             False: 未处于维护状态

        Parameters:
         - dev_uuids

        """
        pass

    def enable_maintenance_of_devices(self, dev_uuids):
        """
        指定存储池设备进入维护状态
        @param   list<string>    dev_uuids   指定存储池设备的 UUID 列表
        @return  list<string>    dev_uuids   进入维护模式的 UUID 列表

        Parameters:
         - dev_uuids

        """
        pass

    def disable_maintenance_of_devices(self, dev_uuids):
        """
        指定存储池设备退出维护状态
        @param   list<string>    dev_uuids   指定存储池设备的 UUID 列表
        @return  list<string>    dev_uuids   退出维护模式的 UUID 列表

        Parameters:
         - dev_uuids

        """
        pass

    def get_free_data_disks_for_replace(self, dev_id):
        """
        获取可用于替换指定存储池设备的备选空闲数据盘列表
        规则：
          1.备选设备和要替换的设备处于同一服务器节点

        @param dev_id(int)     存储池中需要被替换的设备ID， ncTStoragePoolDevice.swift_device.dev_id
        @return map<disk_dev_path, data_disk>   备选空闲数据盘列表

        Parameters:
         - dev_id

        """
        pass

    def replace_device_in_pool(self, dev_id, disk_dev_path):
        """
        在存储池中使用指定数据盘替换指定存储池设备（仅限同一节点内的磁盘替换）
        单副本环境不支持此操作
        若替换磁盘的容量与原磁盘不一致，则此操作会引起存储池内的数据重新负载均衡及迁移
        此操作适用于某块故障卷可以被尽快更换的场景，或需要替换使用大容量磁盘达到扩容目的的场景

        @param dev_id(int)           存储池中需要被替换的设备ID， ncTStoragePoolDevice.swift_device.dev_id
        @param disk_dev_path(str)    用于替换的数据盘路径

        Parameters:
         - dev_id
         - disk_dev_path

        """
        pass

    def remove_device_from_pool(self, dev_id):
        """
        从存储池中移除单个设备
        此操作会引起存储池内的数据重新负载均衡及迁移
        此操作适用于某块存储卷已故障不可用，且长时间无法得到恢复或更换的场景
        单副本环境不支持此操作

        @param dev_id(int)   存储池中的设备ID， ncTStoragePoolDevice.swift_device.dev_id

        Parameters:
         - dev_id

        """
        pass

    def remove_node_devices_from_pool(self, node_ip):
        """
        从存储池中移除指定节点的所有设备
        单副本环境不支持此操作

        @param string node_ip      节点 ip

        Parameters:
         - node_ip

        """
        pass

    def rebalance_storage_pool(self):
        """
        将存储池重新负载均衡

        """
        pass

    def change_replicas(self, replicas):
        """
        修改存储池副本数

        @param int replicas 副本数

        Parameters:
         - replicas

        """
        pass

    def get_replicas_health(self):
        """
        查询当前存储池的副本健康度.
        内部采用抽样的方法检测.
        @return health_percent   返回健康百分比之分子，等于 100 可视为健康，
                                 说明所有对象的副本都100%存在正确的位置上。

        """
        pass

    def get_all_data_raid_pds(self, node_ip):
        """
        获取指定节点上的所有数据RAID物理磁盘列表

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        pass

    def get_free_data_raid_pds(self, node_ip):
        """
        获取指定节点上的空闲数据RAID物理磁盘列表
        空闲数据RAID物理磁盘：指尚未加入存储池的数据RAID物理磁盘

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        pass

    def get_raid_pds_in_storage_pool(self, node_ip):
        """
        获取指定节点上的已加入存储池的数据RAID物理磁盘列表

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        pass

    def get_sys_raid_pds(self, node_ip):
        """
        获取指定节点上的系统RAID物理磁盘列表
        系统RAID物理磁盘：指用于系统盘或缓存盘的RAID物理磁盘或热备盘

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        pass

    def get_all_raid_lds(self, node_ip):
        """
        获取指定节点上的所有RAID逻辑磁盘列表

        @param string node_ip                    节点 ip
        @return map<ld_devid, ldinfo>            RAID逻辑磁盘列表

        Parameters:
         - node_ip

        """
        pass

    def get_raid_pd_details(self, node_ip, pd_devid):
        """
        查询指定节点的指定 RAID 物理磁盘设备的详细信息

        @param string node_ip       节点 ip
        @param string pd_devid:     设备唯一标识
        @return map<key, value>:    RAID 物理磁盘设备的详细信息

        Parameters:
         - node_ip
         - pd_devid

        """
        pass

    def get_raid_ld_details(self, node_ip, ld_devid):
        """
        查询指定节点的指定 RAID 逻辑磁盘设备的详细信息

        @param string node_ip       节点 ip
        @param string ld_devid:     设备唯一标识
        @return map<key, value>:    RAID 逻辑设备的详细信息

        Parameters:
         - node_ip
         - ld_devid

        """
        pass

    def init_free_data_raid_pds(self, node_ip, pd_devids, bond_disks_num):
        """
        初始化指定节点上的指定空闲数据RAID物理磁盘
        空闲数据RAID物理磁盘：指尚未加入存储池的数据RAID物理磁盘

        @param string node_ip            节点 ip
        @param list<pd_devid> pd_devids  需要初始化的RAID物理磁盘设备列表
        @param int bond_disks_num        指定将几个磁盘绑定为一个数据盘
                                         == 1：表示使用一个磁盘，对应一个数据盘
                                         > 1：通常用于单副本，需要做RAID5的环境，将 n 个磁盘组合成一个数据盘
                                         PS：> 1 仅对RAID环境生效，裸磁盘均默认按 == 1 处理.
        @return map<ld_devid, ldinfo>    返回初始化创建的RAID逻辑卷列表

        Parameters:
         - node_ip
         - pd_devids
         - bond_disks_num

        """
        pass

    def add_raid_hotspare(self, node_ip, pd_devid, ld_devid):
        """
        在指定节点上添加RAID热备盘

        @param string node_ip        节点 ip
        @param string pd_devid       热备盘ID，可从空闲数据RAID物理磁盘中选取
        @param string ld_devid       指定需要添加热备盘的RAID逻辑磁盘设备ID，若为空，则添加为全局热备盘

        Parameters:
         - node_ip
         - pd_devid
         - ld_devid

        """
        pass

    def remove_raid_hotspare(self, node_ip, pd_devid):
        """
        在指定节点上删除热备盘

        @param string node_ip        节点 ip
        @param string pd_devid       热备盘ID

        Parameters:
         - node_ip
         - pd_devid

        """
        pass

    def get_raid_lds_for_hotspare(self, node_ip):
        """
        获取指定节点上的可添加热备盘的RAID逻辑磁盘列表

        @param string node_ip                    节点 ip
        @return map<ld_devid, ldinfo>            RAID逻辑磁盘列表

        Parameters:
         - node_ip

        """
        pass

    def create_cache_volume(self, node_uuid, disk_dev_path):
        """
        在指定数据盘上创建缓存卷

        @param disk_dev_path(str)    指定磁盘在系统中的设备路径
        @return vol_dev_path(str)    返回所创建的缓存卷设备路径

        Parameters:
         - node_uuid
         - disk_dev_path

        """
        pass

    def remove_cache_volume(self, node_uuid):
        """
        删除缓存卷

        Parameters:
         - node_uuid

        """
        pass

    def get_cache_volume(self, node_uuid):
        """
        获取缓存卷信息
        return ECMSAgent.ncTVolume: 缓存卷信息

        Parameters:
         - node_uuid

        """
        pass

    def init_cache_volume(self, node_uuid):
        """
        初始化缓存卷
        若缓存卷存在，则：清除缓存卷及缓存目录中的数据，并挂载
        若缓存卷不存在，则：清除缓存目录中的数据

        Parameters:
         - node_uuid

        """
        pass

    def is_cache_volume_inited(self, node_uuid):
        """
        判断缓存卷是否已初始化
        若缓存卷存在，若缓存卷中无数据，且已挂载，则已初始化
        若缓存卷不存在，若缓存目录存在，且无数据，则未初始化

        Parameters:
         - node_uuid

        """
        pass

    def mount_cache_volume(self, node_uuid):
        """
        挂载缓存卷
        若缓存卷不存在，则忽略
        若缓存卷挂载失败，则记日志

        Parameters:
         - node_uuid

        """
        pass

    def allocate_cache_volume(self, node_uuid):
        """
        为各应用分配缓存卷

        Parameters:
         - node_uuid

        """
        pass

    def get_sys_volume(self, node_uuid):
        """
        @param <string> node_uuid 节点uuid
        @return ECMSAgent.ncTVolume 系统卷相关信息
        获取指定节点系统卷信息

        Parameters:
         - node_uuid

        """
        pass

    def get_sysvol_volume(self, node_uuid):
        """
        @param <string> node_uuid 节点uuid
        @return ECMSAgent.ncTVolume sysvol卷相关信息
        获取指定节点系统卷信息

        Parameters:
         - node_uuid

        """
        pass

    def get_disk_info(self, node_uuid, dev_path):
        """
        获取指定节点上指定磁盘的信息
        @param <string> node_uuid 节点uuid
        @param map<string, string> 指定磁盘相关信息

        Parameters:
         - node_uuid
         - dev_path

        """
        pass

    def get_data_disks(self, node_uuid):
        """
        获取指定节点上所有数据盘
        @param string node_uuid 节点uuid
        @return data_disks(map<disk_dev_path, ncTDataDisk>)        返回数据盘列表

        Parameters:
         - node_uuid

        """
        pass

    def get_storage_console_address(self, storage_server_name):
        """
        获取存储（本地Ceph）控制台登录地址
        @param string       storage_server_name Ceph 对象存储访问地址
        @return string      Ceph 控制台登录地址

        Parameters:
         - storage_server_name

        """
        pass

    def get_local_ceph_storage_info(self, storage_server_name):
        """
        获取本地Ceph存储的容量信息
        @param string       storage_server_name Ceph 对象存储访问地址
        @return ncTCephStorageInfo

        Parameters:
         - storage_server_name

        """
        pass

    def set_local_ceph_manage_vip(self, ceph_manage_vip):
        """
        设置存储（本地Ceph）管理vip
        @param string       ceph_manage_vip Ceph 管理vip
                            参数可以是ip或者域名，接口内不做检查

        Parameters:
         - ceph_manage_vip

        """
        pass

    def get_local_ceph_manage_vip(self):
        """
        获取存储（本地Ceph）管理vip
        @return string      ceph_manage_vip Ceph 管理vip

        """
        pass

    def get_zabbix_status(self):
        """
         * 获取监控服务状态
         * @return  bool    True:   启用
         *                  False:  禁用
        *

        """
        pass

    def enable_zabbix(self):
        """
        启用 zabbix
        初始化数据库, 导入配置, 创建主机, 链接模板


        """
        pass

    def disable_zabbix(self):
        """
        禁用 zabbix
        停止服务


        """
        pass

    def get_alert_trigger_status(self):
        """
        * 获取告警项状态
        * @return map<string, bool>
        *                                  string: 触发器分类
        *                                  i32:
                                               1:  触发器正常
                                               0:  触发器异常
                                               -1: 对应监控不存在

        """
        pass

    def is_alert_enable(self):
        """
        获取告警通知开关状态
        @return  bool                    True: 开启, False: 关闭

        """
        pass

    def enable_alert(self):
        """
        启用告警通知

        """
        pass

    def disable_alert(self):
        """
        禁用告警通知

        """
        pass

    def enable_maintenance(self):
        """
        启用监控维护模式

        """
        pass

    def disable_maintenance(self):
        """
        禁用监控维护模式

        """
        pass

    def get_maintenance_status(self):
        """
        获取监控维护模式状态
        @return bool False : 维护模式禁用
                     True  : 维护模式启用

        """
        pass

    def get_service_problem_records(self, ipaddr, time_from, time_till):
        """
        获取系统服务异常记录
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_database_problem_records(self, ipaddr, time_from, time_till):
        """
        获取数据库异常记录
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_cpu_problem_records(self, ipaddr, threshold, time_from, time_till):
        """
        获取 CPU 异常记录
        @param string ipaddr 节点的 IP 地址
        @param double threshold CPU 负载阈值, 高于阈值则认为异常
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - threshold
         - time_from
         - time_till

        """
        pass

    def get_sysvol_problem_records(self, ipaddr, time_from, time_till):
        """
        获取系统卷异常记录
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_memory_problem_records(self, ipaddr, threshold, time_from, time_till):
        """
        获取内存异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   double  threshold   内存负载阈值, 高于阈值则认为异常
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - threshold
         - time_from
         - time_till

        """
        pass

    def get_self_backup_problem_records(self, ipaddr, time_from, time_till):
        """
        获取系统自备份异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_node_online_problem_records(self, ipaddr, time_from, time_till):
        """
        获取节点在线状态异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_node_switch_problem_records(self, ipaddr, time_from, time_till):
        """
        获取节点切换异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_replicas_problem_records(self, ipaddr, time_from, time_till):
        """
        获取对象存储副本健康度异常记录
        副本健康度非 100.0% 为异常
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_storage_dev_problem_records(self, ipaddr, time_from, time_till):
        """
        获取存储池设备异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def get_balance_problem_records(self, ipaddr, time_from, time_till):
        """
        获取对象存储负载均衡异常记录
        负载均衡小于 0 为异常
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        pass

    def add_storage_node(self, node_uuid):
        """
        添加存储节点
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def del_storage_node(self, node_uuid):
        """
        移除存储节点
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def get_storage_node_info(self):
        """
        获取存储节点信息

        """
        pass

    def get_storage_master_node_ip(self):
        """
        获取存储子系统主节点 ip
        存储主节点，只是按照一定规则获取的一个在线的存储节点
        注意：接口不拋错, 若没有查找到可用节点ip,返回为空字符串""
        @return  <string> ip

        """
        pass

    def enable_storage_lvs(self, node_uuid):
        """
        启用指定节点的存储lvs
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def disable_storage_lvs(self, node_uuid):
        """
        禁用指定节点的存储lvs
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def add_application_node(self, node_uuid):
        """
        添加应用节点
        @param node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def del_application_node(self, node_uuid):
        """
        移除应用节点
        @param node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def get_app_node_info(self):
        """
        获取应用节点信息

        """
        pass

    def get_app_master_node_info(self):
        """
        获取应用子系统主节点
        @return  ncTAppNodeInfo  应用节点信息

        """
        pass

    def get_app_master_node_ip(self):
        """
        获取应用子系统主节点 ip
        注意：接口不拋错, 若没有查找到可用节点ip,返回为空字符串""
        @return  <string> ip

        """
        pass

    def enable_app_lvs(self, node_uuid):
        """
        启用指定节点的应用lvs
        @param   string  node_uuid  节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def disable_app_lvs(self, node_uuid):
        """
        禁用指定节点的应用lvs
        @param   string  node_uuid   节点uuid

        Parameters:
         - node_uuid

        """
        pass

    def get_application_service(self):
        """
        获取所有应用服务
        @return  list<ncTAppServiceInfo>

        """
        pass

    def add_application_service(self, service_name, port, is_lvs):
        """
        添加应用服务
        @param string service_name 服务名
        @param i32    port         端口
        @param bool   is_lvs       是否进行端口转发

        Parameters:
         - service_name
         - port
         - is_lvs

        """
        pass

    def del_application_service(self, service_name):
        """
        移除应用服务
        @param string service 服务名

        Parameters:
         - service_name

        """
        pass

    def get_service_status(self, node_uuid, service_name):
        """
        获取指定节点服务状态: systemctl status service_name
        @param <string> node_uuid 节点uuid
        @param <string> service_name 服务名

        Parameters:
         - node_uuid
         - service_name

        """
        pass

    def is_app_registered(self, app_name):
        """
        检查单点应用是否在集群中注册安装
        @param   string  app_name    单点应用名称
        @return  bool                True, 单点应用已在集群中安装
                                     False, 单点应用未在集群中安装

        Parameters:
         - app_name

        """
        pass

    def add_single_application_node(self, node_uuid, app_name):
        """
        设置单点应用节点
        @param string node_uuid 节点uuid
        @param string app_name

        Parameters:
         - node_uuid
         - app_name

        """
        pass

    def del_single_application_node(self, app_name):
        """
        取消单点应用节点
        @param string app_name

        Parameters:
         - app_name

        """
        pass

    def get_single_application_service_by_node(self, node_uuid):
        """
        根据节点获取单点应用服务
        @param   string  node_uuid    节点 UUID
        @return  list<ncTAPPServiceInfo>

        Parameters:
         - node_uuid

        """
        pass

    def get_node_uuid_by_app_name(self, app_name):
        """
        根据应用获取单点应用节点UUID
        @param   string  app_name    应用名
        @return  string              节点 UUID

        Parameters:
         - app_name

        """
        pass

    def get_app_host_ip(self, app_name):
        """
        获取安装单点应用的节点 IP
        @param   string  app_name    单点应用名称
        @return  string              节点IP

        Parameters:
         - app_name

        """
        pass

    def verify_sign_in(self, user, password):
        """
        验证登录信息
        @param <string> user 用户名
        @param <string> password 密码
        @return 验证结果  uuid 验证通过
                          ncTSignRet.USER_ERR 用户名错误
                          ncTSignRet.PWD_ERR 密码验证失败

        Parameters:
         - user
         - password

        """
        pass

    def app_sys_status(self):
        """
        应用子系统是否可用,如果可用登陆验证使用应用子系统的验证接口
        如果不可用,则使用集群验证接口
        @return True: 应用子系统可用
                False: 没有应用子系统,或应用子系统不可用

        """
        pass

    def update_password(self, uuid, password):
        """
        修改密码
        @param uuid 管理员用户uuid, 同ShareMgnt.NCT_USER_ADMIN
        @param password 密码

        Parameters:
         - uuid
         - password

        """
        pass

    def update_user_name(self, uuid, user_name):
        """
        修改用户名
        @param uuid 管理员用户uuid, 同ShareMgnt.NCT_USER_ADMIN
        @param user_name 用户名

        Parameters:
         - uuid
         - user_name

        """
        pass

    def commit_conf_file(self, conf_file_path, source_file_path):
        """
        提交配置文件，给集群进行自动一致性管理
        注意：提交后，所有节点将在检测周期内生效，不是立即生效。
        @param string conf_file_path: 需在各节点保持一致的配置文件路径，
                                      注意:需在AnyShareConfig/distributed_conf_files.conf中登记使配置
                                      生效的回调命令，若未登记则不允许提交。
        @param string source_file_path: 配置内容的来源文件路径，
                                        注意：若已在集群中提交过的配置文件，需再次提交时，最好不要在
                                        conf_file_path上直接进行修改然后作为来源文件提交，因为有可能
                                        会被集群自动还原。

        Parameters:
         - conf_file_path
         - source_file_path

        """
        pass

    def commit_conf_file_content(self, conf_file_path, file_content):
        """
        提交配置文件内容，给集群进行自动一致性管理
        注意：提交后，所有节点将在检测周期内生效，不是立即生效。
        @param string conf_file_path: 需在各节点保持一致的配置文件路径，
                                      注意:需在AnyShareConfig/distributed_conf_files.conf中登记使配置
                                      生效的回调命令，若未登记则不允许提交。
        @param string file_content: 配置内容的来源文件内容。

        Parameters:
         - conf_file_path
         - file_content

        """
        pass

    def delete_conf_file(self, conf_file_path):
        """
        从集群中移除对指定配置文件的自动一致性管理
        若已移除，则忽略
        @param string conf_file_path: 配置文件路径

        Parameters:
         - conf_file_path

        """
        pass

    def get_commited_conf_files(self):
        """
        获取已经提交到集群的分布式配置文件列表
        @return map<string, ncTConfFileInfo>

        """
        pass

    def set_dns_server(self, nameservers):
        """
        添加 DNS 服务器
        @param nameservers: DNS 服务器地址列表，可以包含 0-3 个元素

        Parameters:
         - nameservers

        """
        pass

    def get_dns_server(self):
        """
        获取 DNS 服务器信息
        @return DNS 服务器地址列表

        """
        pass

    def get_chrony_status(self):
        """
        获取时间同步服务状态
        @return  bool    True:   启用
                         False:  禁用

        """
        pass

    def disable_chrony(self):
        """
        禁用时间同步服务


        """
        pass

    def enable_chrony(self):
        """
        启用时间同步服务
        配置已添加的外部时间服务器

        """
        pass

    def add_time_server(self, server):
        """
        添加外部时间服务器, 可以是IP或域名, 若是域名则需要配置 dns
        限制，集群中存在离线节点时，不能添加外部时间服务器
        @param string ntp_server: 外部时间服务器

        Parameters:
         - server

        """
        pass

    def del_time_server(self, server):
        """
        删除指定外部时间服务器，不存在指定时间服务器仍可正常执行
        @param string ntp_server: 外部时间服务器

        Parameters:
         - server

        """
        pass

    def get_time_server(self):
        """
        获取当前集群中所有配置的外部时间服务器,不包含本地源 "127.127.1.0"

        """
        pass

    def install_service(self, server_name):
        """
        安装服务
        @param server_name 需要安装的服务名

        Parameters:
         - server_name

        """
        pass

    def uninstall_service(self, server_name):
        """
        卸载服务

        Parameters:
         - server_name

        """
        pass

    def get_node_service(self):
        """
        获取各个节点已安装的服务

        """
        pass


class Client(Iface):
    """
    ECMSManager thift 管理接口

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def is_node_dirty(self, host, port, user, passwd):
        """
        节点环境是否干净
        @param   <string>    host    节点 IP 地址
        @param   <i32>       port    SSH 端口
        @param   <string>    user    SSH 用户
        @param   <string>    passwd  SSH 密码
        @return  <bool>                          True:   节点环境不干净
                                                 False:  节点环境干净

        Parameters:
         - host
         - port
         - user
         - passwd

        """
        self.send_is_node_dirty(host, port, user, passwd)
        return self.recv_is_node_dirty()

    def send_is_node_dirty(self, host, port, user, passwd):
        self._oprot.writeMessageBegin('is_node_dirty', TMessageType.CALL, self._seqid)
        args = is_node_dirty_args()
        args.host = host
        args.port = port
        args.user = user
        args.passwd = passwd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_node_dirty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_node_dirty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_node_dirty failed: unknown result")

    def is_env_dirty(self, node_ipaddr):
        """
        检查节点环境是否干净
        前提：可以连通被检查节点，开放了集群管理服务的访问端口
        @param   <string>    node_ipaddr    节点 IP 地址
        @return  <bool>                          True:   节点环境不干净
                                                 False:  节点环境干净

        Parameters:
         - node_ipaddr

        """
        self.send_is_env_dirty(node_ipaddr)
        return self.recv_is_env_dirty()

    def send_is_env_dirty(self, node_ipaddr):
        self._oprot.writeMessageBegin('is_env_dirty', TMessageType.CALL, self._seqid)
        args = is_env_dirty_args()
        args.node_ipaddr = node_ipaddr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_env_dirty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_env_dirty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_env_dirty failed: unknown result")

    def clear_node(self, node_ipaddr):
        """
        清理节点
        @param   <string>    node_ipaddr         节点 IP 地址

        Parameters:
         - node_ipaddr

        """
        self.send_clear_node(node_ipaddr)
        self.recv_clear_node()

    def send_clear_node(self, node_ipaddr):
        self._oprot.writeMessageBegin('clear_node', TMessageType.CALL, self._seqid)
        args = clear_node_args()
        args.node_ipaddr = node_ipaddr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def active_cluster(self, node_ipaddr):
        """
        激活集群
        @param   <string>    node_ipaddr         节点 IP 地址
        @return  <string>                        集群 UUID

        Parameters:
         - node_ipaddr

        """
        self.send_active_cluster(node_ipaddr)
        return self.recv_active_cluster()

    def send_active_cluster(self, node_ipaddr):
        self._oprot.writeMessageBegin('active_cluster', TMessageType.CALL, self._seqid)
        args = active_cluster_args()
        args.node_ipaddr = node_ipaddr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_active_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = active_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "active_cluster failed: unknown result")

    def add_node(self, host):
        """
        添加节点
        @param   <string>    host    节点 IP 地址
        @return  <string>            节点 UUID

        Parameters:
         - host

        """
        self.send_add_node(host)
        return self.recv_add_node()

    def send_add_node(self, host):
        self._oprot.writeMessageBegin('add_node', TMessageType.CALL, self._seqid)
        args = add_node_args()
        args.host = host
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_node failed: unknown result")

    def del_node(self, node_uuid):
        """
        移除节点
        @param   <string>    node_uuid   节点 UUID

        Parameters:
         - node_uuid

        """
        self.send_del_node(node_uuid)
        self.recv_del_node()

    def send_del_node(self, node_uuid):
        self._oprot.writeMessageBegin('del_node', TMessageType.CALL, self._seqid)
        args = del_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_module_status(self, module_name):
        """
        获取模块状态
        @param   <string>    module_name  模块名

        Parameters:
         - module_name

        """
        self.send_get_module_status(module_name)
        return self.recv_get_module_status()

    def send_get_module_status(self, module_name):
        self._oprot.writeMessageBegin('get_module_status', TMessageType.CALL, self._seqid)
        args = get_module_status_args()
        args.module_name = module_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_module_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_module_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_module_status failed: unknown result")

    def enable_module(self, module_name):
        """
        启用模块
        @param   <string>    module_name  模块名

        Parameters:
         - module_name

        """
        self.send_enable_module(module_name)
        self.recv_enable_module()

    def send_enable_module(self, module_name):
        self._oprot.writeMessageBegin('enable_module', TMessageType.CALL, self._seqid)
        args = enable_module_args()
        args.module_name = module_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_module(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_module_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_module(self, module_name):
        """
        禁用模块
        @param   <string>    module_name  模块名

        Parameters:
         - module_name

        """
        self.send_disable_module(module_name)
        self.recv_disable_module()

    def send_disable_module(self, module_name):
        self._oprot.writeMessageBegin('disable_module', TMessageType.CALL, self._seqid)
        args = disable_module_args()
        args.module_name = module_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_module(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_module_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def create_ecms_db(self):
        """
        创建ecms集群管理数据库

        """
        self.send_create_ecms_db()
        self.recv_create_ecms_db()

    def send_create_ecms_db(self):
        self._oprot.writeMessageBegin('create_ecms_db', TMessageType.CALL, self._seqid)
        args = create_ecms_db_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_ecms_db(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_ecms_db_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_db_node_info(self):
        """
        获取数据库节点信息
        @return list<ncTDBNodeInfo> 数据库节点信息列表

        """
        self.send_get_db_node_info()
        return self.recv_get_db_node_info()

    def send_get_db_node_info(self):
        self._oprot.writeMessageBegin('get_db_node_info', TMessageType.CALL, self._seqid)
        args = get_db_node_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_node_info failed: unknown result")

    def set_db_master(self, node_uuid):
        """
        设置数据库主库
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        self.send_set_db_master(node_uuid)
        self.recv_set_db_master()

    def send_set_db_master(self, node_uuid):
        self._oprot.writeMessageBegin('set_db_master', TMessageType.CALL, self._seqid)
        args = set_db_master_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_db_master(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_db_master_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_db_slave(self, node_uuid):
        """
        设置数据库备份从节点
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        self.send_set_db_slave(node_uuid)
        self.recv_set_db_slave()

    def send_set_db_slave(self, node_uuid):
        self._oprot.writeMessageBegin('set_db_slave', TMessageType.CALL, self._seqid)
        args = set_db_slave_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_db_slave(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_db_slave_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_db_slave_by_xtrabackup(self, node_uuid, slave_ssh_info):
        """
        设置数据库备份从节点,根据空间大小自动判断使用xtrabackup备份方式或者mysqldump
        @param <string>      node_uuid 节点ID
        @param ECMSAgent.ncTSSHInfo slave_ssh_info  数据库高可用备份从节点 ssh 信息
               ncTSSHInfo.host     : 主机地址
               ncTSSHInfo.port     : 连接端口
               ncTSSHInfo.user     : ssh 用户
               ncTSSHInfo.password : ssh 密码

        Parameters:
         - node_uuid
         - slave_ssh_info

        """
        self.send_set_db_slave_by_xtrabackup(node_uuid, slave_ssh_info)
        self.recv_set_db_slave_by_xtrabackup()

    def send_set_db_slave_by_xtrabackup(self, node_uuid, slave_ssh_info):
        self._oprot.writeMessageBegin('set_db_slave_by_xtrabackup', TMessageType.CALL, self._seqid)
        args = set_db_slave_by_xtrabackup_args()
        args.node_uuid = node_uuid
        args.slave_ssh_info = slave_ssh_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_db_slave_by_xtrabackup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_db_slave_by_xtrabackup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def cancel_db_node(self, node_uuid):
        """
        移出数据库节点
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        self.send_cancel_db_node(node_uuid)
        self.recv_cancel_db_node()

    def send_cancel_db_node(self, node_uuid):
        self._oprot.writeMessageBegin('cancel_db_node', TMessageType.CALL, self._seqid)
        args = cancel_db_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_db_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_db_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def update_deployment_mode(self, mode):
        """
        更新集群部署模式
        @param <string>   mode 部署模式 NCT_STANDARD_MODE
                                        NCT_PROFESSIONAL_MODE

        Parameters:
         - mode

        """
        self.send_update_deployment_mode(mode)
        self.recv_update_deployment_mode()

    def send_update_deployment_mode(self, mode):
        self._oprot.writeMessageBegin('update_deployment_mode', TMessageType.CALL, self._seqid)
        args = update_deployment_mode_args()
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_deployment_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_deployment_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_deployment_mode(self):
        """
        获取集群部署模式

        """
        self.send_get_deployment_mode()
        return self.recv_get_deployment_mode()

    def send_get_deployment_mode(self):
        self._oprot.writeMessageBegin('get_deployment_mode', TMessageType.CALL, self._seqid)
        args = get_deployment_mode_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_deployment_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_deployment_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_deployment_mode failed: unknown result")

    def dump_databases_to_path(self, host, port, db_name, path):
        """
        使用mysqldump导出数据到指定目录
        @param <string> host 数据库地址
        @param <int> port 数据库端口
        @param <string> db_name 数据库名
        @param <string> path 导出目录绝对路径

        Parameters:
         - host
         - port
         - db_name
         - path

        """
        self.send_dump_databases_to_path(host, port, db_name, path)
        self.recv_dump_databases_to_path()

    def send_dump_databases_to_path(self, host, port, db_name, path):
        self._oprot.writeMessageBegin('dump_databases_to_path', TMessageType.CALL, self._seqid)
        args = dump_databases_to_path_args()
        args.host = host
        args.port = port
        args.db_name = db_name
        args.path = path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dump_databases_to_path(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dump_databases_to_path_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_databases_name(self, host, port):
        """
        获取数据库名
        注:过滤了"information_schema", "mysql", "performance_schema", "sys"数据库
        @param <string> host 数据库地址
        @param <int> port 数据库端口
        @return list<string> 数据库名称列表

        Parameters:
         - host
         - port

        """
        self.send_get_databases_name(host, port)
        return self.recv_get_databases_name()

    def send_get_databases_name(self, host, port):
        self._oprot.writeMessageBegin('get_databases_name', TMessageType.CALL, self._seqid)
        args = get_databases_name_args()
        args.host = host
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_databases_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_databases_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases_name failed: unknown result")

    def purge_binlogs(self, node_uuid):
        """
        移除指定数据库节点的binlog文件
        @param <string> 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_purge_binlogs(node_uuid)
        self.recv_purge_binlogs()

    def send_purge_binlogs(self, node_uuid):
        self._oprot.writeMessageBegin('purge_binlogs', TMessageType.CALL, self._seqid)
        args = purge_binlogs_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_purge_binlogs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = purge_binlogs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def update_external_db_info(self, info):
        """
        更新第三方数据库信息
        @param ncTExternalDBInfo info 第三方数据库信息
               ncTExternalDBInfo.db_host:第三方数据库地址,
               ncTExternalDBInfo.db_port:第三方数据库端口,
               ncTExternalDBInfo.db_user:第三方数据库用户,
               ncTExternalDBInfo.db_password:第三方数据库密码

        Parameters:
         - info

        """
        self.send_update_external_db_info(info)
        self.recv_update_external_db_info()

    def send_update_external_db_info(self, info):
        self._oprot.writeMessageBegin('update_external_db_info', TMessageType.CALL, self._seqid)
        args = update_external_db_info_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_external_db_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_external_db_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_external_db_info(self):
        """
        获取第三方数据库信息
        @return <ncTExternalDBInfo> 第三方数据库连接结构,结构属性同上

        """
        self.send_get_external_db_info()
        return self.recv_get_external_db_info()

    def send_get_external_db_info(self):
        self._oprot.writeMessageBegin('get_external_db_info', TMessageType.CALL, self._seqid)
        args = get_external_db_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_external_db_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_external_db_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_external_db_info failed: unknown result")

    def is_external_db(self):
        """
        判断是否使用第三方数据库

        """
        self.send_is_external_db()
        return self.recv_is_external_db()

    def send_is_external_db(self):
        self._oprot.writeMessageBegin('is_external_db', TMessageType.CALL, self._seqid)
        args = is_external_db_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_external_db(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_external_db_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_external_db failed: unknown result")

    def is_available_external_db(self, info):
        """
        测试第三方数据库是否可用
        @return <bool> True:可用 | False 不可用

        Parameters:
         - info

        """
        self.send_is_available_external_db(info)
        return self.recv_is_available_external_db()

    def send_is_available_external_db(self, info):
        self._oprot.writeMessageBegin('is_available_external_db', TMessageType.CALL, self._seqid)
        args = is_available_external_db_args()
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_available_external_db(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_available_external_db_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_available_external_db failed: unknown result")

    def add_firewall_rule(self, firewall_info):
        """
        添加防火墙规则
        @param <ncTFirewallInfo> firewall_info 待添加防火墙信息结构

        Parameters:
         - firewall_info

        """
        self.send_add_firewall_rule(firewall_info)
        self.recv_add_firewall_rule()

    def send_add_firewall_rule(self, firewall_info):
        self._oprot.writeMessageBegin('add_firewall_rule', TMessageType.CALL, self._seqid)
        args = add_firewall_rule_args()
        args.firewall_info = firewall_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_firewall_rule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_firewall_rule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def del_firewall_rule(self, firewall_info):
        """
        删除防火墙规则
        @param <ncTFirewallInfo> firewall_info 待删除防火墙信息结构

        Parameters:
         - firewall_info

        """
        self.send_del_firewall_rule(firewall_info)
        self.recv_del_firewall_rule()

    def send_del_firewall_rule(self, firewall_info):
        self._oprot.writeMessageBegin('del_firewall_rule', TMessageType.CALL, self._seqid)
        args = del_firewall_rule_args()
        args.firewall_info = firewall_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_firewall_rule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_firewall_rule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def update_firewall_rule(self, old_info, new_info):
        """
        修改防火墙规则
        @param <ncTFirewallInfo> old_info 待修改防火墙信息结构
        @param <ncTFirewallInfo> new_info 修改后防火墙信息结构

        Parameters:
         - old_info
         - new_info

        """
        self.send_update_firewall_rule(old_info, new_info)
        self.recv_update_firewall_rule()

    def send_update_firewall_rule(self, old_info, new_info):
        self._oprot.writeMessageBegin('update_firewall_rule', TMessageType.CALL, self._seqid)
        args = update_firewall_rule_args()
        args.old_info = old_info
        args.new_info = new_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_firewall_rule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_firewall_rule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_firewall_rule(self, sys_role):
        """
        获取指定子系统所有防火墙规则
        param <string> sys_role 规则所属的子系统,参数如下
                                db:      数据库子系统
                                app:     应用子系统
                                ecms:    集群管理子系统
                                basic:   基础规则,所有节点应用
                                storage: 存储子系统
        return list<ncTFirewallInfo> 防火墙结构信息列表

        Parameters:
         - sys_role

        """
        self.send_get_firewall_rule(sys_role)
        return self.recv_get_firewall_rule()

    def send_get_firewall_rule(self, sys_role):
        self._oprot.writeMessageBegin('get_firewall_rule', TMessageType.CALL, self._seqid)
        args = get_firewall_rule_args()
        args.sys_role = sys_role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_firewall_rule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_firewall_rule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_firewall_rule failed: unknown result")

    def enable_firewall(self):
        """
        启用集群防火墙

        """
        self.send_enable_firewall()
        self.recv_enable_firewall()

    def send_enable_firewall(self):
        self._oprot.writeMessageBegin('enable_firewall', TMessageType.CALL, self._seqid)
        args = enable_firewall_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_firewall(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_firewall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_firewall(self):
        """
        禁用集群防火墙

        """
        self.send_disable_firewall()
        self.recv_disable_firewall()

    def send_disable_firewall(self):
        self._oprot.writeMessageBegin('disable_firewall', TMessageType.CALL, self._seqid)
        args = disable_firewall_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_firewall(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_firewall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_firewall_status(self):
        """
        * 获取集群防火墙状态
        * return bool True:  防火墙开启
                      False: 防火墙关闭

        """
        self.send_get_firewall_status()
        return self.recv_get_firewall_status()

    def send_get_firewall_status(self):
        self._oprot.writeMessageBegin('get_firewall_status', TMessageType.CALL, self._seqid)
        args = get_firewall_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_firewall_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_firewall_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_firewall_status failed: unknown result")

    def enable_sys_service(self, sys_role):
        """
        允许子系统对外服务
        param <string> sys_role 规则所属的子系统,参数及含义如下
                                db:      数据库子系统
                                app:     应用子系统
                                ecms:    集群管理子系统
                                basic:   基础规则,所有节点应用
                                storage: 存储子系统

        Parameters:
         - sys_role

        """
        self.send_enable_sys_service(sys_role)
        self.recv_enable_sys_service()

    def send_enable_sys_service(self, sys_role):
        self._oprot.writeMessageBegin('enable_sys_service', TMessageType.CALL, self._seqid)
        args = enable_sys_service_args()
        args.sys_role = sys_role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_sys_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_sys_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_sys_service(self, sys_role):
        """
        禁止子系统对外服务
        param <string> sys_role 规则所属的子系统,参数及含义如下
                                db:      数据库子系统
                                app:     应用子系统
                                ecms:    集群管理子系统
                                basic:   基础规则,所有节点应用
                                storage: 存储子系统

        Parameters:
         - sys_role

        """
        self.send_disable_sys_service(sys_role)
        self.recv_disable_sys_service()

    def send_disable_sys_service(self, sys_role):
        self._oprot.writeMessageBegin('disable_sys_service', TMessageType.CALL, self._seqid)
        args = disable_sys_service_args()
        args.sys_role = sys_role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_sys_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_sys_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_sys_service_status(self, sys_role):
        """
        * 获取子系统对外服务状态
        * param <string> sys_role 规则所属的子系统,参数及含义如下
        *                         db:      数据库子系统
        *                         app:     应用子系统
        *                         ecms:    集群管理子系统
        *                         basic:   基础规则,所有节点应用
        *                         storage: 存储子系统
        * return bool True:       允许子系统对外服务
                      False:      禁止子系统对外服务

        Parameters:
         - sys_role

        """
        self.send_get_sys_service_status(sys_role)
        return self.recv_get_sys_service_status()

    def send_get_sys_service_status(self, sys_role):
        self._oprot.writeMessageBegin('get_sys_service_status', TMessageType.CALL, self._seqid)
        args = get_sys_service_status_args()
        args.sys_role = sys_role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sys_service_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sys_service_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sys_service_status failed: unknown result")

    def add_trusted_ip(self, ip_list):
        """
        Parameters:
         - ip_list

        """
        self.send_add_trusted_ip(ip_list)
        self.recv_add_trusted_ip()

    def send_add_trusted_ip(self, ip_list):
        self._oprot.writeMessageBegin('add_trusted_ip', TMessageType.CALL, self._seqid)
        args = add_trusted_ip_args()
        args.ip_list = ip_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_trusted_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_trusted_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_storage_trusted_ip(self, firewall_list):
        """
        Parameters:
         - firewall_list

        """
        self.send_set_storage_trusted_ip(firewall_list)
        self.recv_set_storage_trusted_ip()

    def send_set_storage_trusted_ip(self, firewall_list):
        self._oprot.writeMessageBegin('set_storage_trusted_ip', TMessageType.CALL, self._seqid)
        args = set_storage_trusted_ip_args()
        args.firewall_list = firewall_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_storage_trusted_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_storage_trusted_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_asu_node_ip(self):
        self.send_get_asu_node_ip()
        return self.recv_get_asu_node_ip()

    def send_get_asu_node_ip(self):
        self._oprot.writeMessageBegin('get_asu_node_ip', TMessageType.CALL, self._seqid)
        args = get_asu_node_ip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_asu_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_asu_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_asu_node_ip failed: unknown result")

    def get_keepalived_status(self):
        """
        获取高可用模块启用状态
        @return  bool    True:   启用
                         False:  禁用


        """
        self.send_get_keepalived_status()
        return self.recv_get_keepalived_status()

    def send_get_keepalived_status(self):
        self._oprot.writeMessageBegin('get_keepalived_status', TMessageType.CALL, self._seqid)
        args = get_keepalived_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_keepalived_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_keepalived_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_keepalived_status failed: unknown result")

    def enable_keepalived(self):
        """
        启用高可用模块


        """
        self.send_enable_keepalived()
        self.recv_enable_keepalived()

    def send_enable_keepalived(self):
        self._oprot.writeMessageBegin('enable_keepalived', TMessageType.CALL, self._seqid)
        args = enable_keepalived_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_keepalived(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_keepalived_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_keepalived(self):
        """
        禁用高可用模块


        """
        self.send_disable_keepalived()
        self.recv_disable_keepalived()

    def send_disable_keepalived(self):
        self._oprot.writeMessageBegin('disable_keepalived', TMessageType.CALL, self._seqid)
        args = disable_keepalived_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_keepalived(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_keepalived_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_vip_info(self):
        """
        获取高可用vip信息列表
        @return <ncTVipInfo> vip信息结构

        """
        self.send_get_vip_info()
        return self.recv_get_vip_info()

    def send_get_vip_info(self):
        self._oprot.writeMessageBegin('get_vip_info', TMessageType.CALL, self._seqid)
        args = get_vip_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_vip_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_vip_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_vip_info failed: unknown result")

    def set_vip_info(self, vip_info):
        """
        修改高可用vip信息
        @param <ncTVipInfo> 待设置的vip信息结构
        例: ncTVipInfo(vip='192.168.136.1', nic='ens32', mask='255.255.255.0', sys=ncTHaSys.BASIC)

        Parameters:
         - vip_info

        """
        self.send_set_vip_info(vip_info)
        self.recv_set_vip_info()

    def send_set_vip_info(self, vip_info):
        self._oprot.writeMessageBegin('set_vip_info', TMessageType.CALL, self._seqid)
        args = set_vip_info_args()
        args.vip_info = vip_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_vip_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_vip_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_ivip_info(self, ivip_info):
        """
        修改高可用ivip信息
        @param <ncTVipInfo> 待设置的ivip信息结构

        Parameters:
         - ivip_info

        """
        self.send_set_ivip_info(ivip_info)
        self.recv_set_ivip_info()

    def send_set_ivip_info(self, ivip_info):
        self._oprot.writeMessageBegin('set_ivip_info', TMessageType.CALL, self._seqid)
        args = set_ivip_info_args()
        args.ivip_info = ivip_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_ivip_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_ivip_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_ha_node_info(self):
        """
        获取所有的ha节点信息
        @return list<ncTHaNodeInfo> 高可用节点信息列表

        """
        self.send_get_ha_node_info()
        return self.recv_get_ha_node_info()

    def send_get_ha_node_info(self):
        self._oprot.writeMessageBegin('get_ha_node_info', TMessageType.CALL, self._seqid)
        args = get_ha_node_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_ha_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_ha_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_ha_node_info failed: unknown result")

    def set_ha_master(self, node_uuid, vip_info):
        """
        设置高可用主节点
        @param <string>      node_uuid 节点ID
        @param <ncTVipInfo>  vip_info  vip信息结构
        例1：单vip方案, vip参数如下, sys为标记高可用节点所属子系统
        ncTVipInfo(vip='192.168.136.1', nic='ens32', mask='255.255.255.0', sys=ncTHaSys.BASIC)
        例2：多vip方案，设置应用子系统高可用
        ncTVipInfo(vip='192.168.136.1', nic='ens32', mask='255.255.255.0', sys=ncTHaSys.APP)

        Parameters:
         - node_uuid
         - vip_info

        """
        self.send_set_ha_master(node_uuid, vip_info)
        self.recv_set_ha_master()

    def send_set_ha_master(self, node_uuid, vip_info):
        self._oprot.writeMessageBegin('set_ha_master', TMessageType.CALL, self._seqid)
        args = set_ha_master_args()
        args.node_uuid = node_uuid
        args.vip_info = vip_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_ha_master(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_ha_master_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_ha_slave(self, node_uuid, ha_sys):
        """
        设置高可用从节点
        @param <string>      node_uuid 节点ID
        @param <int>    ha_sys 所属高可用系统标记,参数使用如下值:
                                    ncTHaSys.BASIC   集群使用一个vip方案使用值
                                    ncTHaSys.APP     应用高可用
                                    ncTHaSys.STORAGE 存储高可用

        Parameters:
         - node_uuid
         - ha_sys

        """
        self.send_set_ha_slave(node_uuid, ha_sys)
        self.recv_set_ha_slave()

    def send_set_ha_slave(self, node_uuid, ha_sys):
        self._oprot.writeMessageBegin('set_ha_slave', TMessageType.CALL, self._seqid)
        args = set_ha_slave_args()
        args.node_uuid = node_uuid
        args.ha_sys = ha_sys
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_ha_slave(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_ha_slave_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def cancel_ha_node(self, node_uuid):
        """
        取消高可用节点
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        self.send_cancel_ha_node(node_uuid)
        self.recv_cancel_ha_node()

    def send_cancel_ha_node(self, node_uuid):
        self._oprot.writeMessageBegin('cancel_ha_node', TMessageType.CALL, self._seqid)
        args = cancel_ha_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_ha_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_ha_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_db_ha_master(self, ivip_info):
        """
        设置数据库高可用主
        @param <ncTVipInfo>      ivip_info 数据库ivip

        Parameters:
         - ivip_info

        """
        self.send_set_db_ha_master(ivip_info)
        self.recv_set_db_ha_master()

    def send_set_db_ha_master(self, ivip_info):
        self._oprot.writeMessageBegin('set_db_ha_master', TMessageType.CALL, self._seqid)
        args = set_db_ha_master_args()
        args.ivip_info = ivip_info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_db_ha_master(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_db_ha_master_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def set_db_ha_slave(self):
        """
        设置数据库高可用从

        """
        self.send_set_db_ha_slave()
        self.recv_set_db_ha_slave()

    def send_set_db_ha_slave(self):
        self._oprot.writeMessageBegin('set_db_ha_slave', TMessageType.CALL, self._seqid)
        args = set_db_ha_slave_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_db_ha_slave(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_db_ha_slave_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def cancel_db_ha_node(self, node_uuid):
        """
        取消数据库高可用
        @param <string>      node_uuid 节点ID

        Parameters:
         - node_uuid

        """
        self.send_cancel_db_ha_node(node_uuid)
        self.recv_cancel_db_ha_node()

    def send_cancel_db_ha_node(self, node_uuid):
        self._oprot.writeMessageBegin('cancel_db_ha_node', TMessageType.CALL, self._seqid)
        args = cancel_db_ha_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_db_ha_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_db_ha_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def on_lvs_changed(self):
        """
        更新lvs

        """
        self.send_on_lvs_changed()
        self.recv_on_lvs_changed()

    def send_on_lvs_changed(self):
        self._oprot.writeMessageBegin('on_lvs_changed', TMessageType.CALL, self._seqid)
        args = on_lvs_changed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_on_lvs_changed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = on_lvs_changed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def on_node_entering_master(self):
        """
        高可用节点进入主

        """
        self.send_on_node_entering_master()
        self.recv_on_node_entering_master()

    def send_on_node_entering_master(self):
        self._oprot.writeMessageBegin('on_node_entering_master', TMessageType.CALL, self._seqid)
        args = on_node_entering_master_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_on_node_entering_master(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = on_node_entering_master_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def on_node_entering_slave(self):
        """
        高可用节点进入从

        """
        self.send_on_node_entering_slave()
        self.recv_on_node_entering_slave()

    def send_on_node_entering_slave(self):
        self._oprot.writeMessageBegin('on_node_entering_slave', TMessageType.CALL, self._seqid)
        args = on_node_entering_slave_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_on_node_entering_slave(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = on_node_entering_slave_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def force_enter_master(self):
        """
        将当前节点临时地强制切换为主节点(慎用！)
        下次keepalived启动时生效，仅一次有效
        PS：强制切换时，会忽略数据库的binlog IO同步状态

        """
        self.send_force_enter_master()
        self.recv_force_enter_master()

    def send_force_enter_master(self):
        self._oprot.writeMessageBegin('force_enter_master', TMessageType.CALL, self._seqid)
        args = force_enter_master_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_force_enter_master(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = force_enter_master_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_node_info(self, node_uuid):
        """
        获取指定节点信息
        @param string node_uuid 节点uuid
        @return <ncTNodeInfo> 节点信息

        Parameters:
         - node_uuid

        """
        self.send_get_node_info(node_uuid)
        return self.recv_get_node_info()

    def send_get_node_info(self, node_uuid):
        self._oprot.writeMessageBegin('get_node_info', TMessageType.CALL, self._seqid)
        args = get_node_info_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_info failed: unknown result")

    def get_all_node_info(self):
        """
        获取所有节点信息
        @return list<ncTNodeInfo> 节点信息列表

        """
        self.send_get_all_node_info()
        return self.recv_get_all_node_info()

    def send_get_all_node_info(self):
        self._oprot.writeMessageBegin('get_all_node_info', TMessageType.CALL, self._seqid)
        args = get_all_node_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_node_info failed: unknown result")

    def set_node_alias(self, node_uuid, node_alias):
        """
        设置节点别名
        @param string node_uuid 节点uuid
        @param string node_alias 节点别名

        Parameters:
         - node_uuid
         - node_alias

        """
        self.send_set_node_alias(node_uuid, node_alias)
        self.recv_set_node_alias()

    def send_set_node_alias(self, node_uuid, node_alias):
        self._oprot.writeMessageBegin('set_node_alias', TMessageType.CALL, self._seqid)
        args = set_node_alias_args()
        args.node_uuid = node_uuid
        args.node_alias = node_alias
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_node_alias(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_node_alias_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def restart_eisooapp(self, node_uuid):
        """
        指定节点异步重启eisooapp服务
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_restart_eisooapp(node_uuid)
        self.recv_restart_eisooapp()

    def send_restart_eisooapp(self, node_uuid):
        self._oprot.writeMessageBegin('restart_eisooapp', TMessageType.CALL, self._seqid)
        args = restart_eisooapp_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restart_eisooapp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restart_eisooapp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def reboot_node(self, node_uuid):
        """
        重启指定节点
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_reboot_node(node_uuid)
        self.recv_reboot_node()

    def send_reboot_node(self, node_uuid):
        self._oprot.writeMessageBegin('reboot_node', TMessageType.CALL, self._seqid)
        args = reboot_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reboot_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reboot_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def shutdown_cluster(self):
        """
        关闭集群所有节点

        """
        self.send_shutdown_cluster()
        self.recv_shutdown_cluster()

    def send_shutdown_cluster(self):
        self._oprot.writeMessageBegin('shutdown_cluster', TMessageType.CALL, self._seqid)
        args = shutdown_cluster_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shutdown_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shutdown_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_cluster_time(self):
        """
        获取集群时间
        @return i64 当前集群系统时间UNIX时间戳

        """
        self.send_get_cluster_time()
        return self.recv_get_cluster_time()

    def send_get_cluster_time(self):
        self._oprot.writeMessageBegin('get_cluster_time', TMessageType.CALL, self._seqid)
        args = get_cluster_time_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cluster_time failed: unknown result")

    def set_cluster_time(self, datetime):
        """
        设置集群时间
        时间格式："yyyy-mm-dd hh:mm:ss"
        @param string datetime 待设置时间

        Parameters:
         - datetime

        """
        self.send_set_cluster_time(datetime)
        self.recv_set_cluster_time()

    def send_set_cluster_time(self, datetime):
        self._oprot.writeMessageBegin('set_cluster_time', TMessageType.CALL, self._seqid)
        args = set_cluster_time_args()
        args.datetime = datetime
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_cluster_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_cluster_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_cluster_version(self):
        """
        获取集群版本
        @return string 当前集群使用的 AnyShare Server 包版本号
        如安装的 Server 包名为AnyShare-Server-6.0.1-20170511-81,则返回值为 "6.0.1-20170511-81"

        """
        self.send_get_cluster_version()
        return self.recv_get_cluster_version()

    def send_get_cluster_version(self):
        self._oprot.writeMessageBegin('get_cluster_version', TMessageType.CALL, self._seqid)
        args = get_cluster_version_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cluster_version failed: unknown result")

    def get_cluster_uuid(self):
        """
        获取集群 uuid
        @return string 集群 uuid, 集群唯一标识

        """
        self.send_get_cluster_uuid()
        return self.recv_get_cluster_uuid()

    def send_get_cluster_uuid(self):
        self._oprot.writeMessageBegin('get_cluster_uuid', TMessageType.CALL, self._seqid)
        args = get_cluster_uuid_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_uuid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_uuid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cluster_uuid failed: unknown result")

    def add_log_server(self, facility, severity, ip, port, protocol):
        """
        添加一台远程日志服务器,若推送功能开启则立即生效
        @param str facility: 接收规则模块
                   参数: kern, user, mail, daemon, auth, syslog, lpr, news, uucp, authpriv,
                         ftp, cron, local0, local1, local2, local3, local4, local5, local6, local7
        @param str severity: 接收规则等级
                   参数: emerg, alert, crit, err, warn, notice, info, debug
        @param string ip: 远程服务器ip地址
        @param int port: 远程服务器端口
        @param string protocol：传输协议TCP/UDP

        Parameters:
         - facility
         - severity
         - ip
         - port
         - protocol

        """
        self.send_add_log_server(facility, severity, ip, port, protocol)
        self.recv_add_log_server()

    def send_add_log_server(self, facility, severity, ip, port, protocol):
        self._oprot.writeMessageBegin('add_log_server', TMessageType.CALL, self._seqid)
        args = add_log_server_args()
        args.facility = facility
        args.severity = severity
        args.ip = ip
        args.port = port
        args.protocol = protocol
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_log_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_log_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def delete_log_server(self, facility, severity, ip, port, protocol):
        """
        删除一台日志服务器,若推送功能开启则立即生效
        @param str facility: 接收规则模块
        @param str severity: 接收规则等级
        @param string ip: 远程服务器ip地址
        @param int port: 远程服务器端口
        @param string protocol：传输协议TCP/UDP

        Parameters:
         - facility
         - severity
         - ip
         - port
         - protocol

        """
        self.send_delete_log_server(facility, severity, ip, port, protocol)
        self.recv_delete_log_server()

    def send_delete_log_server(self, facility, severity, ip, port, protocol):
        self._oprot.writeMessageBegin('delete_log_server', TMessageType.CALL, self._seqid)
        args = delete_log_server_args()
        args.facility = facility
        args.severity = severity
        args.ip = ip
        args.port = port
        args.protocol = protocol
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_log_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_log_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def enable_upload_log(self, datetime):
        """
        开启日志推送到日志服务器功能
        @param str datetime 用户日志推送起始时间
         e.g: 2016-06-20 09:00:00

        Parameters:
         - datetime

        """
        self.send_enable_upload_log(datetime)
        self.recv_enable_upload_log()

    def send_enable_upload_log(self, datetime):
        self._oprot.writeMessageBegin('enable_upload_log', TMessageType.CALL, self._seqid)
        args = enable_upload_log_args()
        args.datetime = datetime
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_upload_log(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_upload_log_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_upload_log(self):
        """
        关闭日志推送到日志服务器功能

        """
        self.send_disable_upload_log()
        self.recv_disable_upload_log()

    def send_disable_upload_log(self):
        self._oprot.writeMessageBegin('disable_upload_log', TMessageType.CALL, self._seqid)
        args = disable_upload_log_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_upload_log(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_upload_log_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_upload_log_status(self):
        """
        获取日志推送到日志服务器功能状态
        return bool False 日志推送服务关闭
                    True  日志推送服务开启

        """
        self.send_get_upload_log_status()
        return self.recv_get_upload_log_status()

    def send_get_upload_log_status(self):
        self._oprot.writeMessageBegin('get_upload_log_status', TMessageType.CALL, self._seqid)
        args = get_upload_log_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_upload_log_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_upload_log_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_upload_log_status failed: unknown result")

    def get_upload_log_server(self):
        """
        获取数据库中日志服务器信息列表
        @return list<ECMSAgent.ncTLogHostInfo>

        """
        self.send_get_upload_log_server()
        return self.recv_get_upload_log_server()

    def send_get_upload_log_server(self):
        self._oprot.writeMessageBegin('get_upload_log_server', TMessageType.CALL, self._seqid)
        args = get_upload_log_server_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_upload_log_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_upload_log_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_upload_log_server failed: unknown result")

    def get_upload_log_time(self):
        """
        获取用户日志推送起始时间的UNIX时间戳
        @return int UNIX时间戳

        """
        self.send_get_upload_log_time()
        return self.recv_get_upload_log_time()

    def send_get_upload_log_time(self):
        self._oprot.writeMessageBegin('get_upload_log_time', TMessageType.CALL, self._seqid)
        args = get_upload_log_time_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_upload_log_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_upload_log_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_upload_log_time failed: unknown result")

    def get_all_nics_name(self, node_uuid):
        """
        获取指定节点的所有网卡名

        Parameters:
         - node_uuid

        """
        self.send_get_all_nics_name(node_uuid)
        return self.recv_get_all_nics_name()

    def send_get_all_nics_name(self, node_uuid):
        self._oprot.writeMessageBegin('get_all_nics_name', TMessageType.CALL, self._seqid)
        args = get_all_nics_name_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_nics_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_nics_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_nics_name failed: unknown result")

    def get_cpu_usage(self, node_uuid):
        """
        获取指定节点cpu使用率
        @param <string> node_uuid 节点uuid
        @return <double> cpu使用率

        Parameters:
         - node_uuid

        """
        self.send_get_cpu_usage(node_uuid)
        return self.recv_get_cpu_usage()

    def send_get_cpu_usage(self, node_uuid):
        self._oprot.writeMessageBegin('get_cpu_usage', TMessageType.CALL, self._seqid)
        args = get_cpu_usage_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cpu_usage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cpu_usage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cpu_usage failed: unknown result")

    def get_memory_info(self, node_uuid):
        """
        获取指定节点内存使用情况
        @param <string> node_uuid 节点uuid
        @return map<string, i64> {'usage': 已用内存B, 'total': 总共内存B}

        Parameters:
         - node_uuid

        """
        self.send_get_memory_info(node_uuid)
        return self.recv_get_memory_info()

    def send_get_memory_info(self, node_uuid):
        self._oprot.writeMessageBegin('get_memory_info', TMessageType.CALL, self._seqid)
        args = get_memory_info_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_memory_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_memory_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_memory_info failed: unknown result")

    def get_network_outgoing_rate(self, node_uuid):
        """
        获取网络发送速率
        @param <string> node_uuid 节点uuid
        @return <int> 网络发送速度 B/s

        Parameters:
         - node_uuid

        """
        self.send_get_network_outgoing_rate(node_uuid)
        return self.recv_get_network_outgoing_rate()

    def send_get_network_outgoing_rate(self, node_uuid):
        self._oprot.writeMessageBegin('get_network_outgoing_rate', TMessageType.CALL, self._seqid)
        args = get_network_outgoing_rate_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_network_outgoing_rate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_network_outgoing_rate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_network_outgoing_rate failed: unknown result")

    def get_network_incoming_rate(self, node_uuid):
        """
        获取网络接收速度
        @param <string> node_uuid 节点uuid
        @return <int> 网络接收速度 B/s

        Parameters:
         - node_uuid

        """
        self.send_get_network_incoming_rate(node_uuid)
        return self.recv_get_network_incoming_rate()

    def send_get_network_incoming_rate(self, node_uuid):
        self._oprot.writeMessageBegin('get_network_incoming_rate', TMessageType.CALL, self._seqid)
        args = get_network_incoming_rate_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_network_incoming_rate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_network_incoming_rate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_network_incoming_rate failed: unknown result")

    def troubleshoot(self):
        """
        对当前节点环境进行故障检测及处理
        故障如：服务停止

        """
        self.send_troubleshoot()
        self.recv_troubleshoot()

    def send_troubleshoot(self):
        self._oprot.writeMessageBegin('troubleshoot', TMessageType.CALL, self._seqid)
        args = troubleshoot_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_troubleshoot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = troubleshoot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def consistency_repair(self):
        """
        对当前节点环境进行一致性检测及处理

        """
        self.send_consistency_repair()
        self.recv_consistency_repair()

    def send_consistency_repair(self):
        self._oprot.writeMessageBegin('consistency_repair', TMessageType.CALL, self._seqid)
        args = consistency_repair_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_consistency_repair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = consistency_repair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def consistency_check(self):
        """
        对当前节点环境进行一致性检测
        若节点各子模块均与集群保持一致(不需要进行一致性恢复), 返回 True
        若节点各子模块中存在任一模块与集群状态不一致(则需要进行一致性恢复), 返回 False

        """
        self.send_consistency_check()
        return self.recv_consistency_check()

    def send_consistency_check(self):
        self._oprot.writeMessageBegin('consistency_check', TMessageType.CALL, self._seqid)
        args = consistency_check_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_consistency_check(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = consistency_check_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "consistency_check failed: unknown result")

    def on_node_heartbeat(self, node_uuid):
        """
        收到节点心跳的处理
        @param <string> node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_on_node_heartbeat(node_uuid)
        self.recv_on_node_heartbeat()

    def send_on_node_heartbeat(self, node_uuid):
        self._oprot.writeMessageBegin('on_node_heartbeat', TMessageType.CALL, self._seqid)
        args = on_node_heartbeat_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_on_node_heartbeat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = on_node_heartbeat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def on_change_node_ip(self, old_ip, new_ip, update_db_host):
        """
        手动修改节点 ip 后，调用该接口更新相关元数据等信息
        @param <string> old_ip 原 ip
        @param <string> new_ip 新 ip
        @param <bool>   update_db_host 如果待更新的节点原 ip 用于数据库连接，
                                       需要通过该接口更新各节点的 db_host
                                       信息，为 True；否则为 False
                                       调用时，需要能连通各节点的 agent

        Parameters:
         - old_ip
         - new_ip
         - update_db_host

        """
        self.send_on_change_node_ip(old_ip, new_ip, update_db_host)
        self.recv_on_change_node_ip()

    def send_on_change_node_ip(self, old_ip, new_ip, update_db_host):
        self._oprot.writeMessageBegin('on_change_node_ip', TMessageType.CALL, self._seqid)
        args = on_change_node_ip_args()
        args.old_ip = old_ip
        args.new_ip = new_ip
        args.update_db_host = update_db_host
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_on_change_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = on_change_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def enable_raid_manager(self):
        """
        启用 raid 管理模块, 默认不支持 raid 管理, 只有 eisoo 一体机设备并且指定型号 raid 卡才支持

        """
        self.send_enable_raid_manager()
        self.recv_enable_raid_manager()

    def send_enable_raid_manager(self):
        self._oprot.writeMessageBegin('enable_raid_manager', TMessageType.CALL, self._seqid)
        args = enable_raid_manager_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_raid_manager(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_raid_manager_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_raid_manager(self):
        """
        禁用 raid 管理模块

        """
        self.send_disable_raid_manager()
        self.recv_disable_raid_manager()

    def send_disable_raid_manager(self):
        self._oprot.writeMessageBegin('disable_raid_manager', TMessageType.CALL, self._seqid)
        args = disable_raid_manager_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_raid_manager(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_raid_manager_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_raid_manager_status(self):
        """
        获取raid管理模块启用状态

        """
        self.send_get_raid_manager_status()
        return self.recv_get_raid_manager_status()

    def send_get_raid_manager_status(self):
        self._oprot.writeMessageBegin('get_raid_manager_status', TMessageType.CALL, self._seqid)
        args = get_raid_manager_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_raid_manager_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_raid_manager_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_raid_manager_status failed: unknown result")

    def is_available_of_raid_manager(self, node_ip):
        """
        是否支持raid管理
        @param string node_ip 节点ip
        @return bool True:  支持raid管理
                     False: 不支持raid管理

        Parameters:
         - node_ip

        """
        self.send_is_available_of_raid_manager(node_ip)
        return self.recv_is_available_of_raid_manager()

    def send_is_available_of_raid_manager(self, node_ip):
        self._oprot.writeMessageBegin('is_available_of_raid_manager', TMessageType.CALL, self._seqid)
        args = is_available_of_raid_manager_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_available_of_raid_manager(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_available_of_raid_manager_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_available_of_raid_manager failed: unknown result")

    def exist_iscsi_device(self, node_ip):
        """
        判断节点是否存在外挂存储
        @param string node_ip          节点的node_ip

        Parameters:
         - node_ip

        """
        self.send_exist_iscsi_device(node_ip)
        return self.recv_exist_iscsi_device()

    def send_exist_iscsi_device(self, node_ip):
        self._oprot.writeMessageBegin('exist_iscsi_device', TMessageType.CALL, self._seqid)
        args = exist_iscsi_device_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exist_iscsi_device(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exist_iscsi_device_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exist_iscsi_device failed: unknown result")

    def get_free_data_disks(self, node_ip):
        """
        获取指定节点上的空闲数据盘
        空闲数据盘：指尚未加入存储池的数据盘

        @param string node_ip                    节点的 node_ip
        @return map<disk_dev_path, data_disk>    空闲数据盘列表

        Parameters:
         - node_ip

        """
        self.send_get_free_data_disks(node_ip)
        return self.recv_get_free_data_disks()

    def send_get_free_data_disks(self, node_ip):
        self._oprot.writeMessageBegin('get_free_data_disks', TMessageType.CALL, self._seqid)
        args = get_free_data_disks_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_free_data_disks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_free_data_disks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_free_data_disks failed: unknown result")

    def init_storage_pool(self, replicas):
        """
        初始化存储池

        @param int replicas 副本数

        Parameters:
         - replicas

        """
        self.send_init_storage_pool(replicas)
        self.recv_init_storage_pool()

    def send_init_storage_pool(self, replicas):
        self._oprot.writeMessageBegin('init_storage_pool', TMessageType.CALL, self._seqid)
        args = init_storage_pool_args()
        args.replicas = replicas
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_init_storage_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = init_storage_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def is_storage_pool_inited(self):
        """
        判断存储池是否已初始化

        """
        self.send_is_storage_pool_inited()
        return self.recv_is_storage_pool_inited()

    def send_is_storage_pool_inited(self):
        self._oprot.writeMessageBegin('is_storage_pool_inited', TMessageType.CALL, self._seqid)
        args = is_storage_pool_inited_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_storage_pool_inited(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_storage_pool_inited_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_storage_pool_inited failed: unknown result")

    def get_storage_pool(self, include_used_size):
        """
        获取存储池信息

        @param bool need_used_size       是否包含已用空间
             若为True，则需要从各个节点查询所有磁盘的可用空间情况，当节点数较多时，花费时间将较长

        Parameters:
         - include_used_size

        """
        self.send_get_storage_pool(include_used_size)
        return self.recv_get_storage_pool()

    def send_get_storage_pool(self, include_used_size):
        self._oprot.writeMessageBegin('get_storage_pool', TMessageType.CALL, self._seqid)
        args = get_storage_pool_args()
        args.include_used_size = include_used_size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_pool failed: unknown result")

    def get_storage_pool_devices(self, node_ip):
        """
        获取存储池中指定节点上的设备列表(包含设备对应的数据卷信息)

        @param string node_ip          节点的ip, 若为""，则获取全部节点
        @return map<ECMSAgent.ncTSwiftDevice.dev_id, ncTStoragePoolDevice>

        Parameters:
         - node_ip

        """
        self.send_get_storage_pool_devices(node_ip)
        return self.recv_get_storage_pool_devices()

    def send_get_storage_pool_devices(self, node_ip):
        self._oprot.writeMessageBegin('get_storage_pool_devices', TMessageType.CALL, self._seqid)
        args = get_storage_pool_devices_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_pool_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_pool_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_pool_devices failed: unknown result")

    def get_storage_pool_swift_devices(self):
        """
        获取存储池中swift设备列表(按节点分组，不包含设备对应的数据卷信息)

        @return map<node_ip, map<ECMSAgent.ncTSwiftDevice.dev_id, ncTStoragePoolDevice> >

        """
        self.send_get_storage_pool_swift_devices()
        return self.recv_get_storage_pool_swift_devices()

    def send_get_storage_pool_swift_devices(self):
        self._oprot.writeMessageBegin('get_storage_pool_swift_devices', TMessageType.CALL, self._seqid)
        args = get_storage_pool_swift_devices_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_pool_swift_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_pool_swift_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_pool_swift_devices failed: unknown result")

    def add_devices_to_pool(self, disk_dev_paths):
        """
        将指定节点上的指定空闲数据盘一次性加入到存储池中

        @param disks(map<node_ip, list<disk_dev_path>>)  空闲数据盘列表，由 get_free_data_disks 可知

        Parameters:
         - disk_dev_paths

        """
        self.send_add_devices_to_pool(disk_dev_paths)
        self.recv_add_devices_to_pool()

    def send_add_devices_to_pool(self, disk_dev_paths):
        self._oprot.writeMessageBegin('add_devices_to_pool', TMessageType.CALL, self._seqid)
        args = add_devices_to_pool_args()
        args.disk_dev_paths = disk_dev_paths
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_devices_to_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_devices_to_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def add_node_devices_to_pool(self, node_ip):
        """
        将指定某一节点的所有空闲数据盘一次性加入到存储池中

        @param string node_ip      节点 ip

        Parameters:
         - node_ip

        """
        self.send_add_node_devices_to_pool(node_ip)
        self.recv_add_node_devices_to_pool()

    def send_add_node_devices_to_pool(self, node_ip):
        self._oprot.writeMessageBegin('add_node_devices_to_pool', TMessageType.CALL, self._seqid)
        args = add_node_devices_to_pool_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_node_devices_to_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_node_devices_to_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_maintenance_of_devices(self, dev_uuids):
        """
        获取指定存储池设备的维护状态
        @param   list<string>    dev_uuids   指定存储池设备的 UUID 列表
        @return  list<bool>                  True: 处于维护状态
                                             False: 未处于维护状态

        Parameters:
         - dev_uuids

        """
        self.send_get_maintenance_of_devices(dev_uuids)
        return self.recv_get_maintenance_of_devices()

    def send_get_maintenance_of_devices(self, dev_uuids):
        self._oprot.writeMessageBegin('get_maintenance_of_devices', TMessageType.CALL, self._seqid)
        args = get_maintenance_of_devices_args()
        args.dev_uuids = dev_uuids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_maintenance_of_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_maintenance_of_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_maintenance_of_devices failed: unknown result")

    def enable_maintenance_of_devices(self, dev_uuids):
        """
        指定存储池设备进入维护状态
        @param   list<string>    dev_uuids   指定存储池设备的 UUID 列表
        @return  list<string>    dev_uuids   进入维护模式的 UUID 列表

        Parameters:
         - dev_uuids

        """
        self.send_enable_maintenance_of_devices(dev_uuids)
        return self.recv_enable_maintenance_of_devices()

    def send_enable_maintenance_of_devices(self, dev_uuids):
        self._oprot.writeMessageBegin('enable_maintenance_of_devices', TMessageType.CALL, self._seqid)
        args = enable_maintenance_of_devices_args()
        args.dev_uuids = dev_uuids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_maintenance_of_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_maintenance_of_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_maintenance_of_devices failed: unknown result")

    def disable_maintenance_of_devices(self, dev_uuids):
        """
        指定存储池设备退出维护状态
        @param   list<string>    dev_uuids   指定存储池设备的 UUID 列表
        @return  list<string>    dev_uuids   退出维护模式的 UUID 列表

        Parameters:
         - dev_uuids

        """
        self.send_disable_maintenance_of_devices(dev_uuids)
        return self.recv_disable_maintenance_of_devices()

    def send_disable_maintenance_of_devices(self, dev_uuids):
        self._oprot.writeMessageBegin('disable_maintenance_of_devices', TMessageType.CALL, self._seqid)
        args = disable_maintenance_of_devices_args()
        args.dev_uuids = dev_uuids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_maintenance_of_devices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_maintenance_of_devices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_maintenance_of_devices failed: unknown result")

    def get_free_data_disks_for_replace(self, dev_id):
        """
        获取可用于替换指定存储池设备的备选空闲数据盘列表
        规则：
          1.备选设备和要替换的设备处于同一服务器节点

        @param dev_id(int)     存储池中需要被替换的设备ID， ncTStoragePoolDevice.swift_device.dev_id
        @return map<disk_dev_path, data_disk>   备选空闲数据盘列表

        Parameters:
         - dev_id

        """
        self.send_get_free_data_disks_for_replace(dev_id)
        return self.recv_get_free_data_disks_for_replace()

    def send_get_free_data_disks_for_replace(self, dev_id):
        self._oprot.writeMessageBegin('get_free_data_disks_for_replace', TMessageType.CALL, self._seqid)
        args = get_free_data_disks_for_replace_args()
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_free_data_disks_for_replace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_free_data_disks_for_replace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_free_data_disks_for_replace failed: unknown result")

    def replace_device_in_pool(self, dev_id, disk_dev_path):
        """
        在存储池中使用指定数据盘替换指定存储池设备（仅限同一节点内的磁盘替换）
        单副本环境不支持此操作
        若替换磁盘的容量与原磁盘不一致，则此操作会引起存储池内的数据重新负载均衡及迁移
        此操作适用于某块故障卷可以被尽快更换的场景，或需要替换使用大容量磁盘达到扩容目的的场景

        @param dev_id(int)           存储池中需要被替换的设备ID， ncTStoragePoolDevice.swift_device.dev_id
        @param disk_dev_path(str)    用于替换的数据盘路径

        Parameters:
         - dev_id
         - disk_dev_path

        """
        self.send_replace_device_in_pool(dev_id, disk_dev_path)
        self.recv_replace_device_in_pool()

    def send_replace_device_in_pool(self, dev_id, disk_dev_path):
        self._oprot.writeMessageBegin('replace_device_in_pool', TMessageType.CALL, self._seqid)
        args = replace_device_in_pool_args()
        args.dev_id = dev_id
        args.disk_dev_path = disk_dev_path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_replace_device_in_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = replace_device_in_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def remove_device_from_pool(self, dev_id):
        """
        从存储池中移除单个设备
        此操作会引起存储池内的数据重新负载均衡及迁移
        此操作适用于某块存储卷已故障不可用，且长时间无法得到恢复或更换的场景
        单副本环境不支持此操作

        @param dev_id(int)   存储池中的设备ID， ncTStoragePoolDevice.swift_device.dev_id

        Parameters:
         - dev_id

        """
        self.send_remove_device_from_pool(dev_id)
        self.recv_remove_device_from_pool()

    def send_remove_device_from_pool(self, dev_id):
        self._oprot.writeMessageBegin('remove_device_from_pool', TMessageType.CALL, self._seqid)
        args = remove_device_from_pool_args()
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_device_from_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_device_from_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def remove_node_devices_from_pool(self, node_ip):
        """
        从存储池中移除指定节点的所有设备
        单副本环境不支持此操作

        @param string node_ip      节点 ip

        Parameters:
         - node_ip

        """
        self.send_remove_node_devices_from_pool(node_ip)
        self.recv_remove_node_devices_from_pool()

    def send_remove_node_devices_from_pool(self, node_ip):
        self._oprot.writeMessageBegin('remove_node_devices_from_pool', TMessageType.CALL, self._seqid)
        args = remove_node_devices_from_pool_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_node_devices_from_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_node_devices_from_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def rebalance_storage_pool(self):
        """
        将存储池重新负载均衡

        """
        self.send_rebalance_storage_pool()
        self.recv_rebalance_storage_pool()

    def send_rebalance_storage_pool(self):
        self._oprot.writeMessageBegin('rebalance_storage_pool', TMessageType.CALL, self._seqid)
        args = rebalance_storage_pool_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rebalance_storage_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rebalance_storage_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def change_replicas(self, replicas):
        """
        修改存储池副本数

        @param int replicas 副本数

        Parameters:
         - replicas

        """
        self.send_change_replicas(replicas)
        self.recv_change_replicas()

    def send_change_replicas(self, replicas):
        self._oprot.writeMessageBegin('change_replicas', TMessageType.CALL, self._seqid)
        args = change_replicas_args()
        args.replicas = replicas
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_change_replicas(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = change_replicas_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_replicas_health(self):
        """
        查询当前存储池的副本健康度.
        内部采用抽样的方法检测.
        @return health_percent   返回健康百分比之分子，等于 100 可视为健康，
                                 说明所有对象的副本都100%存在正确的位置上。

        """
        self.send_get_replicas_health()
        return self.recv_get_replicas_health()

    def send_get_replicas_health(self):
        self._oprot.writeMessageBegin('get_replicas_health', TMessageType.CALL, self._seqid)
        args = get_replicas_health_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_replicas_health(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_replicas_health_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_replicas_health failed: unknown result")

    def get_all_data_raid_pds(self, node_ip):
        """
        获取指定节点上的所有数据RAID物理磁盘列表

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        self.send_get_all_data_raid_pds(node_ip)
        return self.recv_get_all_data_raid_pds()

    def send_get_all_data_raid_pds(self, node_ip):
        self._oprot.writeMessageBegin('get_all_data_raid_pds', TMessageType.CALL, self._seqid)
        args = get_all_data_raid_pds_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_data_raid_pds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_data_raid_pds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_data_raid_pds failed: unknown result")

    def get_free_data_raid_pds(self, node_ip):
        """
        获取指定节点上的空闲数据RAID物理磁盘列表
        空闲数据RAID物理磁盘：指尚未加入存储池的数据RAID物理磁盘

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        self.send_get_free_data_raid_pds(node_ip)
        return self.recv_get_free_data_raid_pds()

    def send_get_free_data_raid_pds(self, node_ip):
        self._oprot.writeMessageBegin('get_free_data_raid_pds', TMessageType.CALL, self._seqid)
        args = get_free_data_raid_pds_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_free_data_raid_pds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_free_data_raid_pds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_free_data_raid_pds failed: unknown result")

    def get_raid_pds_in_storage_pool(self, node_ip):
        """
        获取指定节点上的已加入存储池的数据RAID物理磁盘列表

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        self.send_get_raid_pds_in_storage_pool(node_ip)
        return self.recv_get_raid_pds_in_storage_pool()

    def send_get_raid_pds_in_storage_pool(self, node_ip):
        self._oprot.writeMessageBegin('get_raid_pds_in_storage_pool', TMessageType.CALL, self._seqid)
        args = get_raid_pds_in_storage_pool_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_raid_pds_in_storage_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_raid_pds_in_storage_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_raid_pds_in_storage_pool failed: unknown result")

    def get_sys_raid_pds(self, node_ip):
        """
        获取指定节点上的系统RAID物理磁盘列表
        系统RAID物理磁盘：指用于系统盘或缓存盘的RAID物理磁盘或热备盘

        @param string node_ip                    节点 ip
        @return map<pd_devid, pdinfo>            RAID物理磁盘列表

        Parameters:
         - node_ip

        """
        self.send_get_sys_raid_pds(node_ip)
        return self.recv_get_sys_raid_pds()

    def send_get_sys_raid_pds(self, node_ip):
        self._oprot.writeMessageBegin('get_sys_raid_pds', TMessageType.CALL, self._seqid)
        args = get_sys_raid_pds_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sys_raid_pds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sys_raid_pds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sys_raid_pds failed: unknown result")

    def get_all_raid_lds(self, node_ip):
        """
        获取指定节点上的所有RAID逻辑磁盘列表

        @param string node_ip                    节点 ip
        @return map<ld_devid, ldinfo>            RAID逻辑磁盘列表

        Parameters:
         - node_ip

        """
        self.send_get_all_raid_lds(node_ip)
        return self.recv_get_all_raid_lds()

    def send_get_all_raid_lds(self, node_ip):
        self._oprot.writeMessageBegin('get_all_raid_lds', TMessageType.CALL, self._seqid)
        args = get_all_raid_lds_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_raid_lds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_raid_lds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_raid_lds failed: unknown result")

    def get_raid_pd_details(self, node_ip, pd_devid):
        """
        查询指定节点的指定 RAID 物理磁盘设备的详细信息

        @param string node_ip       节点 ip
        @param string pd_devid:     设备唯一标识
        @return map<key, value>:    RAID 物理磁盘设备的详细信息

        Parameters:
         - node_ip
         - pd_devid

        """
        self.send_get_raid_pd_details(node_ip, pd_devid)
        return self.recv_get_raid_pd_details()

    def send_get_raid_pd_details(self, node_ip, pd_devid):
        self._oprot.writeMessageBegin('get_raid_pd_details', TMessageType.CALL, self._seqid)
        args = get_raid_pd_details_args()
        args.node_ip = node_ip
        args.pd_devid = pd_devid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_raid_pd_details(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_raid_pd_details_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_raid_pd_details failed: unknown result")

    def get_raid_ld_details(self, node_ip, ld_devid):
        """
        查询指定节点的指定 RAID 逻辑磁盘设备的详细信息

        @param string node_ip       节点 ip
        @param string ld_devid:     设备唯一标识
        @return map<key, value>:    RAID 逻辑设备的详细信息

        Parameters:
         - node_ip
         - ld_devid

        """
        self.send_get_raid_ld_details(node_ip, ld_devid)
        return self.recv_get_raid_ld_details()

    def send_get_raid_ld_details(self, node_ip, ld_devid):
        self._oprot.writeMessageBegin('get_raid_ld_details', TMessageType.CALL, self._seqid)
        args = get_raid_ld_details_args()
        args.node_ip = node_ip
        args.ld_devid = ld_devid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_raid_ld_details(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_raid_ld_details_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_raid_ld_details failed: unknown result")

    def init_free_data_raid_pds(self, node_ip, pd_devids, bond_disks_num):
        """
        初始化指定节点上的指定空闲数据RAID物理磁盘
        空闲数据RAID物理磁盘：指尚未加入存储池的数据RAID物理磁盘

        @param string node_ip            节点 ip
        @param list<pd_devid> pd_devids  需要初始化的RAID物理磁盘设备列表
        @param int bond_disks_num        指定将几个磁盘绑定为一个数据盘
                                         == 1：表示使用一个磁盘，对应一个数据盘
                                         > 1：通常用于单副本，需要做RAID5的环境，将 n 个磁盘组合成一个数据盘
                                         PS：> 1 仅对RAID环境生效，裸磁盘均默认按 == 1 处理.
        @return map<ld_devid, ldinfo>    返回初始化创建的RAID逻辑卷列表

        Parameters:
         - node_ip
         - pd_devids
         - bond_disks_num

        """
        self.send_init_free_data_raid_pds(node_ip, pd_devids, bond_disks_num)
        return self.recv_init_free_data_raid_pds()

    def send_init_free_data_raid_pds(self, node_ip, pd_devids, bond_disks_num):
        self._oprot.writeMessageBegin('init_free_data_raid_pds', TMessageType.CALL, self._seqid)
        args = init_free_data_raid_pds_args()
        args.node_ip = node_ip
        args.pd_devids = pd_devids
        args.bond_disks_num = bond_disks_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_init_free_data_raid_pds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = init_free_data_raid_pds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "init_free_data_raid_pds failed: unknown result")

    def add_raid_hotspare(self, node_ip, pd_devid, ld_devid):
        """
        在指定节点上添加RAID热备盘

        @param string node_ip        节点 ip
        @param string pd_devid       热备盘ID，可从空闲数据RAID物理磁盘中选取
        @param string ld_devid       指定需要添加热备盘的RAID逻辑磁盘设备ID，若为空，则添加为全局热备盘

        Parameters:
         - node_ip
         - pd_devid
         - ld_devid

        """
        self.send_add_raid_hotspare(node_ip, pd_devid, ld_devid)
        self.recv_add_raid_hotspare()

    def send_add_raid_hotspare(self, node_ip, pd_devid, ld_devid):
        self._oprot.writeMessageBegin('add_raid_hotspare', TMessageType.CALL, self._seqid)
        args = add_raid_hotspare_args()
        args.node_ip = node_ip
        args.pd_devid = pd_devid
        args.ld_devid = ld_devid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_raid_hotspare(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_raid_hotspare_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def remove_raid_hotspare(self, node_ip, pd_devid):
        """
        在指定节点上删除热备盘

        @param string node_ip        节点 ip
        @param string pd_devid       热备盘ID

        Parameters:
         - node_ip
         - pd_devid

        """
        self.send_remove_raid_hotspare(node_ip, pd_devid)
        self.recv_remove_raid_hotspare()

    def send_remove_raid_hotspare(self, node_ip, pd_devid):
        self._oprot.writeMessageBegin('remove_raid_hotspare', TMessageType.CALL, self._seqid)
        args = remove_raid_hotspare_args()
        args.node_ip = node_ip
        args.pd_devid = pd_devid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_raid_hotspare(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_raid_hotspare_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_raid_lds_for_hotspare(self, node_ip):
        """
        获取指定节点上的可添加热备盘的RAID逻辑磁盘列表

        @param string node_ip                    节点 ip
        @return map<ld_devid, ldinfo>            RAID逻辑磁盘列表

        Parameters:
         - node_ip

        """
        self.send_get_raid_lds_for_hotspare(node_ip)
        return self.recv_get_raid_lds_for_hotspare()

    def send_get_raid_lds_for_hotspare(self, node_ip):
        self._oprot.writeMessageBegin('get_raid_lds_for_hotspare', TMessageType.CALL, self._seqid)
        args = get_raid_lds_for_hotspare_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_raid_lds_for_hotspare(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_raid_lds_for_hotspare_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_raid_lds_for_hotspare failed: unknown result")

    def create_cache_volume(self, node_uuid, disk_dev_path):
        """
        在指定数据盘上创建缓存卷

        @param disk_dev_path(str)    指定磁盘在系统中的设备路径
        @return vol_dev_path(str)    返回所创建的缓存卷设备路径

        Parameters:
         - node_uuid
         - disk_dev_path

        """
        self.send_create_cache_volume(node_uuid, disk_dev_path)
        return self.recv_create_cache_volume()

    def send_create_cache_volume(self, node_uuid, disk_dev_path):
        self._oprot.writeMessageBegin('create_cache_volume', TMessageType.CALL, self._seqid)
        args = create_cache_volume_args()
        args.node_uuid = node_uuid
        args.disk_dev_path = disk_dev_path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_cache_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_cache_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_cache_volume failed: unknown result")

    def remove_cache_volume(self, node_uuid):
        """
        删除缓存卷

        Parameters:
         - node_uuid

        """
        self.send_remove_cache_volume(node_uuid)
        self.recv_remove_cache_volume()

    def send_remove_cache_volume(self, node_uuid):
        self._oprot.writeMessageBegin('remove_cache_volume', TMessageType.CALL, self._seqid)
        args = remove_cache_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_cache_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_cache_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_cache_volume(self, node_uuid):
        """
        获取缓存卷信息
        return ECMSAgent.ncTVolume: 缓存卷信息

        Parameters:
         - node_uuid

        """
        self.send_get_cache_volume(node_uuid)
        return self.recv_get_cache_volume()

    def send_get_cache_volume(self, node_uuid):
        self._oprot.writeMessageBegin('get_cache_volume', TMessageType.CALL, self._seqid)
        args = get_cache_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cache_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cache_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cache_volume failed: unknown result")

    def init_cache_volume(self, node_uuid):
        """
        初始化缓存卷
        若缓存卷存在，则：清除缓存卷及缓存目录中的数据，并挂载
        若缓存卷不存在，则：清除缓存目录中的数据

        Parameters:
         - node_uuid

        """
        self.send_init_cache_volume(node_uuid)
        self.recv_init_cache_volume()

    def send_init_cache_volume(self, node_uuid):
        self._oprot.writeMessageBegin('init_cache_volume', TMessageType.CALL, self._seqid)
        args = init_cache_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_init_cache_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = init_cache_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def is_cache_volume_inited(self, node_uuid):
        """
        判断缓存卷是否已初始化
        若缓存卷存在，若缓存卷中无数据，且已挂载，则已初始化
        若缓存卷不存在，若缓存目录存在，且无数据，则未初始化

        Parameters:
         - node_uuid

        """
        self.send_is_cache_volume_inited(node_uuid)
        return self.recv_is_cache_volume_inited()

    def send_is_cache_volume_inited(self, node_uuid):
        self._oprot.writeMessageBegin('is_cache_volume_inited', TMessageType.CALL, self._seqid)
        args = is_cache_volume_inited_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_cache_volume_inited(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_cache_volume_inited_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_cache_volume_inited failed: unknown result")

    def mount_cache_volume(self, node_uuid):
        """
        挂载缓存卷
        若缓存卷不存在，则忽略
        若缓存卷挂载失败，则记日志

        Parameters:
         - node_uuid

        """
        self.send_mount_cache_volume(node_uuid)
        self.recv_mount_cache_volume()

    def send_mount_cache_volume(self, node_uuid):
        self._oprot.writeMessageBegin('mount_cache_volume', TMessageType.CALL, self._seqid)
        args = mount_cache_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mount_cache_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mount_cache_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def allocate_cache_volume(self, node_uuid):
        """
        为各应用分配缓存卷

        Parameters:
         - node_uuid

        """
        self.send_allocate_cache_volume(node_uuid)
        self.recv_allocate_cache_volume()

    def send_allocate_cache_volume(self, node_uuid):
        self._oprot.writeMessageBegin('allocate_cache_volume', TMessageType.CALL, self._seqid)
        args = allocate_cache_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_allocate_cache_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = allocate_cache_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_sys_volume(self, node_uuid):
        """
        @param <string> node_uuid 节点uuid
        @return ECMSAgent.ncTVolume 系统卷相关信息
        获取指定节点系统卷信息

        Parameters:
         - node_uuid

        """
        self.send_get_sys_volume(node_uuid)
        return self.recv_get_sys_volume()

    def send_get_sys_volume(self, node_uuid):
        self._oprot.writeMessageBegin('get_sys_volume', TMessageType.CALL, self._seqid)
        args = get_sys_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sys_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sys_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sys_volume failed: unknown result")

    def get_sysvol_volume(self, node_uuid):
        """
        @param <string> node_uuid 节点uuid
        @return ECMSAgent.ncTVolume sysvol卷相关信息
        获取指定节点系统卷信息

        Parameters:
         - node_uuid

        """
        self.send_get_sysvol_volume(node_uuid)
        return self.recv_get_sysvol_volume()

    def send_get_sysvol_volume(self, node_uuid):
        self._oprot.writeMessageBegin('get_sysvol_volume', TMessageType.CALL, self._seqid)
        args = get_sysvol_volume_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sysvol_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sysvol_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sysvol_volume failed: unknown result")

    def get_disk_info(self, node_uuid, dev_path):
        """
        获取指定节点上指定磁盘的信息
        @param <string> node_uuid 节点uuid
        @param map<string, string> 指定磁盘相关信息

        Parameters:
         - node_uuid
         - dev_path

        """
        self.send_get_disk_info(node_uuid, dev_path)
        return self.recv_get_disk_info()

    def send_get_disk_info(self, node_uuid, dev_path):
        self._oprot.writeMessageBegin('get_disk_info', TMessageType.CALL, self._seqid)
        args = get_disk_info_args()
        args.node_uuid = node_uuid
        args.dev_path = dev_path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_disk_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_disk_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_disk_info failed: unknown result")

    def get_data_disks(self, node_uuid):
        """
        获取指定节点上所有数据盘
        @param string node_uuid 节点uuid
        @return data_disks(map<disk_dev_path, ncTDataDisk>)        返回数据盘列表

        Parameters:
         - node_uuid

        """
        self.send_get_data_disks(node_uuid)
        return self.recv_get_data_disks()

    def send_get_data_disks(self, node_uuid):
        self._oprot.writeMessageBegin('get_data_disks', TMessageType.CALL, self._seqid)
        args = get_data_disks_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_data_disks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_data_disks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_disks failed: unknown result")

    def get_storage_console_address(self, storage_server_name):
        """
        获取存储（本地Ceph）控制台登录地址
        @param string       storage_server_name Ceph 对象存储访问地址
        @return string      Ceph 控制台登录地址

        Parameters:
         - storage_server_name

        """
        self.send_get_storage_console_address(storage_server_name)
        return self.recv_get_storage_console_address()

    def send_get_storage_console_address(self, storage_server_name):
        self._oprot.writeMessageBegin('get_storage_console_address', TMessageType.CALL, self._seqid)
        args = get_storage_console_address_args()
        args.storage_server_name = storage_server_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_console_address(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_console_address_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_console_address failed: unknown result")

    def get_local_ceph_storage_info(self, storage_server_name):
        """
        获取本地Ceph存储的容量信息
        @param string       storage_server_name Ceph 对象存储访问地址
        @return ncTCephStorageInfo

        Parameters:
         - storage_server_name

        """
        self.send_get_local_ceph_storage_info(storage_server_name)
        return self.recv_get_local_ceph_storage_info()

    def send_get_local_ceph_storage_info(self, storage_server_name):
        self._oprot.writeMessageBegin('get_local_ceph_storage_info', TMessageType.CALL, self._seqid)
        args = get_local_ceph_storage_info_args()
        args.storage_server_name = storage_server_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_local_ceph_storage_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_local_ceph_storage_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_local_ceph_storage_info failed: unknown result")

    def set_local_ceph_manage_vip(self, ceph_manage_vip):
        """
        设置存储（本地Ceph）管理vip
        @param string       ceph_manage_vip Ceph 管理vip
                            参数可以是ip或者域名，接口内不做检查

        Parameters:
         - ceph_manage_vip

        """
        self.send_set_local_ceph_manage_vip(ceph_manage_vip)
        self.recv_set_local_ceph_manage_vip()

    def send_set_local_ceph_manage_vip(self, ceph_manage_vip):
        self._oprot.writeMessageBegin('set_local_ceph_manage_vip', TMessageType.CALL, self._seqid)
        args = set_local_ceph_manage_vip_args()
        args.ceph_manage_vip = ceph_manage_vip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_local_ceph_manage_vip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_local_ceph_manage_vip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_local_ceph_manage_vip(self):
        """
        获取存储（本地Ceph）管理vip
        @return string      ceph_manage_vip Ceph 管理vip

        """
        self.send_get_local_ceph_manage_vip()
        return self.recv_get_local_ceph_manage_vip()

    def send_get_local_ceph_manage_vip(self):
        self._oprot.writeMessageBegin('get_local_ceph_manage_vip', TMessageType.CALL, self._seqid)
        args = get_local_ceph_manage_vip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_local_ceph_manage_vip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_local_ceph_manage_vip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_local_ceph_manage_vip failed: unknown result")

    def get_zabbix_status(self):
        """
         * 获取监控服务状态
         * @return  bool    True:   启用
         *                  False:  禁用
        *

        """
        self.send_get_zabbix_status()
        return self.recv_get_zabbix_status()

    def send_get_zabbix_status(self):
        self._oprot.writeMessageBegin('get_zabbix_status', TMessageType.CALL, self._seqid)
        args = get_zabbix_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_zabbix_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_zabbix_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_zabbix_status failed: unknown result")

    def enable_zabbix(self):
        """
        启用 zabbix
        初始化数据库, 导入配置, 创建主机, 链接模板


        """
        self.send_enable_zabbix()
        self.recv_enable_zabbix()

    def send_enable_zabbix(self):
        self._oprot.writeMessageBegin('enable_zabbix', TMessageType.CALL, self._seqid)
        args = enable_zabbix_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_zabbix(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_zabbix_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_zabbix(self):
        """
        禁用 zabbix
        停止服务


        """
        self.send_disable_zabbix()
        self.recv_disable_zabbix()

    def send_disable_zabbix(self):
        self._oprot.writeMessageBegin('disable_zabbix', TMessageType.CALL, self._seqid)
        args = disable_zabbix_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_zabbix(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_zabbix_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_alert_trigger_status(self):
        """
        * 获取告警项状态
        * @return map<string, bool>
        *                                  string: 触发器分类
        *                                  i32:
                                               1:  触发器正常
                                               0:  触发器异常
                                               -1: 对应监控不存在

        """
        self.send_get_alert_trigger_status()
        return self.recv_get_alert_trigger_status()

    def send_get_alert_trigger_status(self):
        self._oprot.writeMessageBegin('get_alert_trigger_status', TMessageType.CALL, self._seqid)
        args = get_alert_trigger_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_alert_trigger_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_alert_trigger_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_alert_trigger_status failed: unknown result")

    def is_alert_enable(self):
        """
        获取告警通知开关状态
        @return  bool                    True: 开启, False: 关闭

        """
        self.send_is_alert_enable()
        return self.recv_is_alert_enable()

    def send_is_alert_enable(self):
        self._oprot.writeMessageBegin('is_alert_enable', TMessageType.CALL, self._seqid)
        args = is_alert_enable_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_alert_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_alert_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_alert_enable failed: unknown result")

    def enable_alert(self):
        """
        启用告警通知

        """
        self.send_enable_alert()
        self.recv_enable_alert()

    def send_enable_alert(self):
        self._oprot.writeMessageBegin('enable_alert', TMessageType.CALL, self._seqid)
        args = enable_alert_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_alert(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_alert_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_alert(self):
        """
        禁用告警通知

        """
        self.send_disable_alert()
        self.recv_disable_alert()

    def send_disable_alert(self):
        self._oprot.writeMessageBegin('disable_alert', TMessageType.CALL, self._seqid)
        args = disable_alert_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_alert(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_alert_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def enable_maintenance(self):
        """
        启用监控维护模式

        """
        self.send_enable_maintenance()
        self.recv_enable_maintenance()

    def send_enable_maintenance(self):
        self._oprot.writeMessageBegin('enable_maintenance', TMessageType.CALL, self._seqid)
        args = enable_maintenance_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_maintenance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_maintenance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_maintenance(self):
        """
        禁用监控维护模式

        """
        self.send_disable_maintenance()
        self.recv_disable_maintenance()

    def send_disable_maintenance(self):
        self._oprot.writeMessageBegin('disable_maintenance', TMessageType.CALL, self._seqid)
        args = disable_maintenance_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_maintenance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_maintenance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_maintenance_status(self):
        """
        获取监控维护模式状态
        @return bool False : 维护模式禁用
                     True  : 维护模式启用

        """
        self.send_get_maintenance_status()
        return self.recv_get_maintenance_status()

    def send_get_maintenance_status(self):
        self._oprot.writeMessageBegin('get_maintenance_status', TMessageType.CALL, self._seqid)
        args = get_maintenance_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_maintenance_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_maintenance_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_maintenance_status failed: unknown result")

    def get_service_problem_records(self, ipaddr, time_from, time_till):
        """
        获取系统服务异常记录
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_service_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_service_problem_records()

    def send_get_service_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_service_problem_records', TMessageType.CALL, self._seqid)
        args = get_service_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_service_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_service_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_service_problem_records failed: unknown result")

    def get_database_problem_records(self, ipaddr, time_from, time_till):
        """
        获取数据库异常记录
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_database_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_database_problem_records()

    def send_get_database_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_database_problem_records', TMessageType.CALL, self._seqid)
        args = get_database_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_database_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_database_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database_problem_records failed: unknown result")

    def get_cpu_problem_records(self, ipaddr, threshold, time_from, time_till):
        """
        获取 CPU 异常记录
        @param string ipaddr 节点的 IP 地址
        @param double threshold CPU 负载阈值, 高于阈值则认为异常
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - threshold
         - time_from
         - time_till

        """
        self.send_get_cpu_problem_records(ipaddr, threshold, time_from, time_till)
        return self.recv_get_cpu_problem_records()

    def send_get_cpu_problem_records(self, ipaddr, threshold, time_from, time_till):
        self._oprot.writeMessageBegin('get_cpu_problem_records', TMessageType.CALL, self._seqid)
        args = get_cpu_problem_records_args()
        args.ipaddr = ipaddr
        args.threshold = threshold
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cpu_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cpu_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cpu_problem_records failed: unknown result")

    def get_sysvol_problem_records(self, ipaddr, time_from, time_till):
        """
        获取系统卷异常记录
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_sysvol_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_sysvol_problem_records()

    def send_get_sysvol_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_sysvol_problem_records', TMessageType.CALL, self._seqid)
        args = get_sysvol_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sysvol_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sysvol_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sysvol_problem_records failed: unknown result")

    def get_memory_problem_records(self, ipaddr, threshold, time_from, time_till):
        """
        获取内存异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   double  threshold   内存负载阈值, 高于阈值则认为异常
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - threshold
         - time_from
         - time_till

        """
        self.send_get_memory_problem_records(ipaddr, threshold, time_from, time_till)
        return self.recv_get_memory_problem_records()

    def send_get_memory_problem_records(self, ipaddr, threshold, time_from, time_till):
        self._oprot.writeMessageBegin('get_memory_problem_records', TMessageType.CALL, self._seqid)
        args = get_memory_problem_records_args()
        args.ipaddr = ipaddr
        args.threshold = threshold
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_memory_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_memory_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_memory_problem_records failed: unknown result")

    def get_self_backup_problem_records(self, ipaddr, time_from, time_till):
        """
        获取系统自备份异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_self_backup_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_self_backup_problem_records()

    def send_get_self_backup_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_self_backup_problem_records', TMessageType.CALL, self._seqid)
        args = get_self_backup_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_self_backup_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_self_backup_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_self_backup_problem_records failed: unknown result")

    def get_node_online_problem_records(self, ipaddr, time_from, time_till):
        """
        获取节点在线状态异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_node_online_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_node_online_problem_records()

    def send_get_node_online_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_node_online_problem_records', TMessageType.CALL, self._seqid)
        args = get_node_online_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_node_online_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_node_online_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_online_problem_records failed: unknown result")

    def get_node_switch_problem_records(self, ipaddr, time_from, time_till):
        """
        获取节点切换异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_node_switch_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_node_switch_problem_records()

    def send_get_node_switch_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_node_switch_problem_records', TMessageType.CALL, self._seqid)
        args = get_node_switch_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_node_switch_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_node_switch_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_switch_problem_records failed: unknown result")

    def get_replicas_problem_records(self, ipaddr, time_from, time_till):
        """
        获取对象存储副本健康度异常记录
        副本健康度非 100.0% 为异常
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_replicas_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_replicas_problem_records()

    def send_get_replicas_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_replicas_problem_records', TMessageType.CALL, self._seqid)
        args = get_replicas_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_replicas_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_replicas_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_replicas_problem_records failed: unknown result")

    def get_storage_dev_problem_records(self, ipaddr, time_from, time_till):
        """
        获取存储池设备异常记录
        @param   string  ipaddr      节点的 IP 地址
        @param   i32     time_from   返回指定时间之后的记录
        @param   i32     time_till   返回指定时间之前的记录
        @return  list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_storage_dev_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_storage_dev_problem_records()

    def send_get_storage_dev_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_storage_dev_problem_records', TMessageType.CALL, self._seqid)
        args = get_storage_dev_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_dev_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_dev_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_dev_problem_records failed: unknown result")

    def get_balance_problem_records(self, ipaddr, time_from, time_till):
        """
        获取对象存储负载均衡异常记录
        负载均衡小于 0 为异常
        @param string ipaddr 节点的 IP 地址
        @param i32 time_from 返回指定时间之后的记录
        @param i32 time_till 返回指定时间之前的记录
        @return list<ncTMonitorProblemRecord>

        Parameters:
         - ipaddr
         - time_from
         - time_till

        """
        self.send_get_balance_problem_records(ipaddr, time_from, time_till)
        return self.recv_get_balance_problem_records()

    def send_get_balance_problem_records(self, ipaddr, time_from, time_till):
        self._oprot.writeMessageBegin('get_balance_problem_records', TMessageType.CALL, self._seqid)
        args = get_balance_problem_records_args()
        args.ipaddr = ipaddr
        args.time_from = time_from
        args.time_till = time_till
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_balance_problem_records(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_balance_problem_records_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_balance_problem_records failed: unknown result")

    def add_storage_node(self, node_uuid):
        """
        添加存储节点
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_add_storage_node(node_uuid)
        self.recv_add_storage_node()

    def send_add_storage_node(self, node_uuid):
        self._oprot.writeMessageBegin('add_storage_node', TMessageType.CALL, self._seqid)
        args = add_storage_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_storage_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_storage_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def del_storage_node(self, node_uuid):
        """
        移除存储节点
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_del_storage_node(node_uuid)
        self.recv_del_storage_node()

    def send_del_storage_node(self, node_uuid):
        self._oprot.writeMessageBegin('del_storage_node', TMessageType.CALL, self._seqid)
        args = del_storage_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_storage_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_storage_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_storage_node_info(self):
        """
        获取存储节点信息

        """
        self.send_get_storage_node_info()
        return self.recv_get_storage_node_info()

    def send_get_storage_node_info(self):
        self._oprot.writeMessageBegin('get_storage_node_info', TMessageType.CALL, self._seqid)
        args = get_storage_node_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_node_info failed: unknown result")

    def get_storage_master_node_ip(self):
        """
        获取存储子系统主节点 ip
        存储主节点，只是按照一定规则获取的一个在线的存储节点
        注意：接口不拋错, 若没有查找到可用节点ip,返回为空字符串""
        @return  <string> ip

        """
        self.send_get_storage_master_node_ip()
        return self.recv_get_storage_master_node_ip()

    def send_get_storage_master_node_ip(self):
        self._oprot.writeMessageBegin('get_storage_master_node_ip', TMessageType.CALL, self._seqid)
        args = get_storage_master_node_ip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_master_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_master_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_master_node_ip failed: unknown result")

    def enable_storage_lvs(self, node_uuid):
        """
        启用指定节点的存储lvs
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_enable_storage_lvs(node_uuid)
        self.recv_enable_storage_lvs()

    def send_enable_storage_lvs(self, node_uuid):
        self._oprot.writeMessageBegin('enable_storage_lvs', TMessageType.CALL, self._seqid)
        args = enable_storage_lvs_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_storage_lvs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_storage_lvs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_storage_lvs(self, node_uuid):
        """
        禁用指定节点的存储lvs
        @param string node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_disable_storage_lvs(node_uuid)
        self.recv_disable_storage_lvs()

    def send_disable_storage_lvs(self, node_uuid):
        self._oprot.writeMessageBegin('disable_storage_lvs', TMessageType.CALL, self._seqid)
        args = disable_storage_lvs_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_storage_lvs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_storage_lvs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def add_application_node(self, node_uuid):
        """
        添加应用节点
        @param node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_add_application_node(node_uuid)
        self.recv_add_application_node()

    def send_add_application_node(self, node_uuid):
        self._oprot.writeMessageBegin('add_application_node', TMessageType.CALL, self._seqid)
        args = add_application_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_application_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_application_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def del_application_node(self, node_uuid):
        """
        移除应用节点
        @param node_uuid 节点uuid

        Parameters:
         - node_uuid

        """
        self.send_del_application_node(node_uuid)
        self.recv_del_application_node()

    def send_del_application_node(self, node_uuid):
        self._oprot.writeMessageBegin('del_application_node', TMessageType.CALL, self._seqid)
        args = del_application_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_application_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_application_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_app_node_info(self):
        """
        获取应用节点信息

        """
        self.send_get_app_node_info()
        return self.recv_get_app_node_info()

    def send_get_app_node_info(self):
        self._oprot.writeMessageBegin('get_app_node_info', TMessageType.CALL, self._seqid)
        args = get_app_node_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_app_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_app_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_app_node_info failed: unknown result")

    def get_app_master_node_info(self):
        """
        获取应用子系统主节点
        @return  ncTAppNodeInfo  应用节点信息

        """
        self.send_get_app_master_node_info()
        return self.recv_get_app_master_node_info()

    def send_get_app_master_node_info(self):
        self._oprot.writeMessageBegin('get_app_master_node_info', TMessageType.CALL, self._seqid)
        args = get_app_master_node_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_app_master_node_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_app_master_node_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_app_master_node_info failed: unknown result")

    def get_app_master_node_ip(self):
        """
        获取应用子系统主节点 ip
        注意：接口不拋错, 若没有查找到可用节点ip,返回为空字符串""
        @return  <string> ip

        """
        self.send_get_app_master_node_ip()
        return self.recv_get_app_master_node_ip()

    def send_get_app_master_node_ip(self):
        self._oprot.writeMessageBegin('get_app_master_node_ip', TMessageType.CALL, self._seqid)
        args = get_app_master_node_ip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_app_master_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_app_master_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_app_master_node_ip failed: unknown result")

    def enable_app_lvs(self, node_uuid):
        """
        启用指定节点的应用lvs
        @param   string  node_uuid  节点uuid

        Parameters:
         - node_uuid

        """
        self.send_enable_app_lvs(node_uuid)
        self.recv_enable_app_lvs()

    def send_enable_app_lvs(self, node_uuid):
        self._oprot.writeMessageBegin('enable_app_lvs', TMessageType.CALL, self._seqid)
        args = enable_app_lvs_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_app_lvs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_app_lvs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def disable_app_lvs(self, node_uuid):
        """
        禁用指定节点的应用lvs
        @param   string  node_uuid   节点uuid

        Parameters:
         - node_uuid

        """
        self.send_disable_app_lvs(node_uuid)
        self.recv_disable_app_lvs()

    def send_disable_app_lvs(self, node_uuid):
        self._oprot.writeMessageBegin('disable_app_lvs', TMessageType.CALL, self._seqid)
        args = disable_app_lvs_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_app_lvs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_app_lvs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_application_service(self):
        """
        获取所有应用服务
        @return  list<ncTAppServiceInfo>

        """
        self.send_get_application_service()
        return self.recv_get_application_service()

    def send_get_application_service(self):
        self._oprot.writeMessageBegin('get_application_service', TMessageType.CALL, self._seqid)
        args = get_application_service_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_application_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_application_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_application_service failed: unknown result")

    def add_application_service(self, service_name, port, is_lvs):
        """
        添加应用服务
        @param string service_name 服务名
        @param i32    port         端口
        @param bool   is_lvs       是否进行端口转发

        Parameters:
         - service_name
         - port
         - is_lvs

        """
        self.send_add_application_service(service_name, port, is_lvs)
        self.recv_add_application_service()

    def send_add_application_service(self, service_name, port, is_lvs):
        self._oprot.writeMessageBegin('add_application_service', TMessageType.CALL, self._seqid)
        args = add_application_service_args()
        args.service_name = service_name
        args.port = port
        args.is_lvs = is_lvs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_application_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_application_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def del_application_service(self, service_name):
        """
        移除应用服务
        @param string service 服务名

        Parameters:
         - service_name

        """
        self.send_del_application_service(service_name)
        self.recv_del_application_service()

    def send_del_application_service(self, service_name):
        self._oprot.writeMessageBegin('del_application_service', TMessageType.CALL, self._seqid)
        args = del_application_service_args()
        args.service_name = service_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_application_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_application_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_service_status(self, node_uuid, service_name):
        """
        获取指定节点服务状态: systemctl status service_name
        @param <string> node_uuid 节点uuid
        @param <string> service_name 服务名

        Parameters:
         - node_uuid
         - service_name

        """
        self.send_get_service_status(node_uuid, service_name)
        return self.recv_get_service_status()

    def send_get_service_status(self, node_uuid, service_name):
        self._oprot.writeMessageBegin('get_service_status', TMessageType.CALL, self._seqid)
        args = get_service_status_args()
        args.node_uuid = node_uuid
        args.service_name = service_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_service_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_service_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_service_status failed: unknown result")

    def is_app_registered(self, app_name):
        """
        检查单点应用是否在集群中注册安装
        @param   string  app_name    单点应用名称
        @return  bool                True, 单点应用已在集群中安装
                                     False, 单点应用未在集群中安装

        Parameters:
         - app_name

        """
        self.send_is_app_registered(app_name)
        return self.recv_is_app_registered()

    def send_is_app_registered(self, app_name):
        self._oprot.writeMessageBegin('is_app_registered', TMessageType.CALL, self._seqid)
        args = is_app_registered_args()
        args.app_name = app_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_app_registered(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_app_registered_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_app_registered failed: unknown result")

    def add_single_application_node(self, node_uuid, app_name):
        """
        设置单点应用节点
        @param string node_uuid 节点uuid
        @param string app_name

        Parameters:
         - node_uuid
         - app_name

        """
        self.send_add_single_application_node(node_uuid, app_name)
        self.recv_add_single_application_node()

    def send_add_single_application_node(self, node_uuid, app_name):
        self._oprot.writeMessageBegin('add_single_application_node', TMessageType.CALL, self._seqid)
        args = add_single_application_node_args()
        args.node_uuid = node_uuid
        args.app_name = app_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_single_application_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_single_application_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def del_single_application_node(self, app_name):
        """
        取消单点应用节点
        @param string app_name

        Parameters:
         - app_name

        """
        self.send_del_single_application_node(app_name)
        self.recv_del_single_application_node()

    def send_del_single_application_node(self, app_name):
        self._oprot.writeMessageBegin('del_single_application_node', TMessageType.CALL, self._seqid)
        args = del_single_application_node_args()
        args.app_name = app_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_single_application_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_single_application_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_single_application_service_by_node(self, node_uuid):
        """
        根据节点获取单点应用服务
        @param   string  node_uuid    节点 UUID
        @return  list<ncTAPPServiceInfo>

        Parameters:
         - node_uuid

        """
        self.send_get_single_application_service_by_node(node_uuid)
        return self.recv_get_single_application_service_by_node()

    def send_get_single_application_service_by_node(self, node_uuid):
        self._oprot.writeMessageBegin('get_single_application_service_by_node', TMessageType.CALL, self._seqid)
        args = get_single_application_service_by_node_args()
        args.node_uuid = node_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_single_application_service_by_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_single_application_service_by_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_single_application_service_by_node failed: unknown result")

    def get_node_uuid_by_app_name(self, app_name):
        """
        根据应用获取单点应用节点UUID
        @param   string  app_name    应用名
        @return  string              节点 UUID

        Parameters:
         - app_name

        """
        self.send_get_node_uuid_by_app_name(app_name)
        return self.recv_get_node_uuid_by_app_name()

    def send_get_node_uuid_by_app_name(self, app_name):
        self._oprot.writeMessageBegin('get_node_uuid_by_app_name', TMessageType.CALL, self._seqid)
        args = get_node_uuid_by_app_name_args()
        args.app_name = app_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_node_uuid_by_app_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_node_uuid_by_app_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ex is not None:
            raise result.ex
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_uuid_by_app_name failed: unknown result")

    def get_app_host_ip(self, app_name):
        """
        获取安装单点应用的节点 IP
        @param   string  app_name    单点应用名称
        @return  string              节点IP

        Parameters:
         - app_name

        """
        self.send_get_app_host_ip(app_name)
        return self.recv_get_app_host_ip()

    def send_get_app_host_ip(self, app_name):
        self._oprot.writeMessageBegin('get_app_host_ip', TMessageType.CALL, self._seqid)
        args = get_app_host_ip_args()
        args.app_name = app_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_app_host_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_app_host_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_app_host_ip failed: unknown result")

    def verify_sign_in(self, user, password):
        """
        验证登录信息
        @param <string> user 用户名
        @param <string> password 密码
        @return 验证结果  uuid 验证通过
                          ncTSignRet.USER_ERR 用户名错误
                          ncTSignRet.PWD_ERR 密码验证失败

        Parameters:
         - user
         - password

        """
        self.send_verify_sign_in(user, password)
        return self.recv_verify_sign_in()

    def send_verify_sign_in(self, user, password):
        self._oprot.writeMessageBegin('verify_sign_in', TMessageType.CALL, self._seqid)
        args = verify_sign_in_args()
        args.user = user
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verify_sign_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verify_sign_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verify_sign_in failed: unknown result")

    def app_sys_status(self):
        """
        应用子系统是否可用,如果可用登陆验证使用应用子系统的验证接口
        如果不可用,则使用集群验证接口
        @return True: 应用子系统可用
                False: 没有应用子系统,或应用子系统不可用

        """
        self.send_app_sys_status()
        return self.recv_app_sys_status()

    def send_app_sys_status(self):
        self._oprot.writeMessageBegin('app_sys_status', TMessageType.CALL, self._seqid)
        args = app_sys_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_app_sys_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = app_sys_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "app_sys_status failed: unknown result")

    def update_password(self, uuid, password):
        """
        修改密码
        @param uuid 管理员用户uuid, 同ShareMgnt.NCT_USER_ADMIN
        @param password 密码

        Parameters:
         - uuid
         - password

        """
        self.send_update_password(uuid, password)
        self.recv_update_password()

    def send_update_password(self, uuid, password):
        self._oprot.writeMessageBegin('update_password', TMessageType.CALL, self._seqid)
        args = update_password_args()
        args.uuid = uuid
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_password(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_password_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def update_user_name(self, uuid, user_name):
        """
        修改用户名
        @param uuid 管理员用户uuid, 同ShareMgnt.NCT_USER_ADMIN
        @param user_name 用户名

        Parameters:
         - uuid
         - user_name

        """
        self.send_update_user_name(uuid, user_name)
        self.recv_update_user_name()

    def send_update_user_name(self, uuid, user_name):
        self._oprot.writeMessageBegin('update_user_name', TMessageType.CALL, self._seqid)
        args = update_user_name_args()
        args.uuid = uuid
        args.user_name = user_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_user_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_user_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def commit_conf_file(self, conf_file_path, source_file_path):
        """
        提交配置文件，给集群进行自动一致性管理
        注意：提交后，所有节点将在检测周期内生效，不是立即生效。
        @param string conf_file_path: 需在各节点保持一致的配置文件路径，
                                      注意:需在AnyShareConfig/distributed_conf_files.conf中登记使配置
                                      生效的回调命令，若未登记则不允许提交。
        @param string source_file_path: 配置内容的来源文件路径，
                                        注意：若已在集群中提交过的配置文件，需再次提交时，最好不要在
                                        conf_file_path上直接进行修改然后作为来源文件提交，因为有可能
                                        会被集群自动还原。

        Parameters:
         - conf_file_path
         - source_file_path

        """
        self.send_commit_conf_file(conf_file_path, source_file_path)
        self.recv_commit_conf_file()

    def send_commit_conf_file(self, conf_file_path, source_file_path):
        self._oprot.writeMessageBegin('commit_conf_file', TMessageType.CALL, self._seqid)
        args = commit_conf_file_args()
        args.conf_file_path = conf_file_path
        args.source_file_path = source_file_path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_conf_file(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_conf_file_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def commit_conf_file_content(self, conf_file_path, file_content):
        """
        提交配置文件内容，给集群进行自动一致性管理
        注意：提交后，所有节点将在检测周期内生效，不是立即生效。
        @param string conf_file_path: 需在各节点保持一致的配置文件路径，
                                      注意:需在AnyShareConfig/distributed_conf_files.conf中登记使配置
                                      生效的回调命令，若未登记则不允许提交。
        @param string file_content: 配置内容的来源文件内容。

        Parameters:
         - conf_file_path
         - file_content

        """
        self.send_commit_conf_file_content(conf_file_path, file_content)
        self.recv_commit_conf_file_content()

    def send_commit_conf_file_content(self, conf_file_path, file_content):
        self._oprot.writeMessageBegin('commit_conf_file_content', TMessageType.CALL, self._seqid)
        args = commit_conf_file_content_args()
        args.conf_file_path = conf_file_path
        args.file_content = file_content
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_conf_file_content(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_conf_file_content_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def delete_conf_file(self, conf_file_path):
        """
        从集群中移除对指定配置文件的自动一致性管理
        若已移除，则忽略
        @param string conf_file_path: 配置文件路径

        Parameters:
         - conf_file_path

        """
        self.send_delete_conf_file(conf_file_path)
        self.recv_delete_conf_file()

    def send_delete_conf_file(self, conf_file_path):
        self._oprot.writeMessageBegin('delete_conf_file', TMessageType.CALL, self._seqid)
        args = delete_conf_file_args()
        args.conf_file_path = conf_file_path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_conf_file(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_conf_file_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_commited_conf_files(self):
        """
        获取已经提交到集群的分布式配置文件列表
        @return map<string, ncTConfFileInfo>

        """
        self.send_get_commited_conf_files()
        return self.recv_get_commited_conf_files()

    def send_get_commited_conf_files(self):
        self._oprot.writeMessageBegin('get_commited_conf_files', TMessageType.CALL, self._seqid)
        args = get_commited_conf_files_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_commited_conf_files(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_commited_conf_files_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_commited_conf_files failed: unknown result")

    def set_dns_server(self, nameservers):
        """
        添加 DNS 服务器
        @param nameservers: DNS 服务器地址列表，可以包含 0-3 个元素

        Parameters:
         - nameservers

        """
        self.send_set_dns_server(nameservers)
        self.recv_set_dns_server()

    def send_set_dns_server(self, nameservers):
        self._oprot.writeMessageBegin('set_dns_server', TMessageType.CALL, self._seqid)
        args = set_dns_server_args()
        args.nameservers = nameservers
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_dns_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_dns_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_dns_server(self):
        """
        获取 DNS 服务器信息
        @return DNS 服务器地址列表

        """
        self.send_get_dns_server()
        return self.recv_get_dns_server()

    def send_get_dns_server(self):
        self._oprot.writeMessageBegin('get_dns_server', TMessageType.CALL, self._seqid)
        args = get_dns_server_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dns_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dns_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dns_server failed: unknown result")

    def get_chrony_status(self):
        """
        获取时间同步服务状态
        @return  bool    True:   启用
                         False:  禁用

        """
        self.send_get_chrony_status()
        return self.recv_get_chrony_status()

    def send_get_chrony_status(self):
        self._oprot.writeMessageBegin('get_chrony_status', TMessageType.CALL, self._seqid)
        args = get_chrony_status_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_chrony_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_chrony_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_chrony_status failed: unknown result")

    def disable_chrony(self):
        """
        禁用时间同步服务


        """
        self.send_disable_chrony()
        self.recv_disable_chrony()

    def send_disable_chrony(self):
        self._oprot.writeMessageBegin('disable_chrony', TMessageType.CALL, self._seqid)
        args = disable_chrony_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_chrony(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_chrony_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def enable_chrony(self):
        """
        启用时间同步服务
        配置已添加的外部时间服务器

        """
        self.send_enable_chrony()
        self.recv_enable_chrony()

    def send_enable_chrony(self):
        self._oprot.writeMessageBegin('enable_chrony', TMessageType.CALL, self._seqid)
        args = enable_chrony_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_chrony(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_chrony_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def add_time_server(self, server):
        """
        添加外部时间服务器, 可以是IP或域名, 若是域名则需要配置 dns
        限制，集群中存在离线节点时，不能添加外部时间服务器
        @param string ntp_server: 外部时间服务器

        Parameters:
         - server

        """
        self.send_add_time_server(server)
        self.recv_add_time_server()

    def send_add_time_server(self, server):
        self._oprot.writeMessageBegin('add_time_server', TMessageType.CALL, self._seqid)
        args = add_time_server_args()
        args.server = server
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_time_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_time_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def del_time_server(self, server):
        """
        删除指定外部时间服务器，不存在指定时间服务器仍可正常执行
        @param string ntp_server: 外部时间服务器

        Parameters:
         - server

        """
        self.send_del_time_server(server)
        self.recv_del_time_server()

    def send_del_time_server(self, server):
        self._oprot.writeMessageBegin('del_time_server', TMessageType.CALL, self._seqid)
        args = del_time_server_args()
        args.server = server
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_time_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_time_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_time_server(self):
        """
        获取当前集群中所有配置的外部时间服务器,不包含本地源 "127.127.1.0"

        """
        self.send_get_time_server()
        return self.recv_get_time_server()

    def send_get_time_server(self):
        self._oprot.writeMessageBegin('get_time_server', TMessageType.CALL, self._seqid)
        args = get_time_server_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_time_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_time_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_time_server failed: unknown result")

    def install_service(self, server_name):
        """
        安装服务
        @param server_name 需要安装的服务名

        Parameters:
         - server_name

        """
        self.send_install_service(server_name)
        self.recv_install_service()

    def send_install_service(self, server_name):
        self._oprot.writeMessageBegin('install_service', TMessageType.CALL, self._seqid)
        args = install_service_args()
        args.server_name = server_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_install_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = install_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def uninstall_service(self, server_name):
        """
        卸载服务

        Parameters:
         - server_name

        """
        self.send_uninstall_service(server_name)
        self.recv_uninstall_service()

    def send_uninstall_service(self, server_name):
        self._oprot.writeMessageBegin('uninstall_service', TMessageType.CALL, self._seqid)
        args = uninstall_service_args()
        args.server_name = server_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_uninstall_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = uninstall_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_node_service(self):
        """
        获取各个节点已安装的服务

        """
        self.send_get_node_service()
        return self.recv_get_node_service()

    def send_get_node_service(self):
        self._oprot.writeMessageBegin('get_node_service', TMessageType.CALL, self._seqid)
        args = get_node_service_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_node_service(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_node_service_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_service failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["is_node_dirty"] = Processor.process_is_node_dirty
        self._processMap["is_env_dirty"] = Processor.process_is_env_dirty
        self._processMap["clear_node"] = Processor.process_clear_node
        self._processMap["active_cluster"] = Processor.process_active_cluster
        self._processMap["add_node"] = Processor.process_add_node
        self._processMap["del_node"] = Processor.process_del_node
        self._processMap["get_module_status"] = Processor.process_get_module_status
        self._processMap["enable_module"] = Processor.process_enable_module
        self._processMap["disable_module"] = Processor.process_disable_module
        self._processMap["create_ecms_db"] = Processor.process_create_ecms_db
        self._processMap["get_db_node_info"] = Processor.process_get_db_node_info
        self._processMap["set_db_master"] = Processor.process_set_db_master
        self._processMap["set_db_slave"] = Processor.process_set_db_slave
        self._processMap["set_db_slave_by_xtrabackup"] = Processor.process_set_db_slave_by_xtrabackup
        self._processMap["cancel_db_node"] = Processor.process_cancel_db_node
        self._processMap["update_deployment_mode"] = Processor.process_update_deployment_mode
        self._processMap["get_deployment_mode"] = Processor.process_get_deployment_mode
        self._processMap["dump_databases_to_path"] = Processor.process_dump_databases_to_path
        self._processMap["get_databases_name"] = Processor.process_get_databases_name
        self._processMap["purge_binlogs"] = Processor.process_purge_binlogs
        self._processMap["update_external_db_info"] = Processor.process_update_external_db_info
        self._processMap["get_external_db_info"] = Processor.process_get_external_db_info
        self._processMap["is_external_db"] = Processor.process_is_external_db
        self._processMap["is_available_external_db"] = Processor.process_is_available_external_db
        self._processMap["add_firewall_rule"] = Processor.process_add_firewall_rule
        self._processMap["del_firewall_rule"] = Processor.process_del_firewall_rule
        self._processMap["update_firewall_rule"] = Processor.process_update_firewall_rule
        self._processMap["get_firewall_rule"] = Processor.process_get_firewall_rule
        self._processMap["enable_firewall"] = Processor.process_enable_firewall
        self._processMap["disable_firewall"] = Processor.process_disable_firewall
        self._processMap["get_firewall_status"] = Processor.process_get_firewall_status
        self._processMap["enable_sys_service"] = Processor.process_enable_sys_service
        self._processMap["disable_sys_service"] = Processor.process_disable_sys_service
        self._processMap["get_sys_service_status"] = Processor.process_get_sys_service_status
        self._processMap["add_trusted_ip"] = Processor.process_add_trusted_ip
        self._processMap["set_storage_trusted_ip"] = Processor.process_set_storage_trusted_ip
        self._processMap["get_asu_node_ip"] = Processor.process_get_asu_node_ip
        self._processMap["get_keepalived_status"] = Processor.process_get_keepalived_status
        self._processMap["enable_keepalived"] = Processor.process_enable_keepalived
        self._processMap["disable_keepalived"] = Processor.process_disable_keepalived
        self._processMap["get_vip_info"] = Processor.process_get_vip_info
        self._processMap["set_vip_info"] = Processor.process_set_vip_info
        self._processMap["set_ivip_info"] = Processor.process_set_ivip_info
        self._processMap["get_ha_node_info"] = Processor.process_get_ha_node_info
        self._processMap["set_ha_master"] = Processor.process_set_ha_master
        self._processMap["set_ha_slave"] = Processor.process_set_ha_slave
        self._processMap["cancel_ha_node"] = Processor.process_cancel_ha_node
        self._processMap["set_db_ha_master"] = Processor.process_set_db_ha_master
        self._processMap["set_db_ha_slave"] = Processor.process_set_db_ha_slave
        self._processMap["cancel_db_ha_node"] = Processor.process_cancel_db_ha_node
        self._processMap["on_lvs_changed"] = Processor.process_on_lvs_changed
        self._processMap["on_node_entering_master"] = Processor.process_on_node_entering_master
        self._processMap["on_node_entering_slave"] = Processor.process_on_node_entering_slave
        self._processMap["force_enter_master"] = Processor.process_force_enter_master
        self._processMap["get_node_info"] = Processor.process_get_node_info
        self._processMap["get_all_node_info"] = Processor.process_get_all_node_info
        self._processMap["set_node_alias"] = Processor.process_set_node_alias
        self._processMap["restart_eisooapp"] = Processor.process_restart_eisooapp
        self._processMap["reboot_node"] = Processor.process_reboot_node
        self._processMap["shutdown_cluster"] = Processor.process_shutdown_cluster
        self._processMap["get_cluster_time"] = Processor.process_get_cluster_time
        self._processMap["set_cluster_time"] = Processor.process_set_cluster_time
        self._processMap["get_cluster_version"] = Processor.process_get_cluster_version
        self._processMap["get_cluster_uuid"] = Processor.process_get_cluster_uuid
        self._processMap["add_log_server"] = Processor.process_add_log_server
        self._processMap["delete_log_server"] = Processor.process_delete_log_server
        self._processMap["enable_upload_log"] = Processor.process_enable_upload_log
        self._processMap["disable_upload_log"] = Processor.process_disable_upload_log
        self._processMap["get_upload_log_status"] = Processor.process_get_upload_log_status
        self._processMap["get_upload_log_server"] = Processor.process_get_upload_log_server
        self._processMap["get_upload_log_time"] = Processor.process_get_upload_log_time
        self._processMap["get_all_nics_name"] = Processor.process_get_all_nics_name
        self._processMap["get_cpu_usage"] = Processor.process_get_cpu_usage
        self._processMap["get_memory_info"] = Processor.process_get_memory_info
        self._processMap["get_network_outgoing_rate"] = Processor.process_get_network_outgoing_rate
        self._processMap["get_network_incoming_rate"] = Processor.process_get_network_incoming_rate
        self._processMap["troubleshoot"] = Processor.process_troubleshoot
        self._processMap["consistency_repair"] = Processor.process_consistency_repair
        self._processMap["consistency_check"] = Processor.process_consistency_check
        self._processMap["on_node_heartbeat"] = Processor.process_on_node_heartbeat
        self._processMap["on_change_node_ip"] = Processor.process_on_change_node_ip
        self._processMap["enable_raid_manager"] = Processor.process_enable_raid_manager
        self._processMap["disable_raid_manager"] = Processor.process_disable_raid_manager
        self._processMap["get_raid_manager_status"] = Processor.process_get_raid_manager_status
        self._processMap["is_available_of_raid_manager"] = Processor.process_is_available_of_raid_manager
        self._processMap["exist_iscsi_device"] = Processor.process_exist_iscsi_device
        self._processMap["get_free_data_disks"] = Processor.process_get_free_data_disks
        self._processMap["init_storage_pool"] = Processor.process_init_storage_pool
        self._processMap["is_storage_pool_inited"] = Processor.process_is_storage_pool_inited
        self._processMap["get_storage_pool"] = Processor.process_get_storage_pool
        self._processMap["get_storage_pool_devices"] = Processor.process_get_storage_pool_devices
        self._processMap["get_storage_pool_swift_devices"] = Processor.process_get_storage_pool_swift_devices
        self._processMap["add_devices_to_pool"] = Processor.process_add_devices_to_pool
        self._processMap["add_node_devices_to_pool"] = Processor.process_add_node_devices_to_pool
        self._processMap["get_maintenance_of_devices"] = Processor.process_get_maintenance_of_devices
        self._processMap["enable_maintenance_of_devices"] = Processor.process_enable_maintenance_of_devices
        self._processMap["disable_maintenance_of_devices"] = Processor.process_disable_maintenance_of_devices
        self._processMap["get_free_data_disks_for_replace"] = Processor.process_get_free_data_disks_for_replace
        self._processMap["replace_device_in_pool"] = Processor.process_replace_device_in_pool
        self._processMap["remove_device_from_pool"] = Processor.process_remove_device_from_pool
        self._processMap["remove_node_devices_from_pool"] = Processor.process_remove_node_devices_from_pool
        self._processMap["rebalance_storage_pool"] = Processor.process_rebalance_storage_pool
        self._processMap["change_replicas"] = Processor.process_change_replicas
        self._processMap["get_replicas_health"] = Processor.process_get_replicas_health
        self._processMap["get_all_data_raid_pds"] = Processor.process_get_all_data_raid_pds
        self._processMap["get_free_data_raid_pds"] = Processor.process_get_free_data_raid_pds
        self._processMap["get_raid_pds_in_storage_pool"] = Processor.process_get_raid_pds_in_storage_pool
        self._processMap["get_sys_raid_pds"] = Processor.process_get_sys_raid_pds
        self._processMap["get_all_raid_lds"] = Processor.process_get_all_raid_lds
        self._processMap["get_raid_pd_details"] = Processor.process_get_raid_pd_details
        self._processMap["get_raid_ld_details"] = Processor.process_get_raid_ld_details
        self._processMap["init_free_data_raid_pds"] = Processor.process_init_free_data_raid_pds
        self._processMap["add_raid_hotspare"] = Processor.process_add_raid_hotspare
        self._processMap["remove_raid_hotspare"] = Processor.process_remove_raid_hotspare
        self._processMap["get_raid_lds_for_hotspare"] = Processor.process_get_raid_lds_for_hotspare
        self._processMap["create_cache_volume"] = Processor.process_create_cache_volume
        self._processMap["remove_cache_volume"] = Processor.process_remove_cache_volume
        self._processMap["get_cache_volume"] = Processor.process_get_cache_volume
        self._processMap["init_cache_volume"] = Processor.process_init_cache_volume
        self._processMap["is_cache_volume_inited"] = Processor.process_is_cache_volume_inited
        self._processMap["mount_cache_volume"] = Processor.process_mount_cache_volume
        self._processMap["allocate_cache_volume"] = Processor.process_allocate_cache_volume
        self._processMap["get_sys_volume"] = Processor.process_get_sys_volume
        self._processMap["get_sysvol_volume"] = Processor.process_get_sysvol_volume
        self._processMap["get_disk_info"] = Processor.process_get_disk_info
        self._processMap["get_data_disks"] = Processor.process_get_data_disks
        self._processMap["get_storage_console_address"] = Processor.process_get_storage_console_address
        self._processMap["get_local_ceph_storage_info"] = Processor.process_get_local_ceph_storage_info
        self._processMap["set_local_ceph_manage_vip"] = Processor.process_set_local_ceph_manage_vip
        self._processMap["get_local_ceph_manage_vip"] = Processor.process_get_local_ceph_manage_vip
        self._processMap["get_zabbix_status"] = Processor.process_get_zabbix_status
        self._processMap["enable_zabbix"] = Processor.process_enable_zabbix
        self._processMap["disable_zabbix"] = Processor.process_disable_zabbix
        self._processMap["get_alert_trigger_status"] = Processor.process_get_alert_trigger_status
        self._processMap["is_alert_enable"] = Processor.process_is_alert_enable
        self._processMap["enable_alert"] = Processor.process_enable_alert
        self._processMap["disable_alert"] = Processor.process_disable_alert
        self._processMap["enable_maintenance"] = Processor.process_enable_maintenance
        self._processMap["disable_maintenance"] = Processor.process_disable_maintenance
        self._processMap["get_maintenance_status"] = Processor.process_get_maintenance_status
        self._processMap["get_service_problem_records"] = Processor.process_get_service_problem_records
        self._processMap["get_database_problem_records"] = Processor.process_get_database_problem_records
        self._processMap["get_cpu_problem_records"] = Processor.process_get_cpu_problem_records
        self._processMap["get_sysvol_problem_records"] = Processor.process_get_sysvol_problem_records
        self._processMap["get_memory_problem_records"] = Processor.process_get_memory_problem_records
        self._processMap["get_self_backup_problem_records"] = Processor.process_get_self_backup_problem_records
        self._processMap["get_node_online_problem_records"] = Processor.process_get_node_online_problem_records
        self._processMap["get_node_switch_problem_records"] = Processor.process_get_node_switch_problem_records
        self._processMap["get_replicas_problem_records"] = Processor.process_get_replicas_problem_records
        self._processMap["get_storage_dev_problem_records"] = Processor.process_get_storage_dev_problem_records
        self._processMap["get_balance_problem_records"] = Processor.process_get_balance_problem_records
        self._processMap["add_storage_node"] = Processor.process_add_storage_node
        self._processMap["del_storage_node"] = Processor.process_del_storage_node
        self._processMap["get_storage_node_info"] = Processor.process_get_storage_node_info
        self._processMap["get_storage_master_node_ip"] = Processor.process_get_storage_master_node_ip
        self._processMap["enable_storage_lvs"] = Processor.process_enable_storage_lvs
        self._processMap["disable_storage_lvs"] = Processor.process_disable_storage_lvs
        self._processMap["add_application_node"] = Processor.process_add_application_node
        self._processMap["del_application_node"] = Processor.process_del_application_node
        self._processMap["get_app_node_info"] = Processor.process_get_app_node_info
        self._processMap["get_app_master_node_info"] = Processor.process_get_app_master_node_info
        self._processMap["get_app_master_node_ip"] = Processor.process_get_app_master_node_ip
        self._processMap["enable_app_lvs"] = Processor.process_enable_app_lvs
        self._processMap["disable_app_lvs"] = Processor.process_disable_app_lvs
        self._processMap["get_application_service"] = Processor.process_get_application_service
        self._processMap["add_application_service"] = Processor.process_add_application_service
        self._processMap["del_application_service"] = Processor.process_del_application_service
        self._processMap["get_service_status"] = Processor.process_get_service_status
        self._processMap["is_app_registered"] = Processor.process_is_app_registered
        self._processMap["add_single_application_node"] = Processor.process_add_single_application_node
        self._processMap["del_single_application_node"] = Processor.process_del_single_application_node
        self._processMap["get_single_application_service_by_node"] = Processor.process_get_single_application_service_by_node
        self._processMap["get_node_uuid_by_app_name"] = Processor.process_get_node_uuid_by_app_name
        self._processMap["get_app_host_ip"] = Processor.process_get_app_host_ip
        self._processMap["verify_sign_in"] = Processor.process_verify_sign_in
        self._processMap["app_sys_status"] = Processor.process_app_sys_status
        self._processMap["update_password"] = Processor.process_update_password
        self._processMap["update_user_name"] = Processor.process_update_user_name
        self._processMap["commit_conf_file"] = Processor.process_commit_conf_file
        self._processMap["commit_conf_file_content"] = Processor.process_commit_conf_file_content
        self._processMap["delete_conf_file"] = Processor.process_delete_conf_file
        self._processMap["get_commited_conf_files"] = Processor.process_get_commited_conf_files
        self._processMap["set_dns_server"] = Processor.process_set_dns_server
        self._processMap["get_dns_server"] = Processor.process_get_dns_server
        self._processMap["get_chrony_status"] = Processor.process_get_chrony_status
        self._processMap["disable_chrony"] = Processor.process_disable_chrony
        self._processMap["enable_chrony"] = Processor.process_enable_chrony
        self._processMap["add_time_server"] = Processor.process_add_time_server
        self._processMap["del_time_server"] = Processor.process_del_time_server
        self._processMap["get_time_server"] = Processor.process_get_time_server
        self._processMap["install_service"] = Processor.process_install_service
        self._processMap["uninstall_service"] = Processor.process_uninstall_service
        self._processMap["get_node_service"] = Processor.process_get_node_service
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_is_node_dirty(self, seqid, iprot, oprot):
        args = is_node_dirty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_node_dirty_result()
        try:
            result.success = self._handler.is_node_dirty(args.host, args.port, args.user, args.passwd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_node_dirty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_env_dirty(self, seqid, iprot, oprot):
        args = is_env_dirty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_env_dirty_result()
        try:
            result.success = self._handler.is_env_dirty(args.node_ipaddr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_env_dirty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clear_node(self, seqid, iprot, oprot):
        args = clear_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_node_result()
        try:
            self._handler.clear_node(args.node_ipaddr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clear_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_active_cluster(self, seqid, iprot, oprot):
        args = active_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = active_cluster_result()
        try:
            result.success = self._handler.active_cluster(args.node_ipaddr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("active_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_node(self, seqid, iprot, oprot):
        args = add_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_node_result()
        try:
            result.success = self._handler.add_node(args.host)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_node(self, seqid, iprot, oprot):
        args = del_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_node_result()
        try:
            self._handler.del_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_module_status(self, seqid, iprot, oprot):
        args = get_module_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_module_status_result()
        try:
            result.success = self._handler.get_module_status(args.module_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_module_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_module(self, seqid, iprot, oprot):
        args = enable_module_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_module_result()
        try:
            self._handler.enable_module(args.module_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_module", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_module(self, seqid, iprot, oprot):
        args = disable_module_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_module_result()
        try:
            self._handler.disable_module(args.module_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_module", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_ecms_db(self, seqid, iprot, oprot):
        args = create_ecms_db_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_ecms_db_result()
        try:
            self._handler.create_ecms_db()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_ecms_db", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_node_info(self, seqid, iprot, oprot):
        args = get_db_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_node_info_result()
        try:
            result.success = self._handler.get_db_node_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_db_master(self, seqid, iprot, oprot):
        args = set_db_master_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_db_master_result()
        try:
            self._handler.set_db_master(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_db_master", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_db_slave(self, seqid, iprot, oprot):
        args = set_db_slave_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_db_slave_result()
        try:
            self._handler.set_db_slave(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_db_slave", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_db_slave_by_xtrabackup(self, seqid, iprot, oprot):
        args = set_db_slave_by_xtrabackup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_db_slave_by_xtrabackup_result()
        try:
            self._handler.set_db_slave_by_xtrabackup(args.node_uuid, args.slave_ssh_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_db_slave_by_xtrabackup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_db_node(self, seqid, iprot, oprot):
        args = cancel_db_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_db_node_result()
        try:
            self._handler.cancel_db_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_db_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_deployment_mode(self, seqid, iprot, oprot):
        args = update_deployment_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_deployment_mode_result()
        try:
            self._handler.update_deployment_mode(args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_deployment_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_deployment_mode(self, seqid, iprot, oprot):
        args = get_deployment_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_deployment_mode_result()
        try:
            result.success = self._handler.get_deployment_mode()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_deployment_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dump_databases_to_path(self, seqid, iprot, oprot):
        args = dump_databases_to_path_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dump_databases_to_path_result()
        try:
            self._handler.dump_databases_to_path(args.host, args.port, args.db_name, args.path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dump_databases_to_path", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_databases_name(self, seqid, iprot, oprot):
        args = get_databases_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_databases_name_result()
        try:
            result.success = self._handler.get_databases_name(args.host, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_databases_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_purge_binlogs(self, seqid, iprot, oprot):
        args = purge_binlogs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = purge_binlogs_result()
        try:
            self._handler.purge_binlogs(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("purge_binlogs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_external_db_info(self, seqid, iprot, oprot):
        args = update_external_db_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_external_db_info_result()
        try:
            self._handler.update_external_db_info(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_external_db_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_external_db_info(self, seqid, iprot, oprot):
        args = get_external_db_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_external_db_info_result()
        try:
            result.success = self._handler.get_external_db_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_external_db_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_external_db(self, seqid, iprot, oprot):
        args = is_external_db_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_external_db_result()
        try:
            result.success = self._handler.is_external_db()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_external_db", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_available_external_db(self, seqid, iprot, oprot):
        args = is_available_external_db_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_available_external_db_result()
        try:
            result.success = self._handler.is_available_external_db(args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_available_external_db", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_firewall_rule(self, seqid, iprot, oprot):
        args = add_firewall_rule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_firewall_rule_result()
        try:
            self._handler.add_firewall_rule(args.firewall_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_firewall_rule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_firewall_rule(self, seqid, iprot, oprot):
        args = del_firewall_rule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_firewall_rule_result()
        try:
            self._handler.del_firewall_rule(args.firewall_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_firewall_rule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_firewall_rule(self, seqid, iprot, oprot):
        args = update_firewall_rule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_firewall_rule_result()
        try:
            self._handler.update_firewall_rule(args.old_info, args.new_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_firewall_rule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_firewall_rule(self, seqid, iprot, oprot):
        args = get_firewall_rule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_firewall_rule_result()
        try:
            result.success = self._handler.get_firewall_rule(args.sys_role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_firewall_rule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_firewall(self, seqid, iprot, oprot):
        args = enable_firewall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_firewall_result()
        try:
            self._handler.enable_firewall()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_firewall", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_firewall(self, seqid, iprot, oprot):
        args = disable_firewall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_firewall_result()
        try:
            self._handler.disable_firewall()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_firewall", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_firewall_status(self, seqid, iprot, oprot):
        args = get_firewall_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_firewall_status_result()
        try:
            result.success = self._handler.get_firewall_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_firewall_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_sys_service(self, seqid, iprot, oprot):
        args = enable_sys_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_sys_service_result()
        try:
            self._handler.enable_sys_service(args.sys_role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_sys_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_sys_service(self, seqid, iprot, oprot):
        args = disable_sys_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_sys_service_result()
        try:
            self._handler.disable_sys_service(args.sys_role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_sys_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sys_service_status(self, seqid, iprot, oprot):
        args = get_sys_service_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sys_service_status_result()
        try:
            result.success = self._handler.get_sys_service_status(args.sys_role)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sys_service_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_trusted_ip(self, seqid, iprot, oprot):
        args = add_trusted_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_trusted_ip_result()
        try:
            self._handler.add_trusted_ip(args.ip_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_trusted_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_storage_trusted_ip(self, seqid, iprot, oprot):
        args = set_storage_trusted_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_storage_trusted_ip_result()
        try:
            self._handler.set_storage_trusted_ip(args.firewall_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_storage_trusted_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_asu_node_ip(self, seqid, iprot, oprot):
        args = get_asu_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_asu_node_ip_result()
        try:
            result.success = self._handler.get_asu_node_ip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_asu_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_keepalived_status(self, seqid, iprot, oprot):
        args = get_keepalived_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_keepalived_status_result()
        try:
            result.success = self._handler.get_keepalived_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_keepalived_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_keepalived(self, seqid, iprot, oprot):
        args = enable_keepalived_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_keepalived_result()
        try:
            self._handler.enable_keepalived()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_keepalived", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_keepalived(self, seqid, iprot, oprot):
        args = disable_keepalived_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_keepalived_result()
        try:
            self._handler.disable_keepalived()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_keepalived", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_vip_info(self, seqid, iprot, oprot):
        args = get_vip_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_vip_info_result()
        try:
            result.success = self._handler.get_vip_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_vip_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_vip_info(self, seqid, iprot, oprot):
        args = set_vip_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_vip_info_result()
        try:
            self._handler.set_vip_info(args.vip_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_vip_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_ivip_info(self, seqid, iprot, oprot):
        args = set_ivip_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_ivip_info_result()
        try:
            self._handler.set_ivip_info(args.ivip_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_ivip_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_ha_node_info(self, seqid, iprot, oprot):
        args = get_ha_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_ha_node_info_result()
        try:
            result.success = self._handler.get_ha_node_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_ha_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_ha_master(self, seqid, iprot, oprot):
        args = set_ha_master_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_ha_master_result()
        try:
            self._handler.set_ha_master(args.node_uuid, args.vip_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_ha_master", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_ha_slave(self, seqid, iprot, oprot):
        args = set_ha_slave_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_ha_slave_result()
        try:
            self._handler.set_ha_slave(args.node_uuid, args.ha_sys)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_ha_slave", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_ha_node(self, seqid, iprot, oprot):
        args = cancel_ha_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_ha_node_result()
        try:
            self._handler.cancel_ha_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_ha_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_db_ha_master(self, seqid, iprot, oprot):
        args = set_db_ha_master_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_db_ha_master_result()
        try:
            self._handler.set_db_ha_master(args.ivip_info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_db_ha_master", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_db_ha_slave(self, seqid, iprot, oprot):
        args = set_db_ha_slave_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_db_ha_slave_result()
        try:
            self._handler.set_db_ha_slave()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_db_ha_slave", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_db_ha_node(self, seqid, iprot, oprot):
        args = cancel_db_ha_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_db_ha_node_result()
        try:
            self._handler.cancel_db_ha_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_db_ha_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_on_lvs_changed(self, seqid, iprot, oprot):
        args = on_lvs_changed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = on_lvs_changed_result()
        try:
            self._handler.on_lvs_changed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("on_lvs_changed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_on_node_entering_master(self, seqid, iprot, oprot):
        args = on_node_entering_master_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = on_node_entering_master_result()
        try:
            self._handler.on_node_entering_master()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("on_node_entering_master", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_on_node_entering_slave(self, seqid, iprot, oprot):
        args = on_node_entering_slave_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = on_node_entering_slave_result()
        try:
            self._handler.on_node_entering_slave()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("on_node_entering_slave", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_force_enter_master(self, seqid, iprot, oprot):
        args = force_enter_master_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = force_enter_master_result()
        try:
            self._handler.force_enter_master()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("force_enter_master", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_node_info(self, seqid, iprot, oprot):
        args = get_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_node_info_result()
        try:
            result.success = self._handler.get_node_info(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_node_info(self, seqid, iprot, oprot):
        args = get_all_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_node_info_result()
        try:
            result.success = self._handler.get_all_node_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_node_alias(self, seqid, iprot, oprot):
        args = set_node_alias_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_node_alias_result()
        try:
            self._handler.set_node_alias(args.node_uuid, args.node_alias)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_node_alias", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restart_eisooapp(self, seqid, iprot, oprot):
        args = restart_eisooapp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restart_eisooapp_result()
        try:
            self._handler.restart_eisooapp(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restart_eisooapp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reboot_node(self, seqid, iprot, oprot):
        args = reboot_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reboot_node_result()
        try:
            self._handler.reboot_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reboot_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shutdown_cluster(self, seqid, iprot, oprot):
        args = shutdown_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shutdown_cluster_result()
        try:
            self._handler.shutdown_cluster()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shutdown_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_time(self, seqid, iprot, oprot):
        args = get_cluster_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_time_result()
        try:
            result.success = self._handler.get_cluster_time()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cluster_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_cluster_time(self, seqid, iprot, oprot):
        args = set_cluster_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_cluster_time_result()
        try:
            self._handler.set_cluster_time(args.datetime)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_cluster_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_version(self, seqid, iprot, oprot):
        args = get_cluster_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_version_result()
        try:
            result.success = self._handler.get_cluster_version()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cluster_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_uuid(self, seqid, iprot, oprot):
        args = get_cluster_uuid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_uuid_result()
        try:
            result.success = self._handler.get_cluster_uuid()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cluster_uuid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_log_server(self, seqid, iprot, oprot):
        args = add_log_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_log_server_result()
        try:
            self._handler.add_log_server(args.facility, args.severity, args.ip, args.port, args.protocol)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_log_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_log_server(self, seqid, iprot, oprot):
        args = delete_log_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_log_server_result()
        try:
            self._handler.delete_log_server(args.facility, args.severity, args.ip, args.port, args.protocol)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_log_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_upload_log(self, seqid, iprot, oprot):
        args = enable_upload_log_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_upload_log_result()
        try:
            self._handler.enable_upload_log(args.datetime)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_upload_log", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_upload_log(self, seqid, iprot, oprot):
        args = disable_upload_log_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_upload_log_result()
        try:
            self._handler.disable_upload_log()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_upload_log", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_upload_log_status(self, seqid, iprot, oprot):
        args = get_upload_log_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_upload_log_status_result()
        try:
            result.success = self._handler.get_upload_log_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_upload_log_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_upload_log_server(self, seqid, iprot, oprot):
        args = get_upload_log_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_upload_log_server_result()
        try:
            result.success = self._handler.get_upload_log_server()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_upload_log_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_upload_log_time(self, seqid, iprot, oprot):
        args = get_upload_log_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_upload_log_time_result()
        try:
            result.success = self._handler.get_upload_log_time()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_upload_log_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_nics_name(self, seqid, iprot, oprot):
        args = get_all_nics_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_nics_name_result()
        try:
            result.success = self._handler.get_all_nics_name(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_nics_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cpu_usage(self, seqid, iprot, oprot):
        args = get_cpu_usage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cpu_usage_result()
        try:
            result.success = self._handler.get_cpu_usage(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cpu_usage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_memory_info(self, seqid, iprot, oprot):
        args = get_memory_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_memory_info_result()
        try:
            result.success = self._handler.get_memory_info(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_memory_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_network_outgoing_rate(self, seqid, iprot, oprot):
        args = get_network_outgoing_rate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_network_outgoing_rate_result()
        try:
            result.success = self._handler.get_network_outgoing_rate(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_network_outgoing_rate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_network_incoming_rate(self, seqid, iprot, oprot):
        args = get_network_incoming_rate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_network_incoming_rate_result()
        try:
            result.success = self._handler.get_network_incoming_rate(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_network_incoming_rate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_troubleshoot(self, seqid, iprot, oprot):
        args = troubleshoot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = troubleshoot_result()
        try:
            self._handler.troubleshoot()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("troubleshoot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_consistency_repair(self, seqid, iprot, oprot):
        args = consistency_repair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = consistency_repair_result()
        try:
            self._handler.consistency_repair()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("consistency_repair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_consistency_check(self, seqid, iprot, oprot):
        args = consistency_check_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = consistency_check_result()
        try:
            result.success = self._handler.consistency_check()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("consistency_check", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_on_node_heartbeat(self, seqid, iprot, oprot):
        args = on_node_heartbeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = on_node_heartbeat_result()
        try:
            self._handler.on_node_heartbeat(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("on_node_heartbeat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_on_change_node_ip(self, seqid, iprot, oprot):
        args = on_change_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = on_change_node_ip_result()
        try:
            self._handler.on_change_node_ip(args.old_ip, args.new_ip, args.update_db_host)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("on_change_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_raid_manager(self, seqid, iprot, oprot):
        args = enable_raid_manager_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_raid_manager_result()
        try:
            self._handler.enable_raid_manager()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_raid_manager", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_raid_manager(self, seqid, iprot, oprot):
        args = disable_raid_manager_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_raid_manager_result()
        try:
            self._handler.disable_raid_manager()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_raid_manager", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_raid_manager_status(self, seqid, iprot, oprot):
        args = get_raid_manager_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_raid_manager_status_result()
        try:
            result.success = self._handler.get_raid_manager_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_raid_manager_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_available_of_raid_manager(self, seqid, iprot, oprot):
        args = is_available_of_raid_manager_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_available_of_raid_manager_result()
        try:
            result.success = self._handler.is_available_of_raid_manager(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_available_of_raid_manager", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exist_iscsi_device(self, seqid, iprot, oprot):
        args = exist_iscsi_device_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exist_iscsi_device_result()
        try:
            result.success = self._handler.exist_iscsi_device(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exist_iscsi_device", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_free_data_disks(self, seqid, iprot, oprot):
        args = get_free_data_disks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_free_data_disks_result()
        try:
            result.success = self._handler.get_free_data_disks(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_free_data_disks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_init_storage_pool(self, seqid, iprot, oprot):
        args = init_storage_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = init_storage_pool_result()
        try:
            self._handler.init_storage_pool(args.replicas)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("init_storage_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_storage_pool_inited(self, seqid, iprot, oprot):
        args = is_storage_pool_inited_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_storage_pool_inited_result()
        try:
            result.success = self._handler.is_storage_pool_inited()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_storage_pool_inited", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_pool(self, seqid, iprot, oprot):
        args = get_storage_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_pool_result()
        try:
            result.success = self._handler.get_storage_pool(args.include_used_size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_pool_devices(self, seqid, iprot, oprot):
        args = get_storage_pool_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_pool_devices_result()
        try:
            result.success = self._handler.get_storage_pool_devices(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_pool_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_pool_swift_devices(self, seqid, iprot, oprot):
        args = get_storage_pool_swift_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_pool_swift_devices_result()
        try:
            result.success = self._handler.get_storage_pool_swift_devices()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_pool_swift_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_devices_to_pool(self, seqid, iprot, oprot):
        args = add_devices_to_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_devices_to_pool_result()
        try:
            self._handler.add_devices_to_pool(args.disk_dev_paths)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_devices_to_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_node_devices_to_pool(self, seqid, iprot, oprot):
        args = add_node_devices_to_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_node_devices_to_pool_result()
        try:
            self._handler.add_node_devices_to_pool(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_node_devices_to_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_maintenance_of_devices(self, seqid, iprot, oprot):
        args = get_maintenance_of_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_maintenance_of_devices_result()
        try:
            result.success = self._handler.get_maintenance_of_devices(args.dev_uuids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_maintenance_of_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_maintenance_of_devices(self, seqid, iprot, oprot):
        args = enable_maintenance_of_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_maintenance_of_devices_result()
        try:
            result.success = self._handler.enable_maintenance_of_devices(args.dev_uuids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_maintenance_of_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_maintenance_of_devices(self, seqid, iprot, oprot):
        args = disable_maintenance_of_devices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_maintenance_of_devices_result()
        try:
            result.success = self._handler.disable_maintenance_of_devices(args.dev_uuids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_maintenance_of_devices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_free_data_disks_for_replace(self, seqid, iprot, oprot):
        args = get_free_data_disks_for_replace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_free_data_disks_for_replace_result()
        try:
            result.success = self._handler.get_free_data_disks_for_replace(args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_free_data_disks_for_replace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_replace_device_in_pool(self, seqid, iprot, oprot):
        args = replace_device_in_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = replace_device_in_pool_result()
        try:
            self._handler.replace_device_in_pool(args.dev_id, args.disk_dev_path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("replace_device_in_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_device_from_pool(self, seqid, iprot, oprot):
        args = remove_device_from_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_device_from_pool_result()
        try:
            self._handler.remove_device_from_pool(args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_device_from_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_node_devices_from_pool(self, seqid, iprot, oprot):
        args = remove_node_devices_from_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_node_devices_from_pool_result()
        try:
            self._handler.remove_node_devices_from_pool(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_node_devices_from_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rebalance_storage_pool(self, seqid, iprot, oprot):
        args = rebalance_storage_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rebalance_storage_pool_result()
        try:
            self._handler.rebalance_storage_pool()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rebalance_storage_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_change_replicas(self, seqid, iprot, oprot):
        args = change_replicas_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = change_replicas_result()
        try:
            self._handler.change_replicas(args.replicas)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("change_replicas", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_replicas_health(self, seqid, iprot, oprot):
        args = get_replicas_health_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_replicas_health_result()
        try:
            result.success = self._handler.get_replicas_health()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_replicas_health", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_data_raid_pds(self, seqid, iprot, oprot):
        args = get_all_data_raid_pds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_data_raid_pds_result()
        try:
            result.success = self._handler.get_all_data_raid_pds(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_data_raid_pds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_free_data_raid_pds(self, seqid, iprot, oprot):
        args = get_free_data_raid_pds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_free_data_raid_pds_result()
        try:
            result.success = self._handler.get_free_data_raid_pds(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_free_data_raid_pds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_raid_pds_in_storage_pool(self, seqid, iprot, oprot):
        args = get_raid_pds_in_storage_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_raid_pds_in_storage_pool_result()
        try:
            result.success = self._handler.get_raid_pds_in_storage_pool(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_raid_pds_in_storage_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sys_raid_pds(self, seqid, iprot, oprot):
        args = get_sys_raid_pds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sys_raid_pds_result()
        try:
            result.success = self._handler.get_sys_raid_pds(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sys_raid_pds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_raid_lds(self, seqid, iprot, oprot):
        args = get_all_raid_lds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_raid_lds_result()
        try:
            result.success = self._handler.get_all_raid_lds(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_raid_lds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_raid_pd_details(self, seqid, iprot, oprot):
        args = get_raid_pd_details_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_raid_pd_details_result()
        try:
            result.success = self._handler.get_raid_pd_details(args.node_ip, args.pd_devid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_raid_pd_details", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_raid_ld_details(self, seqid, iprot, oprot):
        args = get_raid_ld_details_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_raid_ld_details_result()
        try:
            result.success = self._handler.get_raid_ld_details(args.node_ip, args.ld_devid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_raid_ld_details", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_init_free_data_raid_pds(self, seqid, iprot, oprot):
        args = init_free_data_raid_pds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = init_free_data_raid_pds_result()
        try:
            result.success = self._handler.init_free_data_raid_pds(args.node_ip, args.pd_devids, args.bond_disks_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("init_free_data_raid_pds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_raid_hotspare(self, seqid, iprot, oprot):
        args = add_raid_hotspare_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_raid_hotspare_result()
        try:
            self._handler.add_raid_hotspare(args.node_ip, args.pd_devid, args.ld_devid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_raid_hotspare", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_raid_hotspare(self, seqid, iprot, oprot):
        args = remove_raid_hotspare_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_raid_hotspare_result()
        try:
            self._handler.remove_raid_hotspare(args.node_ip, args.pd_devid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_raid_hotspare", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_raid_lds_for_hotspare(self, seqid, iprot, oprot):
        args = get_raid_lds_for_hotspare_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_raid_lds_for_hotspare_result()
        try:
            result.success = self._handler.get_raid_lds_for_hotspare(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_raid_lds_for_hotspare", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_cache_volume(self, seqid, iprot, oprot):
        args = create_cache_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_cache_volume_result()
        try:
            result.success = self._handler.create_cache_volume(args.node_uuid, args.disk_dev_path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_cache_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_cache_volume(self, seqid, iprot, oprot):
        args = remove_cache_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_cache_volume_result()
        try:
            self._handler.remove_cache_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_cache_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cache_volume(self, seqid, iprot, oprot):
        args = get_cache_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cache_volume_result()
        try:
            result.success = self._handler.get_cache_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cache_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_init_cache_volume(self, seqid, iprot, oprot):
        args = init_cache_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = init_cache_volume_result()
        try:
            self._handler.init_cache_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("init_cache_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_cache_volume_inited(self, seqid, iprot, oprot):
        args = is_cache_volume_inited_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_cache_volume_inited_result()
        try:
            result.success = self._handler.is_cache_volume_inited(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_cache_volume_inited", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mount_cache_volume(self, seqid, iprot, oprot):
        args = mount_cache_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mount_cache_volume_result()
        try:
            self._handler.mount_cache_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mount_cache_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_allocate_cache_volume(self, seqid, iprot, oprot):
        args = allocate_cache_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = allocate_cache_volume_result()
        try:
            self._handler.allocate_cache_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("allocate_cache_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sys_volume(self, seqid, iprot, oprot):
        args = get_sys_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sys_volume_result()
        try:
            result.success = self._handler.get_sys_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sys_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sysvol_volume(self, seqid, iprot, oprot):
        args = get_sysvol_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sysvol_volume_result()
        try:
            result.success = self._handler.get_sysvol_volume(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sysvol_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_disk_info(self, seqid, iprot, oprot):
        args = get_disk_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_disk_info_result()
        try:
            result.success = self._handler.get_disk_info(args.node_uuid, args.dev_path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_disk_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_data_disks(self, seqid, iprot, oprot):
        args = get_data_disks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_data_disks_result()
        try:
            result.success = self._handler.get_data_disks(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_data_disks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_console_address(self, seqid, iprot, oprot):
        args = get_storage_console_address_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_console_address_result()
        try:
            result.success = self._handler.get_storage_console_address(args.storage_server_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_console_address", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_local_ceph_storage_info(self, seqid, iprot, oprot):
        args = get_local_ceph_storage_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_local_ceph_storage_info_result()
        try:
            result.success = self._handler.get_local_ceph_storage_info(args.storage_server_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_local_ceph_storage_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_local_ceph_manage_vip(self, seqid, iprot, oprot):
        args = set_local_ceph_manage_vip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_local_ceph_manage_vip_result()
        try:
            self._handler.set_local_ceph_manage_vip(args.ceph_manage_vip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_local_ceph_manage_vip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_local_ceph_manage_vip(self, seqid, iprot, oprot):
        args = get_local_ceph_manage_vip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_local_ceph_manage_vip_result()
        try:
            result.success = self._handler.get_local_ceph_manage_vip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_local_ceph_manage_vip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_zabbix_status(self, seqid, iprot, oprot):
        args = get_zabbix_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_zabbix_status_result()
        try:
            result.success = self._handler.get_zabbix_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_zabbix_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_zabbix(self, seqid, iprot, oprot):
        args = enable_zabbix_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_zabbix_result()
        try:
            self._handler.enable_zabbix()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_zabbix", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_zabbix(self, seqid, iprot, oprot):
        args = disable_zabbix_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_zabbix_result()
        try:
            self._handler.disable_zabbix()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_zabbix", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_alert_trigger_status(self, seqid, iprot, oprot):
        args = get_alert_trigger_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_alert_trigger_status_result()
        try:
            result.success = self._handler.get_alert_trigger_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_alert_trigger_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_alert_enable(self, seqid, iprot, oprot):
        args = is_alert_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_alert_enable_result()
        try:
            result.success = self._handler.is_alert_enable()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_alert_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_alert(self, seqid, iprot, oprot):
        args = enable_alert_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_alert_result()
        try:
            self._handler.enable_alert()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_alert", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_alert(self, seqid, iprot, oprot):
        args = disable_alert_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_alert_result()
        try:
            self._handler.disable_alert()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_alert", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_maintenance(self, seqid, iprot, oprot):
        args = enable_maintenance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_maintenance_result()
        try:
            self._handler.enable_maintenance()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_maintenance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_maintenance(self, seqid, iprot, oprot):
        args = disable_maintenance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_maintenance_result()
        try:
            self._handler.disable_maintenance()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_maintenance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_maintenance_status(self, seqid, iprot, oprot):
        args = get_maintenance_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_maintenance_status_result()
        try:
            result.success = self._handler.get_maintenance_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_maintenance_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_service_problem_records(self, seqid, iprot, oprot):
        args = get_service_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_service_problem_records_result()
        try:
            result.success = self._handler.get_service_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_service_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_database_problem_records(self, seqid, iprot, oprot):
        args = get_database_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_database_problem_records_result()
        try:
            result.success = self._handler.get_database_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_database_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cpu_problem_records(self, seqid, iprot, oprot):
        args = get_cpu_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cpu_problem_records_result()
        try:
            result.success = self._handler.get_cpu_problem_records(args.ipaddr, args.threshold, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cpu_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sysvol_problem_records(self, seqid, iprot, oprot):
        args = get_sysvol_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sysvol_problem_records_result()
        try:
            result.success = self._handler.get_sysvol_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sysvol_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_memory_problem_records(self, seqid, iprot, oprot):
        args = get_memory_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_memory_problem_records_result()
        try:
            result.success = self._handler.get_memory_problem_records(args.ipaddr, args.threshold, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_memory_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_self_backup_problem_records(self, seqid, iprot, oprot):
        args = get_self_backup_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_self_backup_problem_records_result()
        try:
            result.success = self._handler.get_self_backup_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_self_backup_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_node_online_problem_records(self, seqid, iprot, oprot):
        args = get_node_online_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_node_online_problem_records_result()
        try:
            result.success = self._handler.get_node_online_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_node_online_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_node_switch_problem_records(self, seqid, iprot, oprot):
        args = get_node_switch_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_node_switch_problem_records_result()
        try:
            result.success = self._handler.get_node_switch_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_node_switch_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_replicas_problem_records(self, seqid, iprot, oprot):
        args = get_replicas_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_replicas_problem_records_result()
        try:
            result.success = self._handler.get_replicas_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_replicas_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_dev_problem_records(self, seqid, iprot, oprot):
        args = get_storage_dev_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_dev_problem_records_result()
        try:
            result.success = self._handler.get_storage_dev_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_dev_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_balance_problem_records(self, seqid, iprot, oprot):
        args = get_balance_problem_records_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_balance_problem_records_result()
        try:
            result.success = self._handler.get_balance_problem_records(args.ipaddr, args.time_from, args.time_till)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_balance_problem_records", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_storage_node(self, seqid, iprot, oprot):
        args = add_storage_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_storage_node_result()
        try:
            self._handler.add_storage_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_storage_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_storage_node(self, seqid, iprot, oprot):
        args = del_storage_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_storage_node_result()
        try:
            self._handler.del_storage_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_storage_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_node_info(self, seqid, iprot, oprot):
        args = get_storage_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_node_info_result()
        try:
            result.success = self._handler.get_storage_node_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_master_node_ip(self, seqid, iprot, oprot):
        args = get_storage_master_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_master_node_ip_result()
        try:
            result.success = self._handler.get_storage_master_node_ip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_master_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_storage_lvs(self, seqid, iprot, oprot):
        args = enable_storage_lvs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_storage_lvs_result()
        try:
            self._handler.enable_storage_lvs(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_storage_lvs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_storage_lvs(self, seqid, iprot, oprot):
        args = disable_storage_lvs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_storage_lvs_result()
        try:
            self._handler.disable_storage_lvs(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_storage_lvs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_application_node(self, seqid, iprot, oprot):
        args = add_application_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_application_node_result()
        try:
            self._handler.add_application_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_application_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_application_node(self, seqid, iprot, oprot):
        args = del_application_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_application_node_result()
        try:
            self._handler.del_application_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_application_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_app_node_info(self, seqid, iprot, oprot):
        args = get_app_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_app_node_info_result()
        try:
            result.success = self._handler.get_app_node_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_app_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_app_master_node_info(self, seqid, iprot, oprot):
        args = get_app_master_node_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_app_master_node_info_result()
        try:
            result.success = self._handler.get_app_master_node_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_app_master_node_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_app_master_node_ip(self, seqid, iprot, oprot):
        args = get_app_master_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_app_master_node_ip_result()
        try:
            result.success = self._handler.get_app_master_node_ip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_app_master_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_app_lvs(self, seqid, iprot, oprot):
        args = enable_app_lvs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_app_lvs_result()
        try:
            self._handler.enable_app_lvs(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_app_lvs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_app_lvs(self, seqid, iprot, oprot):
        args = disable_app_lvs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_app_lvs_result()
        try:
            self._handler.disable_app_lvs(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_app_lvs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_application_service(self, seqid, iprot, oprot):
        args = get_application_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_application_service_result()
        try:
            result.success = self._handler.get_application_service()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_application_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_application_service(self, seqid, iprot, oprot):
        args = add_application_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_application_service_result()
        try:
            self._handler.add_application_service(args.service_name, args.port, args.is_lvs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_application_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_application_service(self, seqid, iprot, oprot):
        args = del_application_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_application_service_result()
        try:
            self._handler.del_application_service(args.service_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_application_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_service_status(self, seqid, iprot, oprot):
        args = get_service_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_service_status_result()
        try:
            result.success = self._handler.get_service_status(args.node_uuid, args.service_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_service_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_app_registered(self, seqid, iprot, oprot):
        args = is_app_registered_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_app_registered_result()
        try:
            result.success = self._handler.is_app_registered(args.app_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_app_registered", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_single_application_node(self, seqid, iprot, oprot):
        args = add_single_application_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_single_application_node_result()
        try:
            self._handler.add_single_application_node(args.node_uuid, args.app_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_single_application_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_single_application_node(self, seqid, iprot, oprot):
        args = del_single_application_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_single_application_node_result()
        try:
            self._handler.del_single_application_node(args.app_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_single_application_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_single_application_service_by_node(self, seqid, iprot, oprot):
        args = get_single_application_service_by_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_single_application_service_by_node_result()
        try:
            result.success = self._handler.get_single_application_service_by_node(args.node_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_single_application_service_by_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_node_uuid_by_app_name(self, seqid, iprot, oprot):
        args = get_node_uuid_by_app_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_node_uuid_by_app_name_result()
        try:
            result.success = self._handler.get_node_uuid_by_app_name(args.app_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as ex:
            msg_type = TMessageType.REPLY
            result.ex = ex
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_node_uuid_by_app_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_app_host_ip(self, seqid, iprot, oprot):
        args = get_app_host_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_app_host_ip_result()
        try:
            result.success = self._handler.get_app_host_ip(args.app_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_app_host_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verify_sign_in(self, seqid, iprot, oprot):
        args = verify_sign_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verify_sign_in_result()
        try:
            result.success = self._handler.verify_sign_in(args.user, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verify_sign_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_app_sys_status(self, seqid, iprot, oprot):
        args = app_sys_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = app_sys_status_result()
        try:
            result.success = self._handler.app_sys_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("app_sys_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_password(self, seqid, iprot, oprot):
        args = update_password_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_password_result()
        try:
            self._handler.update_password(args.uuid, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_password", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_user_name(self, seqid, iprot, oprot):
        args = update_user_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_user_name_result()
        try:
            self._handler.update_user_name(args.uuid, args.user_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_user_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_conf_file(self, seqid, iprot, oprot):
        args = commit_conf_file_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_conf_file_result()
        try:
            self._handler.commit_conf_file(args.conf_file_path, args.source_file_path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_conf_file", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_conf_file_content(self, seqid, iprot, oprot):
        args = commit_conf_file_content_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_conf_file_content_result()
        try:
            self._handler.commit_conf_file_content(args.conf_file_path, args.file_content)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_conf_file_content", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_conf_file(self, seqid, iprot, oprot):
        args = delete_conf_file_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_conf_file_result()
        try:
            self._handler.delete_conf_file(args.conf_file_path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_conf_file", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_commited_conf_files(self, seqid, iprot, oprot):
        args = get_commited_conf_files_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_commited_conf_files_result()
        try:
            result.success = self._handler.get_commited_conf_files()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_commited_conf_files", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_dns_server(self, seqid, iprot, oprot):
        args = set_dns_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_dns_server_result()
        try:
            self._handler.set_dns_server(args.nameservers)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_dns_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dns_server(self, seqid, iprot, oprot):
        args = get_dns_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dns_server_result()
        try:
            result.success = self._handler.get_dns_server()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dns_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_chrony_status(self, seqid, iprot, oprot):
        args = get_chrony_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_chrony_status_result()
        try:
            result.success = self._handler.get_chrony_status()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_chrony_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_chrony(self, seqid, iprot, oprot):
        args = disable_chrony_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_chrony_result()
        try:
            self._handler.disable_chrony()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_chrony", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_chrony(self, seqid, iprot, oprot):
        args = enable_chrony_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_chrony_result()
        try:
            self._handler.enable_chrony()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_chrony", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_time_server(self, seqid, iprot, oprot):
        args = add_time_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_time_server_result()
        try:
            self._handler.add_time_server(args.server)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_time_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_time_server(self, seqid, iprot, oprot):
        args = del_time_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_time_server_result()
        try:
            self._handler.del_time_server(args.server)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_time_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_time_server(self, seqid, iprot, oprot):
        args = get_time_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_time_server_result()
        try:
            result.success = self._handler.get_time_server()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_time_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_install_service(self, seqid, iprot, oprot):
        args = install_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = install_service_result()
        try:
            self._handler.install_service(args.server_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("install_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_uninstall_service(self, seqid, iprot, oprot):
        args = uninstall_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = uninstall_service_result()
        try:
            self._handler.uninstall_service(args.server_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("uninstall_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_node_service(self, seqid, iprot, oprot):
        args = get_node_service_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_node_service_result()
        try:
            result.success = self._handler.get_node_service()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_node_service", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class is_node_dirty_args(object):
    """
    Attributes:
     - host
     - port
     - user
     - passwd

    """


    def __init__(self, host=None, port=None, user=None, passwd=None,):
        self.host = host
        self.port = port
        self.user = user
        self.passwd = passwd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_node_dirty_args')
        if self.host is not None:
            oprot.writeFieldBegin('host', TType.STRING, 1)
            oprot.writeString(self.host.encode('utf-8') if sys.version_info[0] == 2 else self.host)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 3)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 4)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_node_dirty_args)
is_node_dirty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'host', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'user', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'passwd', 'UTF8', None, ),  # 4
)


class is_node_dirty_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_node_dirty_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_node_dirty_result)
is_node_dirty_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_env_dirty_args(object):
    """
    Attributes:
     - node_ipaddr

    """


    def __init__(self, node_ipaddr=None,):
        self.node_ipaddr = node_ipaddr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_env_dirty_args')
        if self.node_ipaddr is not None:
            oprot.writeFieldBegin('node_ipaddr', TType.STRING, 1)
            oprot.writeString(self.node_ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.node_ipaddr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_env_dirty_args)
is_env_dirty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ipaddr', 'UTF8', None, ),  # 1
)


class is_env_dirty_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_env_dirty_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_env_dirty_result)
is_env_dirty_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class clear_node_args(object):
    """
    Attributes:
     - node_ipaddr

    """


    def __init__(self, node_ipaddr=None,):
        self.node_ipaddr = node_ipaddr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_node_args')
        if self.node_ipaddr is not None:
            oprot.writeFieldBegin('node_ipaddr', TType.STRING, 1)
            oprot.writeString(self.node_ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.node_ipaddr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_node_args)
clear_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ipaddr', 'UTF8', None, ),  # 1
)


class clear_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_node_result)
clear_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class active_cluster_args(object):
    """
    Attributes:
     - node_ipaddr

    """


    def __init__(self, node_ipaddr=None,):
        self.node_ipaddr = node_ipaddr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('active_cluster_args')
        if self.node_ipaddr is not None:
            oprot.writeFieldBegin('node_ipaddr', TType.STRING, 1)
            oprot.writeString(self.node_ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.node_ipaddr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(active_cluster_args)
active_cluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ipaddr', 'UTF8', None, ),  # 1
)


class active_cluster_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('active_cluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(active_cluster_result)
active_cluster_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_node_args(object):
    """
    Attributes:
     - host

    """


    def __init__(self, host=None,):
        self.host = host

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_node_args')
        if self.host is not None:
            oprot.writeFieldBegin('host', TType.STRING, 1)
            oprot.writeString(self.host.encode('utf-8') if sys.version_info[0] == 2 else self.host)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_node_args)
add_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'host', 'UTF8', None, ),  # 1
)


class add_node_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_node_result)
add_node_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_node_args)
del_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class del_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_node_result)
del_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_module_status_args(object):
    """
    Attributes:
     - module_name

    """


    def __init__(self, module_name=None,):
        self.module_name = module_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.module_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_module_status_args')
        if self.module_name is not None:
            oprot.writeFieldBegin('module_name', TType.STRING, 1)
            oprot.writeString(self.module_name.encode('utf-8') if sys.version_info[0] == 2 else self.module_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_module_status_args)
get_module_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'module_name', 'UTF8', None, ),  # 1
)


class get_module_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_module_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_module_status_result)
get_module_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_module_args(object):
    """
    Attributes:
     - module_name

    """


    def __init__(self, module_name=None,):
        self.module_name = module_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.module_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_module_args')
        if self.module_name is not None:
            oprot.writeFieldBegin('module_name', TType.STRING, 1)
            oprot.writeString(self.module_name.encode('utf-8') if sys.version_info[0] == 2 else self.module_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_module_args)
enable_module_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'module_name', 'UTF8', None, ),  # 1
)


class enable_module_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_module_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_module_result)
enable_module_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_module_args(object):
    """
    Attributes:
     - module_name

    """


    def __init__(self, module_name=None,):
        self.module_name = module_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.module_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_module_args')
        if self.module_name is not None:
            oprot.writeFieldBegin('module_name', TType.STRING, 1)
            oprot.writeString(self.module_name.encode('utf-8') if sys.version_info[0] == 2 else self.module_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_module_args)
disable_module_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'module_name', 'UTF8', None, ),  # 1
)


class disable_module_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_module_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_module_result)
disable_module_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class create_ecms_db_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_ecms_db_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_ecms_db_args)
create_ecms_db_args.thrift_spec = (
)


class create_ecms_db_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_ecms_db_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_ecms_db_result)
create_ecms_db_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_db_node_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_node_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_node_info_args)
get_db_node_info_args.thrift_spec = (
)


class get_db_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ncTDBNodeInfo()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_node_info_result)
get_db_node_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTDBNodeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_db_master_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_master_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_master_args)
set_db_master_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class set_db_master_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_master_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_master_result)
set_db_master_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_db_slave_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_slave_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_slave_args)
set_db_slave_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class set_db_slave_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_slave_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_slave_result)
set_db_slave_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_db_slave_by_xtrabackup_args(object):
    """
    Attributes:
     - node_uuid
     - slave_ssh_info

    """


    def __init__(self, node_uuid=None, slave_ssh_info=None,):
        self.node_uuid = node_uuid
        self.slave_ssh_info = slave_ssh_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.slave_ssh_info = ECMSAgent.ttypes.ncTSSHInfo()
                    self.slave_ssh_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_slave_by_xtrabackup_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.slave_ssh_info is not None:
            oprot.writeFieldBegin('slave_ssh_info', TType.STRUCT, 2)
            self.slave_ssh_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_slave_by_xtrabackup_args)
set_db_slave_by_xtrabackup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'slave_ssh_info', [ECMSAgent.ttypes.ncTSSHInfo, None], None, ),  # 2
)


class set_db_slave_by_xtrabackup_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_slave_by_xtrabackup_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_slave_by_xtrabackup_result)
set_db_slave_by_xtrabackup_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class cancel_db_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_db_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_db_node_args)
cancel_db_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class cancel_db_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_db_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_db_node_result)
cancel_db_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class update_deployment_mode_args(object):
    """
    Attributes:
     - mode

    """


    def __init__(self, mode=None,):
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mode = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_deployment_mode_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.STRING, 1)
            oprot.writeString(self.mode.encode('utf-8') if sys.version_info[0] == 2 else self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_deployment_mode_args)
update_deployment_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'mode', 'UTF8', None, ),  # 1
)


class update_deployment_mode_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_deployment_mode_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_deployment_mode_result)
update_deployment_mode_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_deployment_mode_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_deployment_mode_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_deployment_mode_args)
get_deployment_mode_args.thrift_spec = (
)


class get_deployment_mode_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_deployment_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_deployment_mode_result)
get_deployment_mode_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class dump_databases_to_path_args(object):
    """
    Attributes:
     - host
     - port
     - db_name
     - path

    """


    def __init__(self, host=None, port=None, db_name=None, path=None,):
        self.host = host
        self.port = port
        self.db_name = db_name
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dump_databases_to_path_args')
        if self.host is not None:
            oprot.writeFieldBegin('host', TType.STRING, 1)
            oprot.writeString(self.host.encode('utf-8') if sys.version_info[0] == 2 else self.host)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 3)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 4)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dump_databases_to_path_args)
dump_databases_to_path_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'host', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'db_name', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'path', 'UTF8', None, ),  # 4
)


class dump_databases_to_path_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dump_databases_to_path_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dump_databases_to_path_result)
dump_databases_to_path_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_databases_name_args(object):
    """
    Attributes:
     - host
     - port

    """


    def __init__(self, host=None, port=None,):
        self.host = host
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_databases_name_args')
        if self.host is not None:
            oprot.writeFieldBegin('host', TType.STRING, 1)
            oprot.writeString(self.host.encode('utf-8') if sys.version_info[0] == 2 else self.host)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_databases_name_args)
get_databases_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'host', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
)


class get_databases_name_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_databases_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter20 in self.success:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_databases_name_result)
get_databases_name_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class purge_binlogs_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('purge_binlogs_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(purge_binlogs_args)
purge_binlogs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class purge_binlogs_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('purge_binlogs_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(purge_binlogs_result)
purge_binlogs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class update_external_db_info_args(object):
    """
    Attributes:
     - info

    """


    def __init__(self, info=None,):
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ECMSAgent.ttypes.ncTExternalDBInfo()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_external_db_info_args')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_external_db_info_args)
update_external_db_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [ECMSAgent.ttypes.ncTExternalDBInfo, None], None, ),  # 1
)


class update_external_db_info_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_external_db_info_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_external_db_info_result)
update_external_db_info_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_external_db_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_external_db_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_external_db_info_args)
get_external_db_info_args.thrift_spec = (
)


class get_external_db_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ECMSAgent.ttypes.ncTExternalDBInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_external_db_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_external_db_info_result)
get_external_db_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ECMSAgent.ttypes.ncTExternalDBInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_external_db_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_external_db_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_external_db_args)
is_external_db_args.thrift_spec = (
)


class is_external_db_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_external_db_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_external_db_result)
is_external_db_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_available_external_db_args(object):
    """
    Attributes:
     - info

    """


    def __init__(self, info=None,):
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = ECMSAgent.ttypes.ncTExternalDBInfo()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_available_external_db_args')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_available_external_db_args)
is_available_external_db_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [ECMSAgent.ttypes.ncTExternalDBInfo, None], None, ),  # 1
)


class is_available_external_db_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_available_external_db_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_available_external_db_result)
is_available_external_db_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_firewall_rule_args(object):
    """
    Attributes:
     - firewall_info

    """


    def __init__(self, firewall_info=None,):
        self.firewall_info = firewall_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.firewall_info = ncTFirewallInfo()
                    self.firewall_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_firewall_rule_args')
        if self.firewall_info is not None:
            oprot.writeFieldBegin('firewall_info', TType.STRUCT, 1)
            self.firewall_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_firewall_rule_args)
add_firewall_rule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'firewall_info', [ncTFirewallInfo, None], None, ),  # 1
)


class add_firewall_rule_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_firewall_rule_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_firewall_rule_result)
add_firewall_rule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_firewall_rule_args(object):
    """
    Attributes:
     - firewall_info

    """


    def __init__(self, firewall_info=None,):
        self.firewall_info = firewall_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.firewall_info = ncTFirewallInfo()
                    self.firewall_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_firewall_rule_args')
        if self.firewall_info is not None:
            oprot.writeFieldBegin('firewall_info', TType.STRUCT, 1)
            self.firewall_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_firewall_rule_args)
del_firewall_rule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'firewall_info', [ncTFirewallInfo, None], None, ),  # 1
)


class del_firewall_rule_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_firewall_rule_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_firewall_rule_result)
del_firewall_rule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class update_firewall_rule_args(object):
    """
    Attributes:
     - old_info
     - new_info

    """


    def __init__(self, old_info=None, new_info=None,):
        self.old_info = old_info
        self.new_info = new_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.old_info = ncTFirewallInfo()
                    self.old_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.new_info = ncTFirewallInfo()
                    self.new_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_firewall_rule_args')
        if self.old_info is not None:
            oprot.writeFieldBegin('old_info', TType.STRUCT, 1)
            self.old_info.write(oprot)
            oprot.writeFieldEnd()
        if self.new_info is not None:
            oprot.writeFieldBegin('new_info', TType.STRUCT, 2)
            self.new_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_firewall_rule_args)
update_firewall_rule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'old_info', [ncTFirewallInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'new_info', [ncTFirewallInfo, None], None, ),  # 2
)


class update_firewall_rule_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_firewall_rule_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_firewall_rule_result)
update_firewall_rule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_firewall_rule_args(object):
    """
    Attributes:
     - sys_role

    """


    def __init__(self, sys_role=None,):
        self.sys_role = sys_role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sys_role = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_firewall_rule_args')
        if self.sys_role is not None:
            oprot.writeFieldBegin('sys_role', TType.STRING, 1)
            oprot.writeString(self.sys_role.encode('utf-8') if sys.version_info[0] == 2 else self.sys_role)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_firewall_rule_args)
get_firewall_rule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sys_role', 'UTF8', None, ),  # 1
)


class get_firewall_rule_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ncTFirewallInfo()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_firewall_rule_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_firewall_rule_result)
get_firewall_rule_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTFirewallInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_firewall_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_firewall_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_firewall_args)
enable_firewall_args.thrift_spec = (
)


class enable_firewall_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_firewall_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_firewall_result)
enable_firewall_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_firewall_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_firewall_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_firewall_args)
disable_firewall_args.thrift_spec = (
)


class disable_firewall_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_firewall_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_firewall_result)
disable_firewall_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_firewall_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_firewall_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_firewall_status_args)
get_firewall_status_args.thrift_spec = (
)


class get_firewall_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_firewall_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_firewall_status_result)
get_firewall_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_sys_service_args(object):
    """
    Attributes:
     - sys_role

    """


    def __init__(self, sys_role=None,):
        self.sys_role = sys_role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sys_role = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_sys_service_args')
        if self.sys_role is not None:
            oprot.writeFieldBegin('sys_role', TType.STRING, 1)
            oprot.writeString(self.sys_role.encode('utf-8') if sys.version_info[0] == 2 else self.sys_role)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_sys_service_args)
enable_sys_service_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sys_role', 'UTF8', None, ),  # 1
)


class enable_sys_service_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_sys_service_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_sys_service_result)
enable_sys_service_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_sys_service_args(object):
    """
    Attributes:
     - sys_role

    """


    def __init__(self, sys_role=None,):
        self.sys_role = sys_role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sys_role = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_sys_service_args')
        if self.sys_role is not None:
            oprot.writeFieldBegin('sys_role', TType.STRING, 1)
            oprot.writeString(self.sys_role.encode('utf-8') if sys.version_info[0] == 2 else self.sys_role)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_sys_service_args)
disable_sys_service_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sys_role', 'UTF8', None, ),  # 1
)


class disable_sys_service_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_sys_service_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_sys_service_result)
disable_sys_service_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_sys_service_status_args(object):
    """
    Attributes:
     - sys_role

    """


    def __init__(self, sys_role=None,):
        self.sys_role = sys_role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sys_role = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sys_service_status_args')
        if self.sys_role is not None:
            oprot.writeFieldBegin('sys_role', TType.STRING, 1)
            oprot.writeString(self.sys_role.encode('utf-8') if sys.version_info[0] == 2 else self.sys_role)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sys_service_status_args)
get_sys_service_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sys_role', 'UTF8', None, ),  # 1
)


class get_sys_service_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sys_service_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sys_service_status_result)
get_sys_service_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_trusted_ip_args(object):
    """
    Attributes:
     - ip_list

    """


    def __init__(self, ip_list=None,):
        self.ip_list = ip_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ip_list = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.ip_list.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_trusted_ip_args')
        if self.ip_list is not None:
            oprot.writeFieldBegin('ip_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.ip_list))
            for iter34 in self.ip_list:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_trusted_ip_args)
add_trusted_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ip_list', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class add_trusted_ip_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_trusted_ip_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_trusted_ip_result)
add_trusted_ip_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_storage_trusted_ip_args(object):
    """
    Attributes:
     - firewall_list

    """


    def __init__(self, firewall_list=None,):
        self.firewall_list = firewall_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.firewall_list = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = ncTFirewallInfo()
                        _elem40.read(iprot)
                        self.firewall_list.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_storage_trusted_ip_args')
        if self.firewall_list is not None:
            oprot.writeFieldBegin('firewall_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.firewall_list))
            for iter41 in self.firewall_list:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_storage_trusted_ip_args)
set_storage_trusted_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'firewall_list', (TType.STRUCT, [ncTFirewallInfo, None], False), None, ),  # 1
)


class set_storage_trusted_ip_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_storage_trusted_ip_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_storage_trusted_ip_result)
set_storage_trusted_ip_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_asu_node_ip_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_asu_node_ip_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_asu_node_ip_args)
get_asu_node_ip_args.thrift_spec = (
)


class get_asu_node_ip_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_asu_node_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter48 in self.success:
                oprot.writeString(iter48.encode('utf-8') if sys.version_info[0] == 2 else iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_asu_node_ip_result)
get_asu_node_ip_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_keepalived_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_keepalived_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_keepalived_status_args)
get_keepalived_status_args.thrift_spec = (
)


class get_keepalived_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_keepalived_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_keepalived_status_result)
get_keepalived_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_keepalived_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_keepalived_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_keepalived_args)
enable_keepalived_args.thrift_spec = (
)


class enable_keepalived_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_keepalived_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_keepalived_result)
enable_keepalived_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_keepalived_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_keepalived_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_keepalived_args)
disable_keepalived_args.thrift_spec = (
)


class disable_keepalived_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_keepalived_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_keepalived_result)
disable_keepalived_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_vip_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_vip_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_vip_info_args)
get_vip_info_args.thrift_spec = (
)


class get_vip_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = ncTVipInfo()
                        _elem54.read(iprot)
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_vip_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter55 in self.success:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_vip_info_result)
get_vip_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTVipInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_vip_info_args(object):
    """
    Attributes:
     - vip_info

    """


    def __init__(self, vip_info=None,):
        self.vip_info = vip_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.vip_info = ncTVipInfo()
                    self.vip_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_vip_info_args')
        if self.vip_info is not None:
            oprot.writeFieldBegin('vip_info', TType.STRUCT, 1)
            self.vip_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_vip_info_args)
set_vip_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'vip_info', [ncTVipInfo, None], None, ),  # 1
)


class set_vip_info_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_vip_info_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_vip_info_result)
set_vip_info_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_ivip_info_args(object):
    """
    Attributes:
     - ivip_info

    """


    def __init__(self, ivip_info=None,):
        self.ivip_info = ivip_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ivip_info = ncTVipInfo()
                    self.ivip_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ivip_info_args')
        if self.ivip_info is not None:
            oprot.writeFieldBegin('ivip_info', TType.STRUCT, 1)
            self.ivip_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ivip_info_args)
set_ivip_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ivip_info', [ncTVipInfo, None], None, ),  # 1
)


class set_ivip_info_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ivip_info_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ivip_info_result)
set_ivip_info_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_ha_node_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_ha_node_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_ha_node_info_args)
get_ha_node_info_args.thrift_spec = (
)


class get_ha_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = ncTHaNodeInfo()
                        _elem61.read(iprot)
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_ha_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter62 in self.success:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_ha_node_info_result)
get_ha_node_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTHaNodeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_ha_master_args(object):
    """
    Attributes:
     - node_uuid
     - vip_info

    """


    def __init__(self, node_uuid=None, vip_info=None,):
        self.node_uuid = node_uuid
        self.vip_info = vip_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.vip_info = ncTVipInfo()
                    self.vip_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ha_master_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.vip_info is not None:
            oprot.writeFieldBegin('vip_info', TType.STRUCT, 2)
            self.vip_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ha_master_args)
set_ha_master_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'vip_info', [ncTVipInfo, None], None, ),  # 2
)


class set_ha_master_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ha_master_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ha_master_result)
set_ha_master_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_ha_slave_args(object):
    """
    Attributes:
     - node_uuid
     - ha_sys

    """


    def __init__(self, node_uuid=None, ha_sys=None,):
        self.node_uuid = node_uuid
        self.ha_sys = ha_sys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.ha_sys = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ha_slave_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.ha_sys is not None:
            oprot.writeFieldBegin('ha_sys', TType.I32, 2)
            oprot.writeI32(self.ha_sys)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ha_slave_args)
set_ha_slave_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'ha_sys', None, None, ),  # 2
)


class set_ha_slave_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_ha_slave_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_ha_slave_result)
set_ha_slave_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class cancel_ha_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_ha_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_ha_node_args)
cancel_ha_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class cancel_ha_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_ha_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_ha_node_result)
cancel_ha_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_db_ha_master_args(object):
    """
    Attributes:
     - ivip_info

    """


    def __init__(self, ivip_info=None,):
        self.ivip_info = ivip_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ivip_info = ncTVipInfo()
                    self.ivip_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_ha_master_args')
        if self.ivip_info is not None:
            oprot.writeFieldBegin('ivip_info', TType.STRUCT, 1)
            self.ivip_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_ha_master_args)
set_db_ha_master_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ivip_info', [ncTVipInfo, None], None, ),  # 1
)


class set_db_ha_master_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_ha_master_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_ha_master_result)
set_db_ha_master_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_db_ha_slave_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_ha_slave_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_ha_slave_args)
set_db_ha_slave_args.thrift_spec = (
)


class set_db_ha_slave_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_db_ha_slave_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_db_ha_slave_result)
set_db_ha_slave_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class cancel_db_ha_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_db_ha_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_db_ha_node_args)
cancel_db_ha_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class cancel_db_ha_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancel_db_ha_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancel_db_ha_node_result)
cancel_db_ha_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class on_lvs_changed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_lvs_changed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_lvs_changed_args)
on_lvs_changed_args.thrift_spec = (
)


class on_lvs_changed_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_lvs_changed_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_lvs_changed_result)
on_lvs_changed_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class on_node_entering_master_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_node_entering_master_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_node_entering_master_args)
on_node_entering_master_args.thrift_spec = (
)


class on_node_entering_master_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_node_entering_master_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_node_entering_master_result)
on_node_entering_master_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class on_node_entering_slave_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_node_entering_slave_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_node_entering_slave_args)
on_node_entering_slave_args.thrift_spec = (
)


class on_node_entering_slave_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_node_entering_slave_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_node_entering_slave_result)
on_node_entering_slave_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class force_enter_master_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('force_enter_master_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(force_enter_master_args)
force_enter_master_args.thrift_spec = (
)


class force_enter_master_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('force_enter_master_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(force_enter_master_result)
force_enter_master_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_node_info_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_info_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_info_args)
get_node_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTNodeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_info_result)
get_node_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTNodeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_all_node_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_node_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_node_info_args)
get_all_node_info_args.thrift_spec = (
)


class get_all_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = ncTNodeInfo()
                        _elem68.read(iprot)
                        self.success.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter69 in self.success:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_node_info_result)
get_all_node_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTNodeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_node_alias_args(object):
    """
    Attributes:
     - node_uuid
     - node_alias

    """


    def __init__(self, node_uuid=None, node_alias=None,):
        self.node_uuid = node_uuid
        self.node_alias = node_alias

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.node_alias = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_node_alias_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.node_alias is not None:
            oprot.writeFieldBegin('node_alias', TType.STRING, 2)
            oprot.writeString(self.node_alias.encode('utf-8') if sys.version_info[0] == 2 else self.node_alias)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_node_alias_args)
set_node_alias_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'node_alias', 'UTF8', None, ),  # 2
)


class set_node_alias_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_node_alias_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_node_alias_result)
set_node_alias_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class restart_eisooapp_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restart_eisooapp_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restart_eisooapp_args)
restart_eisooapp_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class restart_eisooapp_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restart_eisooapp_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restart_eisooapp_result)
restart_eisooapp_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class reboot_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reboot_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reboot_node_args)
reboot_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class reboot_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reboot_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reboot_node_result)
reboot_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class shutdown_cluster_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_cluster_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_cluster_args)
shutdown_cluster_args.thrift_spec = (
)


class shutdown_cluster_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_cluster_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_cluster_result)
shutdown_cluster_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_cluster_time_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_time_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_time_args)
get_cluster_time_args.thrift_spec = (
)


class get_cluster_time_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_time_result)
get_cluster_time_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_cluster_time_args(object):
    """
    Attributes:
     - datetime

    """


    def __init__(self, datetime=None,):
        self.datetime = datetime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.datetime = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cluster_time_args')
        if self.datetime is not None:
            oprot.writeFieldBegin('datetime', TType.STRING, 1)
            oprot.writeString(self.datetime.encode('utf-8') if sys.version_info[0] == 2 else self.datetime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cluster_time_args)
set_cluster_time_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'datetime', 'UTF8', None, ),  # 1
)


class set_cluster_time_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_cluster_time_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_cluster_time_result)
set_cluster_time_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_cluster_version_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_version_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_version_args)
get_cluster_version_args.thrift_spec = (
)


class get_cluster_version_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_version_result)
get_cluster_version_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_cluster_uuid_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_uuid_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_uuid_args)
get_cluster_uuid_args.thrift_spec = (
)


class get_cluster_uuid_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_uuid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_uuid_result)
get_cluster_uuid_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_log_server_args(object):
    """
    Attributes:
     - facility
     - severity
     - ip
     - port
     - protocol

    """


    def __init__(self, facility=None, severity=None, ip=None, port=None, protocol=None,):
        self.facility = facility
        self.severity = severity
        self.ip = ip
        self.port = port
        self.protocol = protocol

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.facility = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.severity = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.protocol = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_log_server_args')
        if self.facility is not None:
            oprot.writeFieldBegin('facility', TType.STRING, 1)
            oprot.writeString(self.facility.encode('utf-8') if sys.version_info[0] == 2 else self.facility)
            oprot.writeFieldEnd()
        if self.severity is not None:
            oprot.writeFieldBegin('severity', TType.STRING, 2)
            oprot.writeString(self.severity.encode('utf-8') if sys.version_info[0] == 2 else self.severity)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 3)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 4)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.protocol is not None:
            oprot.writeFieldBegin('protocol', TType.STRING, 5)
            oprot.writeString(self.protocol.encode('utf-8') if sys.version_info[0] == 2 else self.protocol)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_log_server_args)
add_log_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'facility', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'severity', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'ip', 'UTF8', None, ),  # 3
    (4, TType.I32, 'port', None, None, ),  # 4
    (5, TType.STRING, 'protocol', 'UTF8', None, ),  # 5
)


class add_log_server_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_log_server_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_log_server_result)
add_log_server_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class delete_log_server_args(object):
    """
    Attributes:
     - facility
     - severity
     - ip
     - port
     - protocol

    """


    def __init__(self, facility=None, severity=None, ip=None, port=None, protocol=None,):
        self.facility = facility
        self.severity = severity
        self.ip = ip
        self.port = port
        self.protocol = protocol

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.facility = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.severity = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.protocol = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_log_server_args')
        if self.facility is not None:
            oprot.writeFieldBegin('facility', TType.STRING, 1)
            oprot.writeString(self.facility.encode('utf-8') if sys.version_info[0] == 2 else self.facility)
            oprot.writeFieldEnd()
        if self.severity is not None:
            oprot.writeFieldBegin('severity', TType.STRING, 2)
            oprot.writeString(self.severity.encode('utf-8') if sys.version_info[0] == 2 else self.severity)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 3)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 4)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.protocol is not None:
            oprot.writeFieldBegin('protocol', TType.STRING, 5)
            oprot.writeString(self.protocol.encode('utf-8') if sys.version_info[0] == 2 else self.protocol)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_log_server_args)
delete_log_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'facility', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'severity', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'ip', 'UTF8', None, ),  # 3
    (4, TType.I32, 'port', None, None, ),  # 4
    (5, TType.STRING, 'protocol', 'UTF8', None, ),  # 5
)


class delete_log_server_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_log_server_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_log_server_result)
delete_log_server_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_upload_log_args(object):
    """
    Attributes:
     - datetime

    """


    def __init__(self, datetime=None,):
        self.datetime = datetime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.datetime = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_upload_log_args')
        if self.datetime is not None:
            oprot.writeFieldBegin('datetime', TType.STRING, 1)
            oprot.writeString(self.datetime.encode('utf-8') if sys.version_info[0] == 2 else self.datetime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_upload_log_args)
enable_upload_log_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'datetime', 'UTF8', None, ),  # 1
)


class enable_upload_log_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_upload_log_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_upload_log_result)
enable_upload_log_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_upload_log_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_upload_log_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_upload_log_args)
disable_upload_log_args.thrift_spec = (
)


class disable_upload_log_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_upload_log_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_upload_log_result)
disable_upload_log_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_upload_log_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_upload_log_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_upload_log_status_args)
get_upload_log_status_args.thrift_spec = (
)


class get_upload_log_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_upload_log_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_upload_log_status_result)
get_upload_log_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_upload_log_server_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_upload_log_server_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_upload_log_server_args)
get_upload_log_server_args.thrift_spec = (
)


class get_upload_log_server_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = ECMSAgent.ttypes.ncTLogHostInfo()
                        _elem75.read(iprot)
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_upload_log_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter76 in self.success:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_upload_log_server_result)
get_upload_log_server_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ECMSAgent.ttypes.ncTLogHostInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_upload_log_time_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_upload_log_time_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_upload_log_time_args)
get_upload_log_time_args.thrift_spec = (
)


class get_upload_log_time_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_upload_log_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_upload_log_time_result)
get_upload_log_time_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_all_nics_name_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_nics_name_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_nics_name_args)
get_all_nics_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_all_nics_name_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_nics_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter83 in self.success:
                oprot.writeString(iter83.encode('utf-8') if sys.version_info[0] == 2 else iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_nics_name_result)
get_all_nics_name_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_cpu_usage_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cpu_usage_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cpu_usage_args)
get_cpu_usage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_cpu_usage_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cpu_usage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cpu_usage_result)
get_cpu_usage_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_memory_info_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_memory_info_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_memory_info_args)
get_memory_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_memory_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype85, _vtype86, _size84) = iprot.readMapBegin()
                    for _i88 in range(_size84):
                        _key89 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val90 = iprot.readI64()
                        self.success[_key89] = _val90
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_memory_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter91, viter92 in self.success.items():
                oprot.writeString(kiter91.encode('utf-8') if sys.version_info[0] == 2 else kiter91)
                oprot.writeI64(viter92)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_memory_info_result)
get_memory_info_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_network_outgoing_rate_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_network_outgoing_rate_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_network_outgoing_rate_args)
get_network_outgoing_rate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_network_outgoing_rate_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_network_outgoing_rate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_network_outgoing_rate_result)
get_network_outgoing_rate_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_network_incoming_rate_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_network_incoming_rate_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_network_incoming_rate_args)
get_network_incoming_rate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_network_incoming_rate_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_network_incoming_rate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_network_incoming_rate_result)
get_network_incoming_rate_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class troubleshoot_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('troubleshoot_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(troubleshoot_args)
troubleshoot_args.thrift_spec = (
)


class troubleshoot_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('troubleshoot_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(troubleshoot_result)
troubleshoot_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class consistency_repair_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('consistency_repair_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(consistency_repair_args)
consistency_repair_args.thrift_spec = (
)


class consistency_repair_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('consistency_repair_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(consistency_repair_result)
consistency_repair_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class consistency_check_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('consistency_check_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(consistency_check_args)
consistency_check_args.thrift_spec = (
)


class consistency_check_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('consistency_check_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(consistency_check_result)
consistency_check_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class on_node_heartbeat_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_node_heartbeat_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_node_heartbeat_args)
on_node_heartbeat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class on_node_heartbeat_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_node_heartbeat_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_node_heartbeat_result)
on_node_heartbeat_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class on_change_node_ip_args(object):
    """
    Attributes:
     - old_ip
     - new_ip
     - update_db_host

    """


    def __init__(self, old_ip=None, new_ip=None, update_db_host=None,):
        self.old_ip = old_ip
        self.new_ip = new_ip
        self.update_db_host = update_db_host

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.old_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.new_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.update_db_host = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_change_node_ip_args')
        if self.old_ip is not None:
            oprot.writeFieldBegin('old_ip', TType.STRING, 1)
            oprot.writeString(self.old_ip.encode('utf-8') if sys.version_info[0] == 2 else self.old_ip)
            oprot.writeFieldEnd()
        if self.new_ip is not None:
            oprot.writeFieldBegin('new_ip', TType.STRING, 2)
            oprot.writeString(self.new_ip.encode('utf-8') if sys.version_info[0] == 2 else self.new_ip)
            oprot.writeFieldEnd()
        if self.update_db_host is not None:
            oprot.writeFieldBegin('update_db_host', TType.BOOL, 3)
            oprot.writeBool(self.update_db_host)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_change_node_ip_args)
on_change_node_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'old_ip', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'new_ip', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'update_db_host', None, None, ),  # 3
)


class on_change_node_ip_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('on_change_node_ip_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(on_change_node_ip_result)
on_change_node_ip_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_raid_manager_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_raid_manager_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_raid_manager_args)
enable_raid_manager_args.thrift_spec = (
)


class enable_raid_manager_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_raid_manager_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_raid_manager_result)
enable_raid_manager_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_raid_manager_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_raid_manager_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_raid_manager_args)
disable_raid_manager_args.thrift_spec = (
)


class disable_raid_manager_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_raid_manager_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_raid_manager_result)
disable_raid_manager_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_raid_manager_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_manager_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_manager_status_args)
get_raid_manager_status_args.thrift_spec = (
)


class get_raid_manager_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_manager_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_manager_status_result)
get_raid_manager_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_available_of_raid_manager_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_available_of_raid_manager_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_available_of_raid_manager_args)
is_available_of_raid_manager_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class is_available_of_raid_manager_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_available_of_raid_manager_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_available_of_raid_manager_result)
is_available_of_raid_manager_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class exist_iscsi_device_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exist_iscsi_device_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exist_iscsi_device_args)
exist_iscsi_device_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class exist_iscsi_device_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exist_iscsi_device_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exist_iscsi_device_result)
exist_iscsi_device_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_free_data_disks_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_free_data_disks_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_free_data_disks_args)
get_free_data_disks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_free_data_disks_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype94, _vtype95, _size93) = iprot.readMapBegin()
                    for _i97 in range(_size93):
                        _key98 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val99 = ECMSAgent.ttypes.ncTDataDisk()
                        _val99.read(iprot)
                        self.success[_key98] = _val99
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_free_data_disks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter100, viter101 in self.success.items():
                oprot.writeString(kiter100.encode('utf-8') if sys.version_info[0] == 2 else kiter100)
                viter101.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_free_data_disks_result)
get_free_data_disks_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTDataDisk, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class init_storage_pool_args(object):
    """
    Attributes:
     - replicas

    """


    def __init__(self, replicas=None,):
        self.replicas = replicas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.replicas = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_storage_pool_args')
        if self.replicas is not None:
            oprot.writeFieldBegin('replicas', TType.I32, 1)
            oprot.writeI32(self.replicas)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_storage_pool_args)
init_storage_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'replicas', None, None, ),  # 1
)


class init_storage_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_storage_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_storage_pool_result)
init_storage_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_storage_pool_inited_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_storage_pool_inited_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_storage_pool_inited_args)
is_storage_pool_inited_args.thrift_spec = (
)


class is_storage_pool_inited_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_storage_pool_inited_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_storage_pool_inited_result)
is_storage_pool_inited_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_pool_args(object):
    """
    Attributes:
     - include_used_size

    """


    def __init__(self, include_used_size=None,):
        self.include_used_size = include_used_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.include_used_size = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_pool_args')
        if self.include_used_size is not None:
            oprot.writeFieldBegin('include_used_size', TType.BOOL, 1)
            oprot.writeBool(self.include_used_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_pool_args)
get_storage_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'include_used_size', None, None, ),  # 1
)


class get_storage_pool_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTStoragePool()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_pool_result)
get_storage_pool_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTStoragePool, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_pool_devices_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_pool_devices_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_pool_devices_args)
get_storage_pool_devices_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_storage_pool_devices_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype103, _vtype104, _size102) = iprot.readMapBegin()
                    for _i106 in range(_size102):
                        _key107 = iprot.readI32()
                        _val108 = ncTStoragePoolDevice()
                        _val108.read(iprot)
                        self.success[_key107] = _val108
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_pool_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.success))
            for kiter109, viter110 in self.success.items():
                oprot.writeI32(kiter109)
                viter110.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_pool_devices_result)
get_storage_pool_devices_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.STRUCT, [ncTStoragePoolDevice, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_pool_swift_devices_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_pool_swift_devices_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_pool_swift_devices_args)
get_storage_pool_swift_devices_args.thrift_spec = (
)


class get_storage_pool_swift_devices_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                    for _i115 in range(_size111):
                        _key116 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val117 = {}
                        (_ktype119, _vtype120, _size118) = iprot.readMapBegin()
                        for _i122 in range(_size118):
                            _key123 = iprot.readI32()
                            _val124 = ECMSAgent.ttypes.ncTSwiftDevice()
                            _val124.read(iprot)
                            _val117[_key123] = _val124
                        iprot.readMapEnd()
                        self.success[_key116] = _val117
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_pool_swift_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
            for kiter125, viter126 in self.success.items():
                oprot.writeString(kiter125.encode('utf-8') if sys.version_info[0] == 2 else kiter125)
                oprot.writeMapBegin(TType.I32, TType.STRUCT, len(viter126))
                for kiter127, viter128 in viter126.items():
                    oprot.writeI32(kiter127)
                    viter128.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_pool_swift_devices_result)
get_storage_pool_swift_devices_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.MAP, (TType.I32, None, TType.STRUCT, [ECMSAgent.ttypes.ncTSwiftDevice, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_devices_to_pool_args(object):
    """
    Attributes:
     - disk_dev_paths

    """


    def __init__(self, disk_dev_paths=None,):
        self.disk_dev_paths = disk_dev_paths

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.disk_dev_paths = {}
                    (_ktype130, _vtype131, _size129) = iprot.readMapBegin()
                    for _i133 in range(_size129):
                        _key134 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val135 = []
                        (_etype139, _size136) = iprot.readListBegin()
                        for _i140 in range(_size136):
                            _elem141 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val135.append(_elem141)
                        iprot.readListEnd()
                        self.disk_dev_paths[_key134] = _val135
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_devices_to_pool_args')
        if self.disk_dev_paths is not None:
            oprot.writeFieldBegin('disk_dev_paths', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.disk_dev_paths))
            for kiter142, viter143 in self.disk_dev_paths.items():
                oprot.writeString(kiter142.encode('utf-8') if sys.version_info[0] == 2 else kiter142)
                oprot.writeListBegin(TType.STRING, len(viter143))
                for iter144 in viter143:
                    oprot.writeString(iter144.encode('utf-8') if sys.version_info[0] == 2 else iter144)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_devices_to_pool_args)
add_devices_to_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'disk_dev_paths', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 1
)


class add_devices_to_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_devices_to_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_devices_to_pool_result)
add_devices_to_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_node_devices_to_pool_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_node_devices_to_pool_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_node_devices_to_pool_args)
add_node_devices_to_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class add_node_devices_to_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_node_devices_to_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_node_devices_to_pool_result)
add_node_devices_to_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_maintenance_of_devices_args(object):
    """
    Attributes:
     - dev_uuids

    """


    def __init__(self, dev_uuids=None,):
        self.dev_uuids = dev_uuids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dev_uuids = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.dev_uuids.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_maintenance_of_devices_args')
        if self.dev_uuids is not None:
            oprot.writeFieldBegin('dev_uuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.dev_uuids))
            for iter151 in self.dev_uuids:
                oprot.writeString(iter151.encode('utf-8') if sys.version_info[0] == 2 else iter151)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_maintenance_of_devices_args)
get_maintenance_of_devices_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dev_uuids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_maintenance_of_devices_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = iprot.readBool()
                        self.success.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_maintenance_of_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BOOL, len(self.success))
            for iter158 in self.success:
                oprot.writeBool(iter158)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_maintenance_of_devices_result)
get_maintenance_of_devices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BOOL, None, False), None, ),  # 0
)


class enable_maintenance_of_devices_args(object):
    """
    Attributes:
     - dev_uuids

    """


    def __init__(self, dev_uuids=None,):
        self.dev_uuids = dev_uuids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dev_uuids = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.dev_uuids.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_maintenance_of_devices_args')
        if self.dev_uuids is not None:
            oprot.writeFieldBegin('dev_uuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.dev_uuids))
            for iter165 in self.dev_uuids:
                oprot.writeString(iter165.encode('utf-8') if sys.version_info[0] == 2 else iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_maintenance_of_devices_args)
enable_maintenance_of_devices_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dev_uuids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class enable_maintenance_of_devices_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_maintenance_of_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter172 in self.success:
                oprot.writeString(iter172.encode('utf-8') if sys.version_info[0] == 2 else iter172)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_maintenance_of_devices_result)
enable_maintenance_of_devices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class disable_maintenance_of_devices_args(object):
    """
    Attributes:
     - dev_uuids

    """


    def __init__(self, dev_uuids=None,):
        self.dev_uuids = dev_uuids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dev_uuids = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.dev_uuids.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_maintenance_of_devices_args')
        if self.dev_uuids is not None:
            oprot.writeFieldBegin('dev_uuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.dev_uuids))
            for iter179 in self.dev_uuids:
                oprot.writeString(iter179.encode('utf-8') if sys.version_info[0] == 2 else iter179)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_maintenance_of_devices_args)
disable_maintenance_of_devices_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dev_uuids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class disable_maintenance_of_devices_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_maintenance_of_devices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter186 in self.success:
                oprot.writeString(iter186.encode('utf-8') if sys.version_info[0] == 2 else iter186)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_maintenance_of_devices_result)
disable_maintenance_of_devices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_free_data_disks_for_replace_args(object):
    """
    Attributes:
     - dev_id

    """


    def __init__(self, dev_id=None,):
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_free_data_disks_for_replace_args')
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 1)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_free_data_disks_for_replace_args)
get_free_data_disks_for_replace_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev_id', None, None, ),  # 1
)


class get_free_data_disks_for_replace_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype188, _vtype189, _size187) = iprot.readMapBegin()
                    for _i191 in range(_size187):
                        _key192 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val193 = ECMSAgent.ttypes.ncTDataDisk()
                        _val193.read(iprot)
                        self.success[_key192] = _val193
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_free_data_disks_for_replace_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter194, viter195 in self.success.items():
                oprot.writeString(kiter194.encode('utf-8') if sys.version_info[0] == 2 else kiter194)
                viter195.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_free_data_disks_for_replace_result)
get_free_data_disks_for_replace_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTDataDisk, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class replace_device_in_pool_args(object):
    """
    Attributes:
     - dev_id
     - disk_dev_path

    """


    def __init__(self, dev_id=None, disk_dev_path=None,):
        self.dev_id = dev_id
        self.disk_dev_path = disk_dev_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.disk_dev_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replace_device_in_pool_args')
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 1)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.disk_dev_path is not None:
            oprot.writeFieldBegin('disk_dev_path', TType.STRING, 2)
            oprot.writeString(self.disk_dev_path.encode('utf-8') if sys.version_info[0] == 2 else self.disk_dev_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replace_device_in_pool_args)
replace_device_in_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev_id', None, None, ),  # 1
    (2, TType.STRING, 'disk_dev_path', 'UTF8', None, ),  # 2
)


class replace_device_in_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replace_device_in_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replace_device_in_pool_result)
replace_device_in_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class remove_device_from_pool_args(object):
    """
    Attributes:
     - dev_id

    """


    def __init__(self, dev_id=None,):
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_device_from_pool_args')
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 1)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_device_from_pool_args)
remove_device_from_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev_id', None, None, ),  # 1
)


class remove_device_from_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_device_from_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_device_from_pool_result)
remove_device_from_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class remove_node_devices_from_pool_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_node_devices_from_pool_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_node_devices_from_pool_args)
remove_node_devices_from_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class remove_node_devices_from_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_node_devices_from_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_node_devices_from_pool_result)
remove_node_devices_from_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class rebalance_storage_pool_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rebalance_storage_pool_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rebalance_storage_pool_args)
rebalance_storage_pool_args.thrift_spec = (
)


class rebalance_storage_pool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rebalance_storage_pool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rebalance_storage_pool_result)
rebalance_storage_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class change_replicas_args(object):
    """
    Attributes:
     - replicas

    """


    def __init__(self, replicas=None,):
        self.replicas = replicas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.replicas = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('change_replicas_args')
        if self.replicas is not None:
            oprot.writeFieldBegin('replicas', TType.I32, 1)
            oprot.writeI32(self.replicas)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(change_replicas_args)
change_replicas_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'replicas', None, None, ),  # 1
)


class change_replicas_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('change_replicas_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(change_replicas_result)
change_replicas_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_replicas_health_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_replicas_health_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_replicas_health_args)
get_replicas_health_args.thrift_spec = (
)


class get_replicas_health_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_replicas_health_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_replicas_health_result)
get_replicas_health_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_all_data_raid_pds_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_data_raid_pds_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_data_raid_pds_args)
get_all_data_raid_pds_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_all_data_raid_pds_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype197, _vtype198, _size196) = iprot.readMapBegin()
                    for _i200 in range(_size196):
                        _key201 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val202 = ECMSAgent.ttypes.ncTRaidPDInfo()
                        _val202.read(iprot)
                        self.success[_key201] = _val202
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_data_raid_pds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter203, viter204 in self.success.items():
                oprot.writeString(kiter203.encode('utf-8') if sys.version_info[0] == 2 else kiter203)
                viter204.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_data_raid_pds_result)
get_all_data_raid_pds_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidPDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_free_data_raid_pds_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_free_data_raid_pds_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_free_data_raid_pds_args)
get_free_data_raid_pds_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_free_data_raid_pds_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype206, _vtype207, _size205) = iprot.readMapBegin()
                    for _i209 in range(_size205):
                        _key210 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val211 = ECMSAgent.ttypes.ncTRaidPDInfo()
                        _val211.read(iprot)
                        self.success[_key210] = _val211
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_free_data_raid_pds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter212, viter213 in self.success.items():
                oprot.writeString(kiter212.encode('utf-8') if sys.version_info[0] == 2 else kiter212)
                viter213.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_free_data_raid_pds_result)
get_free_data_raid_pds_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidPDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_raid_pds_in_storage_pool_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_pds_in_storage_pool_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_pds_in_storage_pool_args)
get_raid_pds_in_storage_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_raid_pds_in_storage_pool_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype215, _vtype216, _size214) = iprot.readMapBegin()
                    for _i218 in range(_size214):
                        _key219 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val220 = ECMSAgent.ttypes.ncTRaidPDInfo()
                        _val220.read(iprot)
                        self.success[_key219] = _val220
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_pds_in_storage_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter221, viter222 in self.success.items():
                oprot.writeString(kiter221.encode('utf-8') if sys.version_info[0] == 2 else kiter221)
                viter222.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_pds_in_storage_pool_result)
get_raid_pds_in_storage_pool_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidPDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_sys_raid_pds_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sys_raid_pds_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sys_raid_pds_args)
get_sys_raid_pds_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_sys_raid_pds_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype224, _vtype225, _size223) = iprot.readMapBegin()
                    for _i227 in range(_size223):
                        _key228 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val229 = ECMSAgent.ttypes.ncTRaidPDInfo()
                        _val229.read(iprot)
                        self.success[_key228] = _val229
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sys_raid_pds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter230, viter231 in self.success.items():
                oprot.writeString(kiter230.encode('utf-8') if sys.version_info[0] == 2 else kiter230)
                viter231.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sys_raid_pds_result)
get_sys_raid_pds_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidPDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_all_raid_lds_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_raid_lds_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_raid_lds_args)
get_all_raid_lds_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_all_raid_lds_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype233, _vtype234, _size232) = iprot.readMapBegin()
                    for _i236 in range(_size232):
                        _key237 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val238 = ECMSAgent.ttypes.ncTRaidLDInfo()
                        _val238.read(iprot)
                        self.success[_key237] = _val238
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_raid_lds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter239, viter240 in self.success.items():
                oprot.writeString(kiter239.encode('utf-8') if sys.version_info[0] == 2 else kiter239)
                viter240.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_raid_lds_result)
get_all_raid_lds_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidLDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_raid_pd_details_args(object):
    """
    Attributes:
     - node_ip
     - pd_devid

    """


    def __init__(self, node_ip=None, pd_devid=None,):
        self.node_ip = node_ip
        self.pd_devid = pd_devid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pd_devid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_pd_details_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        if self.pd_devid is not None:
            oprot.writeFieldBegin('pd_devid', TType.STRING, 2)
            oprot.writeString(self.pd_devid.encode('utf-8') if sys.version_info[0] == 2 else self.pd_devid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_pd_details_args)
get_raid_pd_details_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pd_devid', 'UTF8', None, ),  # 2
)


class get_raid_pd_details_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype242, _vtype243, _size241) = iprot.readMapBegin()
                    for _i245 in range(_size241):
                        _key246 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val247 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key246] = _val247
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_pd_details_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter248, viter249 in self.success.items():
                oprot.writeString(kiter248.encode('utf-8') if sys.version_info[0] == 2 else kiter248)
                oprot.writeString(viter249.encode('utf-8') if sys.version_info[0] == 2 else viter249)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_pd_details_result)
get_raid_pd_details_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_raid_ld_details_args(object):
    """
    Attributes:
     - node_ip
     - ld_devid

    """


    def __init__(self, node_ip=None, ld_devid=None,):
        self.node_ip = node_ip
        self.ld_devid = ld_devid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ld_devid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_ld_details_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        if self.ld_devid is not None:
            oprot.writeFieldBegin('ld_devid', TType.STRING, 2)
            oprot.writeString(self.ld_devid.encode('utf-8') if sys.version_info[0] == 2 else self.ld_devid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_ld_details_args)
get_raid_ld_details_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ld_devid', 'UTF8', None, ),  # 2
)


class get_raid_ld_details_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype251, _vtype252, _size250) = iprot.readMapBegin()
                    for _i254 in range(_size250):
                        _key255 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val256 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key255] = _val256
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_ld_details_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter257, viter258 in self.success.items():
                oprot.writeString(kiter257.encode('utf-8') if sys.version_info[0] == 2 else kiter257)
                oprot.writeString(viter258.encode('utf-8') if sys.version_info[0] == 2 else viter258)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_ld_details_result)
get_raid_ld_details_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class init_free_data_raid_pds_args(object):
    """
    Attributes:
     - node_ip
     - pd_devids
     - bond_disks_num

    """


    def __init__(self, node_ip=None, pd_devids=None, bond_disks_num=None,):
        self.node_ip = node_ip
        self.pd_devids = pd_devids
        self.bond_disks_num = bond_disks_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.pd_devids = []
                    (_etype262, _size259) = iprot.readListBegin()
                    for _i263 in range(_size259):
                        _elem264 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.pd_devids.append(_elem264)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.bond_disks_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_free_data_raid_pds_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        if self.pd_devids is not None:
            oprot.writeFieldBegin('pd_devids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.pd_devids))
            for iter265 in self.pd_devids:
                oprot.writeString(iter265.encode('utf-8') if sys.version_info[0] == 2 else iter265)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bond_disks_num is not None:
            oprot.writeFieldBegin('bond_disks_num', TType.I32, 3)
            oprot.writeI32(self.bond_disks_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_free_data_raid_pds_args)
init_free_data_raid_pds_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'pd_devids', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'bond_disks_num', None, None, ),  # 3
)


class init_free_data_raid_pds_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype267, _vtype268, _size266) = iprot.readMapBegin()
                    for _i270 in range(_size266):
                        _key271 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val272 = ECMSAgent.ttypes.ncTRaidLDInfo()
                        _val272.read(iprot)
                        self.success[_key271] = _val272
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_free_data_raid_pds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter273, viter274 in self.success.items():
                oprot.writeString(kiter273.encode('utf-8') if sys.version_info[0] == 2 else kiter273)
                viter274.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_free_data_raid_pds_result)
init_free_data_raid_pds_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidLDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_raid_hotspare_args(object):
    """
    Attributes:
     - node_ip
     - pd_devid
     - ld_devid

    """


    def __init__(self, node_ip=None, pd_devid=None, ld_devid=None,):
        self.node_ip = node_ip
        self.pd_devid = pd_devid
        self.ld_devid = ld_devid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pd_devid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ld_devid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_raid_hotspare_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        if self.pd_devid is not None:
            oprot.writeFieldBegin('pd_devid', TType.STRING, 2)
            oprot.writeString(self.pd_devid.encode('utf-8') if sys.version_info[0] == 2 else self.pd_devid)
            oprot.writeFieldEnd()
        if self.ld_devid is not None:
            oprot.writeFieldBegin('ld_devid', TType.STRING, 3)
            oprot.writeString(self.ld_devid.encode('utf-8') if sys.version_info[0] == 2 else self.ld_devid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_raid_hotspare_args)
add_raid_hotspare_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pd_devid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'ld_devid', 'UTF8', None, ),  # 3
)


class add_raid_hotspare_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_raid_hotspare_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_raid_hotspare_result)
add_raid_hotspare_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class remove_raid_hotspare_args(object):
    """
    Attributes:
     - node_ip
     - pd_devid

    """


    def __init__(self, node_ip=None, pd_devid=None,):
        self.node_ip = node_ip
        self.pd_devid = pd_devid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pd_devid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_raid_hotspare_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        if self.pd_devid is not None:
            oprot.writeFieldBegin('pd_devid', TType.STRING, 2)
            oprot.writeString(self.pd_devid.encode('utf-8') if sys.version_info[0] == 2 else self.pd_devid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_raid_hotspare_args)
remove_raid_hotspare_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pd_devid', 'UTF8', None, ),  # 2
)


class remove_raid_hotspare_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_raid_hotspare_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_raid_hotspare_result)
remove_raid_hotspare_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_raid_lds_for_hotspare_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_lds_for_hotspare_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_lds_for_hotspare_args)
get_raid_lds_for_hotspare_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_raid_lds_for_hotspare_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype276, _vtype277, _size275) = iprot.readMapBegin()
                    for _i279 in range(_size275):
                        _key280 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val281 = ECMSAgent.ttypes.ncTRaidLDInfo()
                        _val281.read(iprot)
                        self.success[_key280] = _val281
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_raid_lds_for_hotspare_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter282, viter283 in self.success.items():
                oprot.writeString(kiter282.encode('utf-8') if sys.version_info[0] == 2 else kiter282)
                viter283.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_raid_lds_for_hotspare_result)
get_raid_lds_for_hotspare_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTRaidLDInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class create_cache_volume_args(object):
    """
    Attributes:
     - node_uuid
     - disk_dev_path

    """


    def __init__(self, node_uuid=None, disk_dev_path=None,):
        self.node_uuid = node_uuid
        self.disk_dev_path = disk_dev_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.disk_dev_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_cache_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.disk_dev_path is not None:
            oprot.writeFieldBegin('disk_dev_path', TType.STRING, 2)
            oprot.writeString(self.disk_dev_path.encode('utf-8') if sys.version_info[0] == 2 else self.disk_dev_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_cache_volume_args)
create_cache_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'disk_dev_path', 'UTF8', None, ),  # 2
)


class create_cache_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_cache_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_cache_volume_result)
create_cache_volume_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class remove_cache_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_cache_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_cache_volume_args)
remove_cache_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class remove_cache_volume_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_cache_volume_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_cache_volume_result)
remove_cache_volume_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_cache_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cache_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cache_volume_args)
get_cache_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_cache_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ECMSAgent.ttypes.ncTVolume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cache_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cache_volume_result)
get_cache_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ECMSAgent.ttypes.ncTVolume, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class init_cache_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_cache_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_cache_volume_args)
init_cache_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class init_cache_volume_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_cache_volume_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_cache_volume_result)
init_cache_volume_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_cache_volume_inited_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_cache_volume_inited_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_cache_volume_inited_args)
is_cache_volume_inited_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class is_cache_volume_inited_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_cache_volume_inited_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_cache_volume_inited_result)
is_cache_volume_inited_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class mount_cache_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mount_cache_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mount_cache_volume_args)
mount_cache_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class mount_cache_volume_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mount_cache_volume_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mount_cache_volume_result)
mount_cache_volume_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class allocate_cache_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('allocate_cache_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(allocate_cache_volume_args)
allocate_cache_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class allocate_cache_volume_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('allocate_cache_volume_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(allocate_cache_volume_result)
allocate_cache_volume_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_sys_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sys_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sys_volume_args)
get_sys_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_sys_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ECMSAgent.ttypes.ncTVolume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sys_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sys_volume_result)
get_sys_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ECMSAgent.ttypes.ncTVolume, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_sysvol_volume_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sysvol_volume_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sysvol_volume_args)
get_sysvol_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_sysvol_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ECMSAgent.ttypes.ncTVolume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sysvol_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sysvol_volume_result)
get_sysvol_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ECMSAgent.ttypes.ncTVolume, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_disk_info_args(object):
    """
    Attributes:
     - node_uuid
     - dev_path

    """


    def __init__(self, node_uuid=None, dev_path=None,):
        self.node_uuid = node_uuid
        self.dev_path = dev_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dev_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_disk_info_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.dev_path is not None:
            oprot.writeFieldBegin('dev_path', TType.STRING, 2)
            oprot.writeString(self.dev_path.encode('utf-8') if sys.version_info[0] == 2 else self.dev_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_disk_info_args)
get_disk_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dev_path', 'UTF8', None, ),  # 2
)


class get_disk_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype285, _vtype286, _size284) = iprot.readMapBegin()
                    for _i288 in range(_size284):
                        _key289 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val290 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key289] = _val290
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_disk_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter291, viter292 in self.success.items():
                oprot.writeString(kiter291.encode('utf-8') if sys.version_info[0] == 2 else kiter291)
                oprot.writeString(viter292.encode('utf-8') if sys.version_info[0] == 2 else viter292)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_disk_info_result)
get_disk_info_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_data_disks_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_disks_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_disks_args)
get_data_disks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_data_disks_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype294, _vtype295, _size293) = iprot.readMapBegin()
                    for _i297 in range(_size293):
                        _key298 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val299 = ECMSAgent.ttypes.ncTDataDisk()
                        _val299.read(iprot)
                        self.success[_key298] = _val299
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_disks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter300, viter301 in self.success.items():
                oprot.writeString(kiter300.encode('utf-8') if sys.version_info[0] == 2 else kiter300)
                viter301.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_disks_result)
get_data_disks_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ECMSAgent.ttypes.ncTDataDisk, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_console_address_args(object):
    """
    Attributes:
     - storage_server_name

    """


    def __init__(self, storage_server_name=None,):
        self.storage_server_name = storage_server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storage_server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_console_address_args')
        if self.storage_server_name is not None:
            oprot.writeFieldBegin('storage_server_name', TType.STRING, 1)
            oprot.writeString(self.storage_server_name.encode('utf-8') if sys.version_info[0] == 2 else self.storage_server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_console_address_args)
get_storage_console_address_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storage_server_name', 'UTF8', None, ),  # 1
)


class get_storage_console_address_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_console_address_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_console_address_result)
get_storage_console_address_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_local_ceph_storage_info_args(object):
    """
    Attributes:
     - storage_server_name

    """


    def __init__(self, storage_server_name=None,):
        self.storage_server_name = storage_server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.storage_server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_local_ceph_storage_info_args')
        if self.storage_server_name is not None:
            oprot.writeFieldBegin('storage_server_name', TType.STRING, 1)
            oprot.writeString(self.storage_server_name.encode('utf-8') if sys.version_info[0] == 2 else self.storage_server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_local_ceph_storage_info_args)
get_local_ceph_storage_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'storage_server_name', 'UTF8', None, ),  # 1
)


class get_local_ceph_storage_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTCephStorageInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_local_ceph_storage_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_local_ceph_storage_info_result)
get_local_ceph_storage_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTCephStorageInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_local_ceph_manage_vip_args(object):
    """
    Attributes:
     - ceph_manage_vip

    """


    def __init__(self, ceph_manage_vip=None,):
        self.ceph_manage_vip = ceph_manage_vip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ceph_manage_vip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_local_ceph_manage_vip_args')
        if self.ceph_manage_vip is not None:
            oprot.writeFieldBegin('ceph_manage_vip', TType.STRING, 1)
            oprot.writeString(self.ceph_manage_vip.encode('utf-8') if sys.version_info[0] == 2 else self.ceph_manage_vip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_local_ceph_manage_vip_args)
set_local_ceph_manage_vip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ceph_manage_vip', 'UTF8', None, ),  # 1
)


class set_local_ceph_manage_vip_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_local_ceph_manage_vip_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_local_ceph_manage_vip_result)
set_local_ceph_manage_vip_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_local_ceph_manage_vip_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_local_ceph_manage_vip_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_local_ceph_manage_vip_args)
get_local_ceph_manage_vip_args.thrift_spec = (
)


class get_local_ceph_manage_vip_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_local_ceph_manage_vip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_local_ceph_manage_vip_result)
get_local_ceph_manage_vip_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_zabbix_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_zabbix_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_zabbix_status_args)
get_zabbix_status_args.thrift_spec = (
)


class get_zabbix_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_zabbix_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_zabbix_status_result)
get_zabbix_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_zabbix_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_zabbix_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_zabbix_args)
enable_zabbix_args.thrift_spec = (
)


class enable_zabbix_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_zabbix_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_zabbix_result)
enable_zabbix_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_zabbix_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_zabbix_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_zabbix_args)
disable_zabbix_args.thrift_spec = (
)


class disable_zabbix_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_zabbix_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_zabbix_result)
disable_zabbix_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_alert_trigger_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_alert_trigger_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_alert_trigger_status_args)
get_alert_trigger_status_args.thrift_spec = (
)


class get_alert_trigger_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype303, _vtype304, _size302) = iprot.readMapBegin()
                    for _i306 in range(_size302):
                        _key307 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val308 = iprot.readI32()
                        self.success[_key307] = _val308
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_alert_trigger_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
            for kiter309, viter310 in self.success.items():
                oprot.writeString(kiter309.encode('utf-8') if sys.version_info[0] == 2 else kiter309)
                oprot.writeI32(viter310)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_alert_trigger_status_result)
get_alert_trigger_status_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_alert_enable_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_alert_enable_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_alert_enable_args)
is_alert_enable_args.thrift_spec = (
)


class is_alert_enable_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_alert_enable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_alert_enable_result)
is_alert_enable_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_alert_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_alert_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_alert_args)
enable_alert_args.thrift_spec = (
)


class enable_alert_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_alert_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_alert_result)
enable_alert_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_alert_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_alert_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_alert_args)
disable_alert_args.thrift_spec = (
)


class disable_alert_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_alert_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_alert_result)
disable_alert_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_maintenance_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_maintenance_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_maintenance_args)
enable_maintenance_args.thrift_spec = (
)


class enable_maintenance_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_maintenance_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_maintenance_result)
enable_maintenance_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_maintenance_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_maintenance_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_maintenance_args)
disable_maintenance_args.thrift_spec = (
)


class disable_maintenance_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_maintenance_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_maintenance_result)
disable_maintenance_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_maintenance_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_maintenance_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_maintenance_status_args)
get_maintenance_status_args.thrift_spec = (
)


class get_maintenance_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_maintenance_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_maintenance_status_result)
get_maintenance_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_service_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_service_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_service_problem_records_args)
get_service_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_service_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = ncTMonitorProblemRecord()
                        _elem316.read(iprot)
                        self.success.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_service_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter317 in self.success:
                iter317.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_service_problem_records_result)
get_service_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_database_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_database_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_database_problem_records_args)
get_database_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_database_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype321, _size318) = iprot.readListBegin()
                    for _i322 in range(_size318):
                        _elem323 = ncTMonitorProblemRecord()
                        _elem323.read(iprot)
                        self.success.append(_elem323)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_database_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter324 in self.success:
                iter324.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_database_problem_records_result)
get_database_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_cpu_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - threshold
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, threshold=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.threshold = threshold
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.threshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cpu_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.threshold is not None:
            oprot.writeFieldBegin('threshold', TType.DOUBLE, 2)
            oprot.writeDouble(self.threshold)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 3)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 4)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cpu_problem_records_args)
get_cpu_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'threshold', None, None, ),  # 2
    (3, TType.I32, 'time_from', None, None, ),  # 3
    (4, TType.I32, 'time_till', None, None, ),  # 4
)


class get_cpu_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype328, _size325) = iprot.readListBegin()
                    for _i329 in range(_size325):
                        _elem330 = ncTMonitorProblemRecord()
                        _elem330.read(iprot)
                        self.success.append(_elem330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cpu_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter331 in self.success:
                iter331.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cpu_problem_records_result)
get_cpu_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_sysvol_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sysvol_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sysvol_problem_records_args)
get_sysvol_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_sysvol_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype335, _size332) = iprot.readListBegin()
                    for _i336 in range(_size332):
                        _elem337 = ncTMonitorProblemRecord()
                        _elem337.read(iprot)
                        self.success.append(_elem337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sysvol_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter338 in self.success:
                iter338.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sysvol_problem_records_result)
get_sysvol_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_memory_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - threshold
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, threshold=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.threshold = threshold
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.threshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_memory_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.threshold is not None:
            oprot.writeFieldBegin('threshold', TType.DOUBLE, 2)
            oprot.writeDouble(self.threshold)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 3)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 4)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_memory_problem_records_args)
get_memory_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'threshold', None, None, ),  # 2
    (3, TType.I32, 'time_from', None, None, ),  # 3
    (4, TType.I32, 'time_till', None, None, ),  # 4
)


class get_memory_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype342, _size339) = iprot.readListBegin()
                    for _i343 in range(_size339):
                        _elem344 = ncTMonitorProblemRecord()
                        _elem344.read(iprot)
                        self.success.append(_elem344)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_memory_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter345 in self.success:
                iter345.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_memory_problem_records_result)
get_memory_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_self_backup_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_self_backup_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_self_backup_problem_records_args)
get_self_backup_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_self_backup_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype349, _size346) = iprot.readListBegin()
                    for _i350 in range(_size346):
                        _elem351 = ncTMonitorProblemRecord()
                        _elem351.read(iprot)
                        self.success.append(_elem351)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_self_backup_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter352 in self.success:
                iter352.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_self_backup_problem_records_result)
get_self_backup_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_node_online_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_online_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_online_problem_records_args)
get_node_online_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_node_online_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = ncTMonitorProblemRecord()
                        _elem358.read(iprot)
                        self.success.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_online_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter359 in self.success:
                iter359.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_online_problem_records_result)
get_node_online_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_node_switch_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_switch_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_switch_problem_records_args)
get_node_switch_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_node_switch_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype363, _size360) = iprot.readListBegin()
                    for _i364 in range(_size360):
                        _elem365 = ncTMonitorProblemRecord()
                        _elem365.read(iprot)
                        self.success.append(_elem365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_switch_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter366 in self.success:
                iter366.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_switch_problem_records_result)
get_node_switch_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_replicas_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_replicas_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_replicas_problem_records_args)
get_replicas_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_replicas_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype370, _size367) = iprot.readListBegin()
                    for _i371 in range(_size367):
                        _elem372 = ncTMonitorProblemRecord()
                        _elem372.read(iprot)
                        self.success.append(_elem372)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_replicas_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter373 in self.success:
                iter373.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_replicas_problem_records_result)
get_replicas_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_dev_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_dev_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_dev_problem_records_args)
get_storage_dev_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_storage_dev_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype377, _size374) = iprot.readListBegin()
                    for _i378 in range(_size374):
                        _elem379 = ncTMonitorProblemRecord()
                        _elem379.read(iprot)
                        self.success.append(_elem379)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_dev_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter380 in self.success:
                iter380.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_dev_problem_records_result)
get_storage_dev_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_balance_problem_records_args(object):
    """
    Attributes:
     - ipaddr
     - time_from
     - time_till

    """


    def __init__(self, ipaddr=None, time_from=None, time_till=None,):
        self.ipaddr = ipaddr
        self.time_from = time_from
        self.time_till = time_till

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ipaddr = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_from = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time_till = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_balance_problem_records_args')
        if self.ipaddr is not None:
            oprot.writeFieldBegin('ipaddr', TType.STRING, 1)
            oprot.writeString(self.ipaddr.encode('utf-8') if sys.version_info[0] == 2 else self.ipaddr)
            oprot.writeFieldEnd()
        if self.time_from is not None:
            oprot.writeFieldBegin('time_from', TType.I32, 2)
            oprot.writeI32(self.time_from)
            oprot.writeFieldEnd()
        if self.time_till is not None:
            oprot.writeFieldBegin('time_till', TType.I32, 3)
            oprot.writeI32(self.time_till)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_balance_problem_records_args)
get_balance_problem_records_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ipaddr', 'UTF8', None, ),  # 1
    (2, TType.I32, 'time_from', None, None, ),  # 2
    (3, TType.I32, 'time_till', None, None, ),  # 3
)


class get_balance_problem_records_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype384, _size381) = iprot.readListBegin()
                    for _i385 in range(_size381):
                        _elem386 = ncTMonitorProblemRecord()
                        _elem386.read(iprot)
                        self.success.append(_elem386)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_balance_problem_records_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter387 in self.success:
                iter387.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_balance_problem_records_result)
get_balance_problem_records_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTMonitorProblemRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_storage_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_storage_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_storage_node_args)
add_storage_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class add_storage_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_storage_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_storage_node_result)
add_storage_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_storage_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_storage_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_storage_node_args)
del_storage_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class del_storage_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_storage_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_storage_node_result)
del_storage_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_node_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_node_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_node_info_args)
get_storage_node_info_args.thrift_spec = (
)


class get_storage_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype391, _size388) = iprot.readListBegin()
                    for _i392 in range(_size388):
                        _elem393 = ncTStorageNodeInfo()
                        _elem393.read(iprot)
                        self.success.append(_elem393)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter394 in self.success:
                iter394.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_node_info_result)
get_storage_node_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTStorageNodeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_storage_master_node_ip_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_master_node_ip_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_master_node_ip_args)
get_storage_master_node_ip_args.thrift_spec = (
)


class get_storage_master_node_ip_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_master_node_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_master_node_ip_result)
get_storage_master_node_ip_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_storage_lvs_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_storage_lvs_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_storage_lvs_args)
enable_storage_lvs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class enable_storage_lvs_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_storage_lvs_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_storage_lvs_result)
enable_storage_lvs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_storage_lvs_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_storage_lvs_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_storage_lvs_args)
disable_storage_lvs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class disable_storage_lvs_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_storage_lvs_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_storage_lvs_result)
disable_storage_lvs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_application_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_application_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_application_node_args)
add_application_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class add_application_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_application_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_application_node_result)
add_application_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_application_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_application_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_application_node_args)
del_application_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class del_application_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_application_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_application_node_result)
del_application_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_app_node_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_node_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_node_info_args)
get_app_node_info_args.thrift_spec = (
)


class get_app_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype398, _size395) = iprot.readListBegin()
                    for _i399 in range(_size395):
                        _elem400 = ncTAppNodeInfo()
                        _elem400.read(iprot)
                        self.success.append(_elem400)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter401 in self.success:
                iter401.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_node_info_result)
get_app_node_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTAppNodeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_app_master_node_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_master_node_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_master_node_info_args)
get_app_master_node_info_args.thrift_spec = (
)


class get_app_master_node_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTAppNodeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_master_node_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_master_node_info_result)
get_app_master_node_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTAppNodeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_app_master_node_ip_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_master_node_ip_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_master_node_ip_args)
get_app_master_node_ip_args.thrift_spec = (
)


class get_app_master_node_ip_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_master_node_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_master_node_ip_result)
get_app_master_node_ip_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_app_lvs_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_app_lvs_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_app_lvs_args)
enable_app_lvs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class enable_app_lvs_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_app_lvs_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_app_lvs_result)
enable_app_lvs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_app_lvs_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_app_lvs_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_app_lvs_args)
disable_app_lvs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class disable_app_lvs_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_app_lvs_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_app_lvs_result)
disable_app_lvs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_application_service_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_application_service_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_application_service_args)
get_application_service_args.thrift_spec = (
)


class get_application_service_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype405, _size402) = iprot.readListBegin()
                    for _i406 in range(_size402):
                        _elem407 = ncTAppServiceInfo()
                        _elem407.read(iprot)
                        self.success.append(_elem407)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_application_service_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter408 in self.success:
                iter408.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_application_service_result)
get_application_service_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTAppServiceInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_application_service_args(object):
    """
    Attributes:
     - service_name
     - port
     - is_lvs

    """


    def __init__(self, service_name=None, port=None, is_lvs=None,):
        self.service_name = service_name
        self.port = port
        self.is_lvs = is_lvs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.service_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_lvs = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_application_service_args')
        if self.service_name is not None:
            oprot.writeFieldBegin('service_name', TType.STRING, 1)
            oprot.writeString(self.service_name.encode('utf-8') if sys.version_info[0] == 2 else self.service_name)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.is_lvs is not None:
            oprot.writeFieldBegin('is_lvs', TType.BOOL, 3)
            oprot.writeBool(self.is_lvs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_application_service_args)
add_application_service_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'service_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.BOOL, 'is_lvs', None, None, ),  # 3
)


class add_application_service_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_application_service_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_application_service_result)
add_application_service_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_application_service_args(object):
    """
    Attributes:
     - service_name

    """


    def __init__(self, service_name=None,):
        self.service_name = service_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.service_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_application_service_args')
        if self.service_name is not None:
            oprot.writeFieldBegin('service_name', TType.STRING, 1)
            oprot.writeString(self.service_name.encode('utf-8') if sys.version_info[0] == 2 else self.service_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_application_service_args)
del_application_service_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'service_name', 'UTF8', None, ),  # 1
)


class del_application_service_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_application_service_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_application_service_result)
del_application_service_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_service_status_args(object):
    """
    Attributes:
     - node_uuid
     - service_name

    """


    def __init__(self, node_uuid=None, service_name=None,):
        self.node_uuid = node_uuid
        self.service_name = service_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.service_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_service_status_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.service_name is not None:
            oprot.writeFieldBegin('service_name', TType.STRING, 2)
            oprot.writeString(self.service_name.encode('utf-8') if sys.version_info[0] == 2 else self.service_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_service_status_args)
get_service_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'service_name', 'UTF8', None, ),  # 2
)


class get_service_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_service_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_service_status_result)
get_service_status_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class is_app_registered_args(object):
    """
    Attributes:
     - app_name

    """


    def __init__(self, app_name=None,):
        self.app_name = app_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.app_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_app_registered_args')
        if self.app_name is not None:
            oprot.writeFieldBegin('app_name', TType.STRING, 1)
            oprot.writeString(self.app_name.encode('utf-8') if sys.version_info[0] == 2 else self.app_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_app_registered_args)
is_app_registered_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'app_name', 'UTF8', None, ),  # 1
)


class is_app_registered_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_app_registered_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_app_registered_result)
is_app_registered_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_single_application_node_args(object):
    """
    Attributes:
     - node_uuid
     - app_name

    """


    def __init__(self, node_uuid=None, app_name=None,):
        self.node_uuid = node_uuid
        self.app_name = app_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.app_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_single_application_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        if self.app_name is not None:
            oprot.writeFieldBegin('app_name', TType.STRING, 2)
            oprot.writeString(self.app_name.encode('utf-8') if sys.version_info[0] == 2 else self.app_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_single_application_node_args)
add_single_application_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'app_name', 'UTF8', None, ),  # 2
)


class add_single_application_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_single_application_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_single_application_node_result)
add_single_application_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_single_application_node_args(object):
    """
    Attributes:
     - app_name

    """


    def __init__(self, app_name=None,):
        self.app_name = app_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.app_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_single_application_node_args')
        if self.app_name is not None:
            oprot.writeFieldBegin('app_name', TType.STRING, 1)
            oprot.writeString(self.app_name.encode('utf-8') if sys.version_info[0] == 2 else self.app_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_single_application_node_args)
del_single_application_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'app_name', 'UTF8', None, ),  # 1
)


class del_single_application_node_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_single_application_node_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_single_application_node_result)
del_single_application_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_single_application_service_by_node_args(object):
    """
    Attributes:
     - node_uuid

    """


    def __init__(self, node_uuid=None,):
        self.node_uuid = node_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_single_application_service_by_node_args')
        if self.node_uuid is not None:
            oprot.writeFieldBegin('node_uuid', TType.STRING, 1)
            oprot.writeString(self.node_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.node_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_single_application_service_by_node_args)
get_single_application_service_by_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_uuid', 'UTF8', None, ),  # 1
)


class get_single_application_service_by_node_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype412, _size409) = iprot.readListBegin()
                    for _i413 in range(_size409):
                        _elem414 = ncTAppServiceInfo()
                        _elem414.read(iprot)
                        self.success.append(_elem414)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_single_application_service_by_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter415 in self.success:
                iter415.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_single_application_service_by_node_result)
get_single_application_service_by_node_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTAppServiceInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_node_uuid_by_app_name_args(object):
    """
    Attributes:
     - app_name

    """


    def __init__(self, app_name=None,):
        self.app_name = app_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.app_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_uuid_by_app_name_args')
        if self.app_name is not None:
            oprot.writeFieldBegin('app_name', TType.STRING, 1)
            oprot.writeString(self.app_name.encode('utf-8') if sys.version_info[0] == 2 else self.app_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_uuid_by_app_name_args)
get_node_uuid_by_app_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'app_name', 'UTF8', None, ),  # 1
)


class get_node_uuid_by_app_name_result(object):
    """
    Attributes:
     - success
     - ex

    """


    def __init__(self, success=None, ex=None,):
        self.success = success
        self.ex = ex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ex = EThriftException.ttypes.ncTException()
                    self.ex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_uuid_by_app_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ex is not None:
            oprot.writeFieldBegin('ex', TType.STRUCT, 1)
            self.ex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_uuid_by_app_name_result)
get_node_uuid_by_app_name_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ex', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_app_host_ip_args(object):
    """
    Attributes:
     - app_name

    """


    def __init__(self, app_name=None,):
        self.app_name = app_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.app_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_host_ip_args')
        if self.app_name is not None:
            oprot.writeFieldBegin('app_name', TType.STRING, 1)
            oprot.writeString(self.app_name.encode('utf-8') if sys.version_info[0] == 2 else self.app_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_host_ip_args)
get_app_host_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'app_name', 'UTF8', None, ),  # 1
)


class get_app_host_ip_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_app_host_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_app_host_ip_result)
get_app_host_ip_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class verify_sign_in_args(object):
    """
    Attributes:
     - user
     - password

    """


    def __init__(self, user=None, password=None,):
        self.user = user
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_sign_in_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_sign_in_args)
verify_sign_in_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)


class verify_sign_in_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_sign_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_sign_in_result)
verify_sign_in_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class app_sys_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('app_sys_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(app_sys_status_args)
app_sys_status_args.thrift_spec = (
)


class app_sys_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('app_sys_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(app_sys_status_result)
app_sys_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class update_password_args(object):
    """
    Attributes:
     - uuid
     - password

    """


    def __init__(self, uuid=None, password=None,):
        self.uuid = uuid
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_password_args')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 1)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_password_args)
update_password_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)


class update_password_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_password_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_password_result)
update_password_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class update_user_name_args(object):
    """
    Attributes:
     - uuid
     - user_name

    """


    def __init__(self, uuid=None, user_name=None,):
        self.uuid = uuid
        self.user_name = user_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_user_name_args')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 1)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 2)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_user_name_args)
update_user_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_name', 'UTF8', None, ),  # 2
)


class update_user_name_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_user_name_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_user_name_result)
update_user_name_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class commit_conf_file_args(object):
    """
    Attributes:
     - conf_file_path
     - source_file_path

    """


    def __init__(self, conf_file_path=None, source_file_path=None,):
        self.conf_file_path = conf_file_path
        self.source_file_path = source_file_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.conf_file_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_file_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_conf_file_args')
        if self.conf_file_path is not None:
            oprot.writeFieldBegin('conf_file_path', TType.STRING, 1)
            oprot.writeString(self.conf_file_path.encode('utf-8') if sys.version_info[0] == 2 else self.conf_file_path)
            oprot.writeFieldEnd()
        if self.source_file_path is not None:
            oprot.writeFieldBegin('source_file_path', TType.STRING, 2)
            oprot.writeString(self.source_file_path.encode('utf-8') if sys.version_info[0] == 2 else self.source_file_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_conf_file_args)
commit_conf_file_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'conf_file_path', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'source_file_path', 'UTF8', None, ),  # 2
)


class commit_conf_file_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_conf_file_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_conf_file_result)
commit_conf_file_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class commit_conf_file_content_args(object):
    """
    Attributes:
     - conf_file_path
     - file_content

    """


    def __init__(self, conf_file_path=None, file_content=None,):
        self.conf_file_path = conf_file_path
        self.file_content = file_content

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.conf_file_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_content = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_conf_file_content_args')
        if self.conf_file_path is not None:
            oprot.writeFieldBegin('conf_file_path', TType.STRING, 1)
            oprot.writeString(self.conf_file_path.encode('utf-8') if sys.version_info[0] == 2 else self.conf_file_path)
            oprot.writeFieldEnd()
        if self.file_content is not None:
            oprot.writeFieldBegin('file_content', TType.STRING, 2)
            oprot.writeString(self.file_content.encode('utf-8') if sys.version_info[0] == 2 else self.file_content)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_conf_file_content_args)
commit_conf_file_content_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'conf_file_path', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'file_content', 'UTF8', None, ),  # 2
)


class commit_conf_file_content_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_conf_file_content_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_conf_file_content_result)
commit_conf_file_content_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class delete_conf_file_args(object):
    """
    Attributes:
     - conf_file_path

    """


    def __init__(self, conf_file_path=None,):
        self.conf_file_path = conf_file_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.conf_file_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_conf_file_args')
        if self.conf_file_path is not None:
            oprot.writeFieldBegin('conf_file_path', TType.STRING, 1)
            oprot.writeString(self.conf_file_path.encode('utf-8') if sys.version_info[0] == 2 else self.conf_file_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_conf_file_args)
delete_conf_file_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'conf_file_path', 'UTF8', None, ),  # 1
)


class delete_conf_file_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_conf_file_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_conf_file_result)
delete_conf_file_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_commited_conf_files_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_commited_conf_files_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_commited_conf_files_args)
get_commited_conf_files_args.thrift_spec = (
)


class get_commited_conf_files_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype417, _vtype418, _size416) = iprot.readMapBegin()
                    for _i420 in range(_size416):
                        _key421 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val422 = ncTConfFileInfo()
                        _val422.read(iprot)
                        self.success[_key421] = _val422
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_commited_conf_files_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter423, viter424 in self.success.items():
                oprot.writeString(kiter423.encode('utf-8') if sys.version_info[0] == 2 else kiter423)
                viter424.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_commited_conf_files_result)
get_commited_conf_files_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ncTConfFileInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class set_dns_server_args(object):
    """
    Attributes:
     - nameservers

    """


    def __init__(self, nameservers=None,):
        self.nameservers = nameservers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nameservers = []
                    (_etype428, _size425) = iprot.readListBegin()
                    for _i429 in range(_size425):
                        _elem430 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.nameservers.append(_elem430)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_dns_server_args')
        if self.nameservers is not None:
            oprot.writeFieldBegin('nameservers', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.nameservers))
            for iter431 in self.nameservers:
                oprot.writeString(iter431.encode('utf-8') if sys.version_info[0] == 2 else iter431)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_dns_server_args)
set_dns_server_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nameservers', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class set_dns_server_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_dns_server_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_dns_server_result)
set_dns_server_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_dns_server_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dns_server_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dns_server_args)
get_dns_server_args.thrift_spec = (
)


class get_dns_server_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype435, _size432) = iprot.readListBegin()
                    for _i436 in range(_size432):
                        _elem437 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem437)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dns_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter438 in self.success:
                oprot.writeString(iter438.encode('utf-8') if sys.version_info[0] == 2 else iter438)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dns_server_result)
get_dns_server_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_chrony_status_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_chrony_status_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_chrony_status_args)
get_chrony_status_args.thrift_spec = (
)


class get_chrony_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_chrony_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_chrony_status_result)
get_chrony_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class disable_chrony_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_chrony_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_chrony_args)
disable_chrony_args.thrift_spec = (
)


class disable_chrony_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_chrony_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_chrony_result)
disable_chrony_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class enable_chrony_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_chrony_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_chrony_args)
enable_chrony_args.thrift_spec = (
)


class enable_chrony_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_chrony_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_chrony_result)
enable_chrony_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class add_time_server_args(object):
    """
    Attributes:
     - server

    """


    def __init__(self, server=None,):
        self.server = server

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_time_server_args')
        if self.server is not None:
            oprot.writeFieldBegin('server', TType.STRING, 1)
            oprot.writeString(self.server.encode('utf-8') if sys.version_info[0] == 2 else self.server)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_time_server_args)
add_time_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server', 'UTF8', None, ),  # 1
)


class add_time_server_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_time_server_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_time_server_result)
add_time_server_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class del_time_server_args(object):
    """
    Attributes:
     - server

    """


    def __init__(self, server=None,):
        self.server = server

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_time_server_args')
        if self.server is not None:
            oprot.writeFieldBegin('server', TType.STRING, 1)
            oprot.writeString(self.server.encode('utf-8') if sys.version_info[0] == 2 else self.server)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_time_server_args)
del_time_server_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server', 'UTF8', None, ),  # 1
)


class del_time_server_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_time_server_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_time_server_result)
del_time_server_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_time_server_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_time_server_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_time_server_args)
get_time_server_args.thrift_spec = (
)


class get_time_server_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype442, _size439) = iprot.readListBegin()
                    for _i443 in range(_size439):
                        _elem444 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem444)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_time_server_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter445 in self.success:
                oprot.writeString(iter445.encode('utf-8') if sys.version_info[0] == 2 else iter445)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_time_server_result)
get_time_server_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class install_service_args(object):
    """
    Attributes:
     - server_name

    """


    def __init__(self, server_name=None,):
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('install_service_args')
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 1)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(install_service_args)
install_service_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server_name', 'UTF8', None, ),  # 1
)


class install_service_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('install_service_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(install_service_result)
install_service_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class uninstall_service_args(object):
    """
    Attributes:
     - server_name

    """


    def __init__(self, server_name=None,):
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('uninstall_service_args')
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 1)
            oprot.writeString(self.server_name.encode('utf-8') if sys.version_info[0] == 2 else self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(uninstall_service_args)
uninstall_service_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'server_name', 'UTF8', None, ),  # 1
)


class uninstall_service_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('uninstall_service_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(uninstall_service_result)
uninstall_service_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class get_node_service_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_service_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_service_args)
get_node_service_args.thrift_spec = (
)


class get_node_service_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype449, _size446) = iprot.readListBegin()
                    for _i450 in range(_size446):
                        _elem451 = ncTNodeServer()
                        _elem451.read(iprot)
                        self.success.append(_elem451)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_service_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter452 in self.success:
                iter452.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_service_result)
get_node_service_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTNodeServer, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

