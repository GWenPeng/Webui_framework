#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def EACP_GetOnlineUserCount(self):
        """
        获取eacp的用户在线数

        @ret: 返回在线用户数
        @throw EThriftException.ncTException

        """
        pass

    def EACP_GetTenantOnlineUserCount(self, orgId):
        """
        获取eacp的用户租户在线数

        @ret: 返回在线用户数
        @throw EThriftException.ncTException

        Parameters:
         - orgId

        """
        pass

    def EACP_OnDeleteUser(self, userId):
        """
        删除用户时，删除用户文档，该用户对应的权限配置，该用户的token信息，所有者信息

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EACP_OnDeleteGroup(self, groupId):
        """
        删除用户组时

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - groupId

        """
        pass

    def EACP_OnDeleteDepartment(self, departmentIds):
        """
        删除部门时通知eacp删除权限

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - departmentIds

        """
        pass

    def EACP_ClearPermOutOfScope(self):
        """
        清除超出共享范围的权限配置

        @ret: 无返回
        @throw EThriftException.ncTException

        """
        pass

    def EACP_ClearLinkOutOfScope(self):
        """
        清除未开启外链共享用户或部门的外链共享信息

        @ret: 无返回
        @throw EThriftException.ncTException

        """
        pass

    def EACP_ClearFindOutOfScope(self):
        """
        清除未开启发现共享用户或部门的发现共享信息

        @ret: 无返回
        @throw EThriftException.ncTException

        """
        pass

    def EACP_GetLicenseInfo(self, license):
        """
        获取注册码模块信息

        @param license:          注册码
        @return:                 注册码对应的模块信息

        Parameters:
         - license

        """
        pass

    def EACP_VerifyActiveCode(self, license, machineCode, activeCode):
        """
        验证离线激活码是否正确

        @param license:          注册码
        @param machineCode:      机器码
        @param activeCode:       激活码
        @return:                 激活结果,0:成功

        Parameters:
         - license
         - machineCode
         - activeCode

        """
        pass

    def EACP_GetAutolockConfig(self):
        """
        获取自动锁配置

        """
        pass

    def EACP_SetAutolockConfig(self, config):
        """
        设置自动锁配置

        Parameters:
         - config

        """
        pass

    def EACP_GetDevicesByUserId(self, userId, start, limit):
        """
        获取用户的设备信息
        @param userId:           用户id
        @paeam start:            起始索引
        @param limit             获取设备信息条数
        @ret:                    用户的登录设备信息
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - start
         - limit

        """
        pass

    def EACP_AddDevice(self, userId, udid, osType):
        """
        添加设备信息
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @param osType:           设备类型 0：Unknown, 1：IOS, 2：Android, 4：Windows, 5：MacOSX
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid
         - osType

        """
        pass

    def EACP_AddDevices(self, userId, udids, osType):
        """
        添加设备信息
        @param userId            用户id
        @param udids:            设备唯一标识码
        @param osType            操作系统类型 0：Unknown, 1：IOS, 2：Android, 4：Windows, 5：MacOSX
        @ret:                    添加失败的设备mac地址
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udids
         - osType

        """
        pass

    def EACP_SearchDevicesByUserIdAndUdid(self, userId, udid, start, limit):
        """
        获取用户的指定设备信息
        @param userId:           用户id
        @param udid:             设备唯一标识号
        @param start:            起始索引
        @param limit             获取设备信息条数
        @param ret:              用户的指定设备信息
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid
         - start
         - limit

        """
        pass

    def EACP_SearchDevices(self, key, start, limit):
        """
        通过部分udid字符获取可能的设备标识号
        @param key:              设备识别号关键字
        @param start:            起始索引
        @param limit             获取设备信息条数
        @param ret:              设备唯一标识号
        @throw EThriftException.ncTException

        Parameters:
         - key
         - start
         - limit

        """
        pass

    def EACP_SearchUserByDeviceUdid(self, udid, start, limit):
        """
        获取绑定了此设备的用户
        @param udid:             设备唯一标识号
        @param start:            起始索引
        @param limit             获取设备信息条数
        @ret:                    用户名列表
        @throw EThriftException.ncTException

        Parameters:
         - udid
         - start
         - limit

        """
        pass

    def EACP_DeleteDevices(self, userId, udids):
        """
        删除设备信息
        @param userId:           用户id
        @param udids:            设备唯一标识码；如果为空，删除用户的所有设备
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udids

        """
        pass

    def EACP_BindDevice(self, userId, udid):
        """
        绑定设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        pass

    def EACP_UnbindDevice(self, userId, udid):
        """
        解绑设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        pass

    def EACP_EnableDevice(self, userId, udid):
        """
        启用设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        pass

    def EACP_DisableDevice(self, userId, udid):
        """
        禁用设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        pass

    def EACP_SetPermConfigs(self, docId, permConfigs):
        """
        配置GNS路径的权限信息，注意不要包含继承的权限
        会自动分析差异，然后进行权限配置
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - docId
         - permConfigs

        """
        pass

    def EACP_ClearTokenByUserId(self, userId):
        """
        清空用户当前的所有token信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EACP_OnProcessChange(self, processId):
        """
        流程变更时，通知eacp删除对应的申请记录
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - processId

        """
        pass

    def EACP_ClearAllToken(self):
        """
        清空所有用户token信息
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_UpdateAllTokenFlagByOsType(self, osType):
        """
        管理员禁止指定设备登录时, 更新所有token flag信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - osType

        """
        pass

    def EACP_UpdateAllTokenFlagByIdcardStatus(self):
        """
        管理员禁止身份证号登录时, 更新相关token flag信息
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_CheckTokenId(self, tokenInfo):
        """
        检查用户tokenid接口
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - tokenInfo

        """
        pass

    def EACP_ClearAllInvitationInfo(self):
        """
        清空所有用户共享邀请链接
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_ClearUserInvitationInfo(self, userId):
        """
        清空冻结用户共享邀请链接
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        pass

    def EACP_RestartGlobalShareMgntServer(self):
        """
        重启所有节点 sharemgnt_server 服务
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_RestartLocalShareMgntServer(self):
        """
        重启当前节点 sharemgnt_server 服务
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_SetPushMessagesConfig(self, appId):
        """
        设置消息推送到的第三方Id
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - appId

        """
        pass

    def EACP_GetPushMessagesConfig(self):
        """
        获取消息推送到的第三方Id
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_PublishDocExchange(self, params):
        """
        发起内外网数据交换流程
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - params

        """
        pass

    def EACP_AddAntivirusMessage(self, msg):
        """
        添加杀毒消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        pass

    def EACP_AddQuarantineMessage(self, msg):
        """
        添加隔离消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        pass

    def EACP_AddAppealMessage(self, msg):
        """
        添加申诉处理消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        pass

    def EACP_AddDocRemindMessage(self, msg):
        """
        添加文件到期通知消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        pass

    def EACP_SetSendShareMailStatus(self, status):
        """
        设置邮件通知分享开关状态
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - status

        """
        pass

    def EACP_GetSendShareMailStatus(self):
        """
        获取邮件通知分享开关状态
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_UpdateTokenFlagByUserId(self, userId, flag):
        """
        更新禁用用户token flag信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - flag

        """
        pass

    def EACP_UpdateTokenFlagByPriority(self, priority, flag):
        """
        根据权重值更新用户token flag信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - priority
         - flag

        """
        pass

    def EACP_SetMessageNotifyStatus(self, status):
        """
        设置消息通知状态
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - status

        """
        pass

    def EACP_GetMessageNotifyStatus(self):
        """
        获取消息通知状态
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_DeleteContactPermByUserID(self, dbName, userId):
        """
        删除用户时清除该用户给联系人组配置的权限
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - dbName
         - userId

        """
        pass

    def EACP_SetCustomApplicationConfig(self, appConfig):
        """
        设置定制化的应用配置
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - appConfig

        """
        pass

    def EACP_GetCustomApplicationConfig(self):
        """
        获取定制化的应用配置
        @ret:
        @throw EThriftException.ncTException

        """
        pass

    def EACP_NotifyPushWebhookThread(self):
        """
        通知线程发送 webhook 通知

        @ret:
        @throw EThriftException.ncTException

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def EACP_GetOnlineUserCount(self):
        """
        获取eacp的用户在线数

        @ret: 返回在线用户数
        @throw EThriftException.ncTException

        """
        self.send_EACP_GetOnlineUserCount()
        return self.recv_EACP_GetOnlineUserCount()

    def send_EACP_GetOnlineUserCount(self):
        self._oprot.writeMessageBegin('EACP_GetOnlineUserCount', TMessageType.CALL, self._seqid)
        args = EACP_GetOnlineUserCount_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetOnlineUserCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetOnlineUserCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetOnlineUserCount failed: unknown result")

    def EACP_GetTenantOnlineUserCount(self, orgId):
        """
        获取eacp的用户租户在线数

        @ret: 返回在线用户数
        @throw EThriftException.ncTException

        Parameters:
         - orgId

        """
        self.send_EACP_GetTenantOnlineUserCount(orgId)
        return self.recv_EACP_GetTenantOnlineUserCount()

    def send_EACP_GetTenantOnlineUserCount(self, orgId):
        self._oprot.writeMessageBegin('EACP_GetTenantOnlineUserCount', TMessageType.CALL, self._seqid)
        args = EACP_GetTenantOnlineUserCount_args()
        args.orgId = orgId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetTenantOnlineUserCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetTenantOnlineUserCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetTenantOnlineUserCount failed: unknown result")

    def EACP_OnDeleteUser(self, userId):
        """
        删除用户时，删除用户文档，该用户对应的权限配置，该用户的token信息，所有者信息

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EACP_OnDeleteUser(userId)
        self.recv_EACP_OnDeleteUser()

    def send_EACP_OnDeleteUser(self, userId):
        self._oprot.writeMessageBegin('EACP_OnDeleteUser', TMessageType.CALL, self._seqid)
        args = EACP_OnDeleteUser_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_OnDeleteUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_OnDeleteUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_OnDeleteGroup(self, groupId):
        """
        删除用户组时

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - groupId

        """
        self.send_EACP_OnDeleteGroup(groupId)
        self.recv_EACP_OnDeleteGroup()

    def send_EACP_OnDeleteGroup(self, groupId):
        self._oprot.writeMessageBegin('EACP_OnDeleteGroup', TMessageType.CALL, self._seqid)
        args = EACP_OnDeleteGroup_args()
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_OnDeleteGroup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_OnDeleteGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_OnDeleteDepartment(self, departmentIds):
        """
        删除部门时通知eacp删除权限

        @ret: 无返回
        @throw EThriftException.ncTException

        Parameters:
         - departmentIds

        """
        self.send_EACP_OnDeleteDepartment(departmentIds)
        self.recv_EACP_OnDeleteDepartment()

    def send_EACP_OnDeleteDepartment(self, departmentIds):
        self._oprot.writeMessageBegin('EACP_OnDeleteDepartment', TMessageType.CALL, self._seqid)
        args = EACP_OnDeleteDepartment_args()
        args.departmentIds = departmentIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_OnDeleteDepartment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_OnDeleteDepartment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_ClearPermOutOfScope(self):
        """
        清除超出共享范围的权限配置

        @ret: 无返回
        @throw EThriftException.ncTException

        """
        self.send_EACP_ClearPermOutOfScope()
        self.recv_EACP_ClearPermOutOfScope()

    def send_EACP_ClearPermOutOfScope(self):
        self._oprot.writeMessageBegin('EACP_ClearPermOutOfScope', TMessageType.CALL, self._seqid)
        args = EACP_ClearPermOutOfScope_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearPermOutOfScope(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearPermOutOfScope_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_ClearLinkOutOfScope(self):
        """
        清除未开启外链共享用户或部门的外链共享信息

        @ret: 无返回
        @throw EThriftException.ncTException

        """
        self.send_EACP_ClearLinkOutOfScope()
        self.recv_EACP_ClearLinkOutOfScope()

    def send_EACP_ClearLinkOutOfScope(self):
        self._oprot.writeMessageBegin('EACP_ClearLinkOutOfScope', TMessageType.CALL, self._seqid)
        args = EACP_ClearLinkOutOfScope_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearLinkOutOfScope(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearLinkOutOfScope_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_ClearFindOutOfScope(self):
        """
        清除未开启发现共享用户或部门的发现共享信息

        @ret: 无返回
        @throw EThriftException.ncTException

        """
        self.send_EACP_ClearFindOutOfScope()
        self.recv_EACP_ClearFindOutOfScope()

    def send_EACP_ClearFindOutOfScope(self):
        self._oprot.writeMessageBegin('EACP_ClearFindOutOfScope', TMessageType.CALL, self._seqid)
        args = EACP_ClearFindOutOfScope_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearFindOutOfScope(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearFindOutOfScope_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_GetLicenseInfo(self, license):
        """
        获取注册码模块信息

        @param license:          注册码
        @return:                 注册码对应的模块信息

        Parameters:
         - license

        """
        self.send_EACP_GetLicenseInfo(license)
        return self.recv_EACP_GetLicenseInfo()

    def send_EACP_GetLicenseInfo(self, license):
        self._oprot.writeMessageBegin('EACP_GetLicenseInfo', TMessageType.CALL, self._seqid)
        args = EACP_GetLicenseInfo_args()
        args.license = license
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetLicenseInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetLicenseInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetLicenseInfo failed: unknown result")

    def EACP_VerifyActiveCode(self, license, machineCode, activeCode):
        """
        验证离线激活码是否正确

        @param license:          注册码
        @param machineCode:      机器码
        @param activeCode:       激活码
        @return:                 激活结果,0:成功

        Parameters:
         - license
         - machineCode
         - activeCode

        """
        self.send_EACP_VerifyActiveCode(license, machineCode, activeCode)
        return self.recv_EACP_VerifyActiveCode()

    def send_EACP_VerifyActiveCode(self, license, machineCode, activeCode):
        self._oprot.writeMessageBegin('EACP_VerifyActiveCode', TMessageType.CALL, self._seqid)
        args = EACP_VerifyActiveCode_args()
        args.license = license
        args.machineCode = machineCode
        args.activeCode = activeCode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_VerifyActiveCode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_VerifyActiveCode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_VerifyActiveCode failed: unknown result")

    def EACP_GetAutolockConfig(self):
        """
        获取自动锁配置

        """
        self.send_EACP_GetAutolockConfig()
        return self.recv_EACP_GetAutolockConfig()

    def send_EACP_GetAutolockConfig(self):
        self._oprot.writeMessageBegin('EACP_GetAutolockConfig', TMessageType.CALL, self._seqid)
        args = EACP_GetAutolockConfig_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetAutolockConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetAutolockConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetAutolockConfig failed: unknown result")

    def EACP_SetAutolockConfig(self, config):
        """
        设置自动锁配置

        Parameters:
         - config

        """
        self.send_EACP_SetAutolockConfig(config)
        self.recv_EACP_SetAutolockConfig()

    def send_EACP_SetAutolockConfig(self, config):
        self._oprot.writeMessageBegin('EACP_SetAutolockConfig', TMessageType.CALL, self._seqid)
        args = EACP_SetAutolockConfig_args()
        args.config = config
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SetAutolockConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SetAutolockConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_GetDevicesByUserId(self, userId, start, limit):
        """
        获取用户的设备信息
        @param userId:           用户id
        @paeam start:            起始索引
        @param limit             获取设备信息条数
        @ret:                    用户的登录设备信息
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - start
         - limit

        """
        self.send_EACP_GetDevicesByUserId(userId, start, limit)
        return self.recv_EACP_GetDevicesByUserId()

    def send_EACP_GetDevicesByUserId(self, userId, start, limit):
        self._oprot.writeMessageBegin('EACP_GetDevicesByUserId', TMessageType.CALL, self._seqid)
        args = EACP_GetDevicesByUserId_args()
        args.userId = userId
        args.start = start
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetDevicesByUserId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetDevicesByUserId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetDevicesByUserId failed: unknown result")

    def EACP_AddDevice(self, userId, udid, osType):
        """
        添加设备信息
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @param osType:           设备类型 0：Unknown, 1：IOS, 2：Android, 4：Windows, 5：MacOSX
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid
         - osType

        """
        self.send_EACP_AddDevice(userId, udid, osType)
        self.recv_EACP_AddDevice()

    def send_EACP_AddDevice(self, userId, udid, osType):
        self._oprot.writeMessageBegin('EACP_AddDevice', TMessageType.CALL, self._seqid)
        args = EACP_AddDevice_args()
        args.userId = userId
        args.udid = udid
        args.osType = osType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_AddDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_AddDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_AddDevices(self, userId, udids, osType):
        """
        添加设备信息
        @param userId            用户id
        @param udids:            设备唯一标识码
        @param osType            操作系统类型 0：Unknown, 1：IOS, 2：Android, 4：Windows, 5：MacOSX
        @ret:                    添加失败的设备mac地址
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udids
         - osType

        """
        self.send_EACP_AddDevices(userId, udids, osType)
        return self.recv_EACP_AddDevices()

    def send_EACP_AddDevices(self, userId, udids, osType):
        self._oprot.writeMessageBegin('EACP_AddDevices', TMessageType.CALL, self._seqid)
        args = EACP_AddDevices_args()
        args.userId = userId
        args.udids = udids
        args.osType = osType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_AddDevices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_AddDevices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_AddDevices failed: unknown result")

    def EACP_SearchDevicesByUserIdAndUdid(self, userId, udid, start, limit):
        """
        获取用户的指定设备信息
        @param userId:           用户id
        @param udid:             设备唯一标识号
        @param start:            起始索引
        @param limit             获取设备信息条数
        @param ret:              用户的指定设备信息
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid
         - start
         - limit

        """
        self.send_EACP_SearchDevicesByUserIdAndUdid(userId, udid, start, limit)
        return self.recv_EACP_SearchDevicesByUserIdAndUdid()

    def send_EACP_SearchDevicesByUserIdAndUdid(self, userId, udid, start, limit):
        self._oprot.writeMessageBegin('EACP_SearchDevicesByUserIdAndUdid', TMessageType.CALL, self._seqid)
        args = EACP_SearchDevicesByUserIdAndUdid_args()
        args.userId = userId
        args.udid = udid
        args.start = start
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SearchDevicesByUserIdAndUdid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SearchDevicesByUserIdAndUdid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_SearchDevicesByUserIdAndUdid failed: unknown result")

    def EACP_SearchDevices(self, key, start, limit):
        """
        通过部分udid字符获取可能的设备标识号
        @param key:              设备识别号关键字
        @param start:            起始索引
        @param limit             获取设备信息条数
        @param ret:              设备唯一标识号
        @throw EThriftException.ncTException

        Parameters:
         - key
         - start
         - limit

        """
        self.send_EACP_SearchDevices(key, start, limit)
        return self.recv_EACP_SearchDevices()

    def send_EACP_SearchDevices(self, key, start, limit):
        self._oprot.writeMessageBegin('EACP_SearchDevices', TMessageType.CALL, self._seqid)
        args = EACP_SearchDevices_args()
        args.key = key
        args.start = start
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SearchDevices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SearchDevices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_SearchDevices failed: unknown result")

    def EACP_SearchUserByDeviceUdid(self, udid, start, limit):
        """
        获取绑定了此设备的用户
        @param udid:             设备唯一标识号
        @param start:            起始索引
        @param limit             获取设备信息条数
        @ret:                    用户名列表
        @throw EThriftException.ncTException

        Parameters:
         - udid
         - start
         - limit

        """
        self.send_EACP_SearchUserByDeviceUdid(udid, start, limit)
        return self.recv_EACP_SearchUserByDeviceUdid()

    def send_EACP_SearchUserByDeviceUdid(self, udid, start, limit):
        self._oprot.writeMessageBegin('EACP_SearchUserByDeviceUdid', TMessageType.CALL, self._seqid)
        args = EACP_SearchUserByDeviceUdid_args()
        args.udid = udid
        args.start = start
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SearchUserByDeviceUdid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SearchUserByDeviceUdid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_SearchUserByDeviceUdid failed: unknown result")

    def EACP_DeleteDevices(self, userId, udids):
        """
        删除设备信息
        @param userId:           用户id
        @param udids:            设备唯一标识码；如果为空，删除用户的所有设备
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udids

        """
        self.send_EACP_DeleteDevices(userId, udids)
        self.recv_EACP_DeleteDevices()

    def send_EACP_DeleteDevices(self, userId, udids):
        self._oprot.writeMessageBegin('EACP_DeleteDevices', TMessageType.CALL, self._seqid)
        args = EACP_DeleteDevices_args()
        args.userId = userId
        args.udids = udids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_DeleteDevices(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_DeleteDevices_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_BindDevice(self, userId, udid):
        """
        绑定设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        self.send_EACP_BindDevice(userId, udid)
        self.recv_EACP_BindDevice()

    def send_EACP_BindDevice(self, userId, udid):
        self._oprot.writeMessageBegin('EACP_BindDevice', TMessageType.CALL, self._seqid)
        args = EACP_BindDevice_args()
        args.userId = userId
        args.udid = udid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_BindDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_BindDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_UnbindDevice(self, userId, udid):
        """
        解绑设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        self.send_EACP_UnbindDevice(userId, udid)
        self.recv_EACP_UnbindDevice()

    def send_EACP_UnbindDevice(self, userId, udid):
        self._oprot.writeMessageBegin('EACP_UnbindDevice', TMessageType.CALL, self._seqid)
        args = EACP_UnbindDevice_args()
        args.userId = userId
        args.udid = udid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_UnbindDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_UnbindDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_EnableDevice(self, userId, udid):
        """
        启用设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        self.send_EACP_EnableDevice(userId, udid)
        self.recv_EACP_EnableDevice()

    def send_EACP_EnableDevice(self, userId, udid):
        self._oprot.writeMessageBegin('EACP_EnableDevice', TMessageType.CALL, self._seqid)
        args = EACP_EnableDevice_args()
        args.userId = userId
        args.udid = udid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_EnableDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_EnableDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_DisableDevice(self, userId, udid):
        """
        禁用设备
        @param userId:           用户id
        @param udid:             设备唯一标识码
        @ret:                    无返回
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - udid

        """
        self.send_EACP_DisableDevice(userId, udid)
        self.recv_EACP_DisableDevice()

    def send_EACP_DisableDevice(self, userId, udid):
        self._oprot.writeMessageBegin('EACP_DisableDevice', TMessageType.CALL, self._seqid)
        args = EACP_DisableDevice_args()
        args.userId = userId
        args.udid = udid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_DisableDevice(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_DisableDevice_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_SetPermConfigs(self, docId, permConfigs):
        """
        配置GNS路径的权限信息，注意不要包含继承的权限
        会自动分析差异，然后进行权限配置
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - docId
         - permConfigs

        """
        self.send_EACP_SetPermConfigs(docId, permConfigs)
        self.recv_EACP_SetPermConfigs()

    def send_EACP_SetPermConfigs(self, docId, permConfigs):
        self._oprot.writeMessageBegin('EACP_SetPermConfigs', TMessageType.CALL, self._seqid)
        args = EACP_SetPermConfigs_args()
        args.docId = docId
        args.permConfigs = permConfigs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SetPermConfigs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SetPermConfigs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_ClearTokenByUserId(self, userId):
        """
        清空用户当前的所有token信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EACP_ClearTokenByUserId(userId)
        self.recv_EACP_ClearTokenByUserId()

    def send_EACP_ClearTokenByUserId(self, userId):
        self._oprot.writeMessageBegin('EACP_ClearTokenByUserId', TMessageType.CALL, self._seqid)
        args = EACP_ClearTokenByUserId_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearTokenByUserId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearTokenByUserId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_OnProcessChange(self, processId):
        """
        流程变更时，通知eacp删除对应的申请记录
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - processId

        """
        self.send_EACP_OnProcessChange(processId)
        self.recv_EACP_OnProcessChange()

    def send_EACP_OnProcessChange(self, processId):
        self._oprot.writeMessageBegin('EACP_OnProcessChange', TMessageType.CALL, self._seqid)
        args = EACP_OnProcessChange_args()
        args.processId = processId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_OnProcessChange(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_OnProcessChange_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_ClearAllToken(self):
        """
        清空所有用户token信息
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_ClearAllToken()
        self.recv_EACP_ClearAllToken()

    def send_EACP_ClearAllToken(self):
        self._oprot.writeMessageBegin('EACP_ClearAllToken', TMessageType.CALL, self._seqid)
        args = EACP_ClearAllToken_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearAllToken(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearAllToken_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_UpdateAllTokenFlagByOsType(self, osType):
        """
        管理员禁止指定设备登录时, 更新所有token flag信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - osType

        """
        self.send_EACP_UpdateAllTokenFlagByOsType(osType)
        self.recv_EACP_UpdateAllTokenFlagByOsType()

    def send_EACP_UpdateAllTokenFlagByOsType(self, osType):
        self._oprot.writeMessageBegin('EACP_UpdateAllTokenFlagByOsType', TMessageType.CALL, self._seqid)
        args = EACP_UpdateAllTokenFlagByOsType_args()
        args.osType = osType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_UpdateAllTokenFlagByOsType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_UpdateAllTokenFlagByOsType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_UpdateAllTokenFlagByIdcardStatus(self):
        """
        管理员禁止身份证号登录时, 更新相关token flag信息
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_UpdateAllTokenFlagByIdcardStatus()
        self.recv_EACP_UpdateAllTokenFlagByIdcardStatus()

    def send_EACP_UpdateAllTokenFlagByIdcardStatus(self):
        self._oprot.writeMessageBegin('EACP_UpdateAllTokenFlagByIdcardStatus', TMessageType.CALL, self._seqid)
        args = EACP_UpdateAllTokenFlagByIdcardStatus_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_UpdateAllTokenFlagByIdcardStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_UpdateAllTokenFlagByIdcardStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_CheckTokenId(self, tokenInfo):
        """
        检查用户tokenid接口
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - tokenInfo

        """
        self.send_EACP_CheckTokenId(tokenInfo)
        return self.recv_EACP_CheckTokenId()

    def send_EACP_CheckTokenId(self, tokenInfo):
        self._oprot.writeMessageBegin('EACP_CheckTokenId', TMessageType.CALL, self._seqid)
        args = EACP_CheckTokenId_args()
        args.tokenInfo = tokenInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_CheckTokenId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_CheckTokenId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_CheckTokenId failed: unknown result")

    def EACP_ClearAllInvitationInfo(self):
        """
        清空所有用户共享邀请链接
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_ClearAllInvitationInfo()
        self.recv_EACP_ClearAllInvitationInfo()

    def send_EACP_ClearAllInvitationInfo(self):
        self._oprot.writeMessageBegin('EACP_ClearAllInvitationInfo', TMessageType.CALL, self._seqid)
        args = EACP_ClearAllInvitationInfo_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearAllInvitationInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearAllInvitationInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_ClearUserInvitationInfo(self, userId):
        """
        清空冻结用户共享邀请链接
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId

        """
        self.send_EACP_ClearUserInvitationInfo(userId)
        self.recv_EACP_ClearUserInvitationInfo()

    def send_EACP_ClearUserInvitationInfo(self, userId):
        self._oprot.writeMessageBegin('EACP_ClearUserInvitationInfo', TMessageType.CALL, self._seqid)
        args = EACP_ClearUserInvitationInfo_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_ClearUserInvitationInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_ClearUserInvitationInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_RestartGlobalShareMgntServer(self):
        """
        重启所有节点 sharemgnt_server 服务
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_RestartGlobalShareMgntServer()
        self.recv_EACP_RestartGlobalShareMgntServer()

    def send_EACP_RestartGlobalShareMgntServer(self):
        self._oprot.writeMessageBegin('EACP_RestartGlobalShareMgntServer', TMessageType.CALL, self._seqid)
        args = EACP_RestartGlobalShareMgntServer_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_RestartGlobalShareMgntServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_RestartGlobalShareMgntServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_RestartLocalShareMgntServer(self):
        """
        重启当前节点 sharemgnt_server 服务
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_RestartLocalShareMgntServer()
        self.recv_EACP_RestartLocalShareMgntServer()

    def send_EACP_RestartLocalShareMgntServer(self):
        self._oprot.writeMessageBegin('EACP_RestartLocalShareMgntServer', TMessageType.CALL, self._seqid)
        args = EACP_RestartLocalShareMgntServer_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_RestartLocalShareMgntServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_RestartLocalShareMgntServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_SetPushMessagesConfig(self, appId):
        """
        设置消息推送到的第三方Id
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - appId

        """
        self.send_EACP_SetPushMessagesConfig(appId)
        self.recv_EACP_SetPushMessagesConfig()

    def send_EACP_SetPushMessagesConfig(self, appId):
        self._oprot.writeMessageBegin('EACP_SetPushMessagesConfig', TMessageType.CALL, self._seqid)
        args = EACP_SetPushMessagesConfig_args()
        args.appId = appId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SetPushMessagesConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SetPushMessagesConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_GetPushMessagesConfig(self):
        """
        获取消息推送到的第三方Id
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_GetPushMessagesConfig()
        return self.recv_EACP_GetPushMessagesConfig()

    def send_EACP_GetPushMessagesConfig(self):
        self._oprot.writeMessageBegin('EACP_GetPushMessagesConfig', TMessageType.CALL, self._seqid)
        args = EACP_GetPushMessagesConfig_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetPushMessagesConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetPushMessagesConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetPushMessagesConfig failed: unknown result")

    def EACP_PublishDocExchange(self, params):
        """
        发起内外网数据交换流程
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - params

        """
        self.send_EACP_PublishDocExchange(params)
        self.recv_EACP_PublishDocExchange()

    def send_EACP_PublishDocExchange(self, params):
        self._oprot.writeMessageBegin('EACP_PublishDocExchange', TMessageType.CALL, self._seqid)
        args = EACP_PublishDocExchange_args()
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_PublishDocExchange(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_PublishDocExchange_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_AddAntivirusMessage(self, msg):
        """
        添加杀毒消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        self.send_EACP_AddAntivirusMessage(msg)
        self.recv_EACP_AddAntivirusMessage()

    def send_EACP_AddAntivirusMessage(self, msg):
        self._oprot.writeMessageBegin('EACP_AddAntivirusMessage', TMessageType.CALL, self._seqid)
        args = EACP_AddAntivirusMessage_args()
        args.msg = msg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_AddAntivirusMessage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_AddAntivirusMessage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_AddQuarantineMessage(self, msg):
        """
        添加隔离消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        self.send_EACP_AddQuarantineMessage(msg)
        self.recv_EACP_AddQuarantineMessage()

    def send_EACP_AddQuarantineMessage(self, msg):
        self._oprot.writeMessageBegin('EACP_AddQuarantineMessage', TMessageType.CALL, self._seqid)
        args = EACP_AddQuarantineMessage_args()
        args.msg = msg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_AddQuarantineMessage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_AddQuarantineMessage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_AddAppealMessage(self, msg):
        """
        添加申诉处理消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        self.send_EACP_AddAppealMessage(msg)
        self.recv_EACP_AddAppealMessage()

    def send_EACP_AddAppealMessage(self, msg):
        self._oprot.writeMessageBegin('EACP_AddAppealMessage', TMessageType.CALL, self._seqid)
        args = EACP_AddAppealMessage_args()
        args.msg = msg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_AddAppealMessage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_AddAppealMessage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_AddDocRemindMessage(self, msg):
        """
        添加文件到期通知消息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - msg

        """
        self.send_EACP_AddDocRemindMessage(msg)
        self.recv_EACP_AddDocRemindMessage()

    def send_EACP_AddDocRemindMessage(self, msg):
        self._oprot.writeMessageBegin('EACP_AddDocRemindMessage', TMessageType.CALL, self._seqid)
        args = EACP_AddDocRemindMessage_args()
        args.msg = msg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_AddDocRemindMessage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_AddDocRemindMessage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_SetSendShareMailStatus(self, status):
        """
        设置邮件通知分享开关状态
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - status

        """
        self.send_EACP_SetSendShareMailStatus(status)
        self.recv_EACP_SetSendShareMailStatus()

    def send_EACP_SetSendShareMailStatus(self, status):
        self._oprot.writeMessageBegin('EACP_SetSendShareMailStatus', TMessageType.CALL, self._seqid)
        args = EACP_SetSendShareMailStatus_args()
        args.status = status
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SetSendShareMailStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SetSendShareMailStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_GetSendShareMailStatus(self):
        """
        获取邮件通知分享开关状态
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_GetSendShareMailStatus()
        return self.recv_EACP_GetSendShareMailStatus()

    def send_EACP_GetSendShareMailStatus(self):
        self._oprot.writeMessageBegin('EACP_GetSendShareMailStatus', TMessageType.CALL, self._seqid)
        args = EACP_GetSendShareMailStatus_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetSendShareMailStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetSendShareMailStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetSendShareMailStatus failed: unknown result")

    def EACP_UpdateTokenFlagByUserId(self, userId, flag):
        """
        更新禁用用户token flag信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - userId
         - flag

        """
        self.send_EACP_UpdateTokenFlagByUserId(userId, flag)
        self.recv_EACP_UpdateTokenFlagByUserId()

    def send_EACP_UpdateTokenFlagByUserId(self, userId, flag):
        self._oprot.writeMessageBegin('EACP_UpdateTokenFlagByUserId', TMessageType.CALL, self._seqid)
        args = EACP_UpdateTokenFlagByUserId_args()
        args.userId = userId
        args.flag = flag
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_UpdateTokenFlagByUserId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_UpdateTokenFlagByUserId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_UpdateTokenFlagByPriority(self, priority, flag):
        """
        根据权重值更新用户token flag信息
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - priority
         - flag

        """
        self.send_EACP_UpdateTokenFlagByPriority(priority, flag)
        self.recv_EACP_UpdateTokenFlagByPriority()

    def send_EACP_UpdateTokenFlagByPriority(self, priority, flag):
        self._oprot.writeMessageBegin('EACP_UpdateTokenFlagByPriority', TMessageType.CALL, self._seqid)
        args = EACP_UpdateTokenFlagByPriority_args()
        args.priority = priority
        args.flag = flag
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_UpdateTokenFlagByPriority(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_UpdateTokenFlagByPriority_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_SetMessageNotifyStatus(self, status):
        """
        设置消息通知状态
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - status

        """
        self.send_EACP_SetMessageNotifyStatus(status)
        self.recv_EACP_SetMessageNotifyStatus()

    def send_EACP_SetMessageNotifyStatus(self, status):
        self._oprot.writeMessageBegin('EACP_SetMessageNotifyStatus', TMessageType.CALL, self._seqid)
        args = EACP_SetMessageNotifyStatus_args()
        args.status = status
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SetMessageNotifyStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SetMessageNotifyStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_GetMessageNotifyStatus(self):
        """
        获取消息通知状态
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_GetMessageNotifyStatus()
        return self.recv_EACP_GetMessageNotifyStatus()

    def send_EACP_GetMessageNotifyStatus(self):
        self._oprot.writeMessageBegin('EACP_GetMessageNotifyStatus', TMessageType.CALL, self._seqid)
        args = EACP_GetMessageNotifyStatus_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetMessageNotifyStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetMessageNotifyStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetMessageNotifyStatus failed: unknown result")

    def EACP_DeleteContactPermByUserID(self, dbName, userId):
        """
        删除用户时清除该用户给联系人组配置的权限
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - dbName
         - userId

        """
        self.send_EACP_DeleteContactPermByUserID(dbName, userId)
        self.recv_EACP_DeleteContactPermByUserID()

    def send_EACP_DeleteContactPermByUserID(self, dbName, userId):
        self._oprot.writeMessageBegin('EACP_DeleteContactPermByUserID', TMessageType.CALL, self._seqid)
        args = EACP_DeleteContactPermByUserID_args()
        args.dbName = dbName
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_DeleteContactPermByUserID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_DeleteContactPermByUserID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_SetCustomApplicationConfig(self, appConfig):
        """
        设置定制化的应用配置
        @ret:
        @throw EThriftException.ncTException

        Parameters:
         - appConfig

        """
        self.send_EACP_SetCustomApplicationConfig(appConfig)
        self.recv_EACP_SetCustomApplicationConfig()

    def send_EACP_SetCustomApplicationConfig(self, appConfig):
        self._oprot.writeMessageBegin('EACP_SetCustomApplicationConfig', TMessageType.CALL, self._seqid)
        args = EACP_SetCustomApplicationConfig_args()
        args.appConfig = appConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_SetCustomApplicationConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_SetCustomApplicationConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def EACP_GetCustomApplicationConfig(self):
        """
        获取定制化的应用配置
        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_GetCustomApplicationConfig()
        return self.recv_EACP_GetCustomApplicationConfig()

    def send_EACP_GetCustomApplicationConfig(self):
        self._oprot.writeMessageBegin('EACP_GetCustomApplicationConfig', TMessageType.CALL, self._seqid)
        args = EACP_GetCustomApplicationConfig_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_GetCustomApplicationConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_GetCustomApplicationConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "EACP_GetCustomApplicationConfig failed: unknown result")

    def EACP_NotifyPushWebhookThread(self):
        """
        通知线程发送 webhook 通知

        @ret:
        @throw EThriftException.ncTException

        """
        self.send_EACP_NotifyPushWebhookThread()
        self.recv_EACP_NotifyPushWebhookThread()

    def send_EACP_NotifyPushWebhookThread(self):
        self._oprot.writeMessageBegin('EACP_NotifyPushWebhookThread', TMessageType.CALL, self._seqid)
        args = EACP_NotifyPushWebhookThread_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EACP_NotifyPushWebhookThread(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EACP_NotifyPushWebhookThread_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["EACP_GetOnlineUserCount"] = Processor.process_EACP_GetOnlineUserCount
        self._processMap["EACP_GetTenantOnlineUserCount"] = Processor.process_EACP_GetTenantOnlineUserCount
        self._processMap["EACP_OnDeleteUser"] = Processor.process_EACP_OnDeleteUser
        self._processMap["EACP_OnDeleteGroup"] = Processor.process_EACP_OnDeleteGroup
        self._processMap["EACP_OnDeleteDepartment"] = Processor.process_EACP_OnDeleteDepartment
        self._processMap["EACP_ClearPermOutOfScope"] = Processor.process_EACP_ClearPermOutOfScope
        self._processMap["EACP_ClearLinkOutOfScope"] = Processor.process_EACP_ClearLinkOutOfScope
        self._processMap["EACP_ClearFindOutOfScope"] = Processor.process_EACP_ClearFindOutOfScope
        self._processMap["EACP_GetLicenseInfo"] = Processor.process_EACP_GetLicenseInfo
        self._processMap["EACP_VerifyActiveCode"] = Processor.process_EACP_VerifyActiveCode
        self._processMap["EACP_GetAutolockConfig"] = Processor.process_EACP_GetAutolockConfig
        self._processMap["EACP_SetAutolockConfig"] = Processor.process_EACP_SetAutolockConfig
        self._processMap["EACP_GetDevicesByUserId"] = Processor.process_EACP_GetDevicesByUserId
        self._processMap["EACP_AddDevice"] = Processor.process_EACP_AddDevice
        self._processMap["EACP_AddDevices"] = Processor.process_EACP_AddDevices
        self._processMap["EACP_SearchDevicesByUserIdAndUdid"] = Processor.process_EACP_SearchDevicesByUserIdAndUdid
        self._processMap["EACP_SearchDevices"] = Processor.process_EACP_SearchDevices
        self._processMap["EACP_SearchUserByDeviceUdid"] = Processor.process_EACP_SearchUserByDeviceUdid
        self._processMap["EACP_DeleteDevices"] = Processor.process_EACP_DeleteDevices
        self._processMap["EACP_BindDevice"] = Processor.process_EACP_BindDevice
        self._processMap["EACP_UnbindDevice"] = Processor.process_EACP_UnbindDevice
        self._processMap["EACP_EnableDevice"] = Processor.process_EACP_EnableDevice
        self._processMap["EACP_DisableDevice"] = Processor.process_EACP_DisableDevice
        self._processMap["EACP_SetPermConfigs"] = Processor.process_EACP_SetPermConfigs
        self._processMap["EACP_ClearTokenByUserId"] = Processor.process_EACP_ClearTokenByUserId
        self._processMap["EACP_OnProcessChange"] = Processor.process_EACP_OnProcessChange
        self._processMap["EACP_ClearAllToken"] = Processor.process_EACP_ClearAllToken
        self._processMap["EACP_UpdateAllTokenFlagByOsType"] = Processor.process_EACP_UpdateAllTokenFlagByOsType
        self._processMap["EACP_UpdateAllTokenFlagByIdcardStatus"] = Processor.process_EACP_UpdateAllTokenFlagByIdcardStatus
        self._processMap["EACP_CheckTokenId"] = Processor.process_EACP_CheckTokenId
        self._processMap["EACP_ClearAllInvitationInfo"] = Processor.process_EACP_ClearAllInvitationInfo
        self._processMap["EACP_ClearUserInvitationInfo"] = Processor.process_EACP_ClearUserInvitationInfo
        self._processMap["EACP_RestartGlobalShareMgntServer"] = Processor.process_EACP_RestartGlobalShareMgntServer
        self._processMap["EACP_RestartLocalShareMgntServer"] = Processor.process_EACP_RestartLocalShareMgntServer
        self._processMap["EACP_SetPushMessagesConfig"] = Processor.process_EACP_SetPushMessagesConfig
        self._processMap["EACP_GetPushMessagesConfig"] = Processor.process_EACP_GetPushMessagesConfig
        self._processMap["EACP_PublishDocExchange"] = Processor.process_EACP_PublishDocExchange
        self._processMap["EACP_AddAntivirusMessage"] = Processor.process_EACP_AddAntivirusMessage
        self._processMap["EACP_AddQuarantineMessage"] = Processor.process_EACP_AddQuarantineMessage
        self._processMap["EACP_AddAppealMessage"] = Processor.process_EACP_AddAppealMessage
        self._processMap["EACP_AddDocRemindMessage"] = Processor.process_EACP_AddDocRemindMessage
        self._processMap["EACP_SetSendShareMailStatus"] = Processor.process_EACP_SetSendShareMailStatus
        self._processMap["EACP_GetSendShareMailStatus"] = Processor.process_EACP_GetSendShareMailStatus
        self._processMap["EACP_UpdateTokenFlagByUserId"] = Processor.process_EACP_UpdateTokenFlagByUserId
        self._processMap["EACP_UpdateTokenFlagByPriority"] = Processor.process_EACP_UpdateTokenFlagByPriority
        self._processMap["EACP_SetMessageNotifyStatus"] = Processor.process_EACP_SetMessageNotifyStatus
        self._processMap["EACP_GetMessageNotifyStatus"] = Processor.process_EACP_GetMessageNotifyStatus
        self._processMap["EACP_DeleteContactPermByUserID"] = Processor.process_EACP_DeleteContactPermByUserID
        self._processMap["EACP_SetCustomApplicationConfig"] = Processor.process_EACP_SetCustomApplicationConfig
        self._processMap["EACP_GetCustomApplicationConfig"] = Processor.process_EACP_GetCustomApplicationConfig
        self._processMap["EACP_NotifyPushWebhookThread"] = Processor.process_EACP_NotifyPushWebhookThread
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_EACP_GetOnlineUserCount(self, seqid, iprot, oprot):
        args = EACP_GetOnlineUserCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetOnlineUserCount_result()
        try:
            result.success = self._handler.EACP_GetOnlineUserCount()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetOnlineUserCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetTenantOnlineUserCount(self, seqid, iprot, oprot):
        args = EACP_GetTenantOnlineUserCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetTenantOnlineUserCount_result()
        try:
            result.success = self._handler.EACP_GetTenantOnlineUserCount(args.orgId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetTenantOnlineUserCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_OnDeleteUser(self, seqid, iprot, oprot):
        args = EACP_OnDeleteUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_OnDeleteUser_result()
        try:
            self._handler.EACP_OnDeleteUser(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_OnDeleteUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_OnDeleteGroup(self, seqid, iprot, oprot):
        args = EACP_OnDeleteGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_OnDeleteGroup_result()
        try:
            self._handler.EACP_OnDeleteGroup(args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_OnDeleteGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_OnDeleteDepartment(self, seqid, iprot, oprot):
        args = EACP_OnDeleteDepartment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_OnDeleteDepartment_result()
        try:
            self._handler.EACP_OnDeleteDepartment(args.departmentIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_OnDeleteDepartment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearPermOutOfScope(self, seqid, iprot, oprot):
        args = EACP_ClearPermOutOfScope_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearPermOutOfScope_result()
        try:
            self._handler.EACP_ClearPermOutOfScope()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearPermOutOfScope", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearLinkOutOfScope(self, seqid, iprot, oprot):
        args = EACP_ClearLinkOutOfScope_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearLinkOutOfScope_result()
        try:
            self._handler.EACP_ClearLinkOutOfScope()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearLinkOutOfScope", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearFindOutOfScope(self, seqid, iprot, oprot):
        args = EACP_ClearFindOutOfScope_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearFindOutOfScope_result()
        try:
            self._handler.EACP_ClearFindOutOfScope()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearFindOutOfScope", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetLicenseInfo(self, seqid, iprot, oprot):
        args = EACP_GetLicenseInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetLicenseInfo_result()
        try:
            result.success = self._handler.EACP_GetLicenseInfo(args.license)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetLicenseInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_VerifyActiveCode(self, seqid, iprot, oprot):
        args = EACP_VerifyActiveCode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_VerifyActiveCode_result()
        try:
            result.success = self._handler.EACP_VerifyActiveCode(args.license, args.machineCode, args.activeCode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_VerifyActiveCode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetAutolockConfig(self, seqid, iprot, oprot):
        args = EACP_GetAutolockConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetAutolockConfig_result()
        try:
            result.success = self._handler.EACP_GetAutolockConfig()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetAutolockConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SetAutolockConfig(self, seqid, iprot, oprot):
        args = EACP_SetAutolockConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SetAutolockConfig_result()
        try:
            self._handler.EACP_SetAutolockConfig(args.config)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SetAutolockConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetDevicesByUserId(self, seqid, iprot, oprot):
        args = EACP_GetDevicesByUserId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetDevicesByUserId_result()
        try:
            result.success = self._handler.EACP_GetDevicesByUserId(args.userId, args.start, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetDevicesByUserId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_AddDevice(self, seqid, iprot, oprot):
        args = EACP_AddDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_AddDevice_result()
        try:
            self._handler.EACP_AddDevice(args.userId, args.udid, args.osType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_AddDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_AddDevices(self, seqid, iprot, oprot):
        args = EACP_AddDevices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_AddDevices_result()
        try:
            result.success = self._handler.EACP_AddDevices(args.userId, args.udids, args.osType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_AddDevices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SearchDevicesByUserIdAndUdid(self, seqid, iprot, oprot):
        args = EACP_SearchDevicesByUserIdAndUdid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SearchDevicesByUserIdAndUdid_result()
        try:
            result.success = self._handler.EACP_SearchDevicesByUserIdAndUdid(args.userId, args.udid, args.start, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SearchDevicesByUserIdAndUdid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SearchDevices(self, seqid, iprot, oprot):
        args = EACP_SearchDevices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SearchDevices_result()
        try:
            result.success = self._handler.EACP_SearchDevices(args.key, args.start, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SearchDevices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SearchUserByDeviceUdid(self, seqid, iprot, oprot):
        args = EACP_SearchUserByDeviceUdid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SearchUserByDeviceUdid_result()
        try:
            result.success = self._handler.EACP_SearchUserByDeviceUdid(args.udid, args.start, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SearchUserByDeviceUdid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_DeleteDevices(self, seqid, iprot, oprot):
        args = EACP_DeleteDevices_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_DeleteDevices_result()
        try:
            self._handler.EACP_DeleteDevices(args.userId, args.udids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_DeleteDevices", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_BindDevice(self, seqid, iprot, oprot):
        args = EACP_BindDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_BindDevice_result()
        try:
            self._handler.EACP_BindDevice(args.userId, args.udid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_BindDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_UnbindDevice(self, seqid, iprot, oprot):
        args = EACP_UnbindDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_UnbindDevice_result()
        try:
            self._handler.EACP_UnbindDevice(args.userId, args.udid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_UnbindDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_EnableDevice(self, seqid, iprot, oprot):
        args = EACP_EnableDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_EnableDevice_result()
        try:
            self._handler.EACP_EnableDevice(args.userId, args.udid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_EnableDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_DisableDevice(self, seqid, iprot, oprot):
        args = EACP_DisableDevice_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_DisableDevice_result()
        try:
            self._handler.EACP_DisableDevice(args.userId, args.udid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_DisableDevice", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SetPermConfigs(self, seqid, iprot, oprot):
        args = EACP_SetPermConfigs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SetPermConfigs_result()
        try:
            self._handler.EACP_SetPermConfigs(args.docId, args.permConfigs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SetPermConfigs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearTokenByUserId(self, seqid, iprot, oprot):
        args = EACP_ClearTokenByUserId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearTokenByUserId_result()
        try:
            self._handler.EACP_ClearTokenByUserId(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearTokenByUserId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_OnProcessChange(self, seqid, iprot, oprot):
        args = EACP_OnProcessChange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_OnProcessChange_result()
        try:
            self._handler.EACP_OnProcessChange(args.processId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_OnProcessChange", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearAllToken(self, seqid, iprot, oprot):
        args = EACP_ClearAllToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearAllToken_result()
        try:
            self._handler.EACP_ClearAllToken()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearAllToken", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_UpdateAllTokenFlagByOsType(self, seqid, iprot, oprot):
        args = EACP_UpdateAllTokenFlagByOsType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_UpdateAllTokenFlagByOsType_result()
        try:
            self._handler.EACP_UpdateAllTokenFlagByOsType(args.osType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_UpdateAllTokenFlagByOsType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_UpdateAllTokenFlagByIdcardStatus(self, seqid, iprot, oprot):
        args = EACP_UpdateAllTokenFlagByIdcardStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_UpdateAllTokenFlagByIdcardStatus_result()
        try:
            self._handler.EACP_UpdateAllTokenFlagByIdcardStatus()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_UpdateAllTokenFlagByIdcardStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_CheckTokenId(self, seqid, iprot, oprot):
        args = EACP_CheckTokenId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_CheckTokenId_result()
        try:
            result.success = self._handler.EACP_CheckTokenId(args.tokenInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_CheckTokenId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearAllInvitationInfo(self, seqid, iprot, oprot):
        args = EACP_ClearAllInvitationInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearAllInvitationInfo_result()
        try:
            self._handler.EACP_ClearAllInvitationInfo()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearAllInvitationInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_ClearUserInvitationInfo(self, seqid, iprot, oprot):
        args = EACP_ClearUserInvitationInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_ClearUserInvitationInfo_result()
        try:
            self._handler.EACP_ClearUserInvitationInfo(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_ClearUserInvitationInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_RestartGlobalShareMgntServer(self, seqid, iprot, oprot):
        args = EACP_RestartGlobalShareMgntServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_RestartGlobalShareMgntServer_result()
        try:
            self._handler.EACP_RestartGlobalShareMgntServer()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_RestartGlobalShareMgntServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_RestartLocalShareMgntServer(self, seqid, iprot, oprot):
        args = EACP_RestartLocalShareMgntServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_RestartLocalShareMgntServer_result()
        try:
            self._handler.EACP_RestartLocalShareMgntServer()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_RestartLocalShareMgntServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SetPushMessagesConfig(self, seqid, iprot, oprot):
        args = EACP_SetPushMessagesConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SetPushMessagesConfig_result()
        try:
            self._handler.EACP_SetPushMessagesConfig(args.appId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SetPushMessagesConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetPushMessagesConfig(self, seqid, iprot, oprot):
        args = EACP_GetPushMessagesConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetPushMessagesConfig_result()
        try:
            result.success = self._handler.EACP_GetPushMessagesConfig()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetPushMessagesConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_PublishDocExchange(self, seqid, iprot, oprot):
        args = EACP_PublishDocExchange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_PublishDocExchange_result()
        try:
            self._handler.EACP_PublishDocExchange(args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_PublishDocExchange", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_AddAntivirusMessage(self, seqid, iprot, oprot):
        args = EACP_AddAntivirusMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_AddAntivirusMessage_result()
        try:
            self._handler.EACP_AddAntivirusMessage(args.msg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_AddAntivirusMessage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_AddQuarantineMessage(self, seqid, iprot, oprot):
        args = EACP_AddQuarantineMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_AddQuarantineMessage_result()
        try:
            self._handler.EACP_AddQuarantineMessage(args.msg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_AddQuarantineMessage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_AddAppealMessage(self, seqid, iprot, oprot):
        args = EACP_AddAppealMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_AddAppealMessage_result()
        try:
            self._handler.EACP_AddAppealMessage(args.msg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_AddAppealMessage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_AddDocRemindMessage(self, seqid, iprot, oprot):
        args = EACP_AddDocRemindMessage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_AddDocRemindMessage_result()
        try:
            self._handler.EACP_AddDocRemindMessage(args.msg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_AddDocRemindMessage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SetSendShareMailStatus(self, seqid, iprot, oprot):
        args = EACP_SetSendShareMailStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SetSendShareMailStatus_result()
        try:
            self._handler.EACP_SetSendShareMailStatus(args.status)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SetSendShareMailStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetSendShareMailStatus(self, seqid, iprot, oprot):
        args = EACP_GetSendShareMailStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetSendShareMailStatus_result()
        try:
            result.success = self._handler.EACP_GetSendShareMailStatus()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetSendShareMailStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_UpdateTokenFlagByUserId(self, seqid, iprot, oprot):
        args = EACP_UpdateTokenFlagByUserId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_UpdateTokenFlagByUserId_result()
        try:
            self._handler.EACP_UpdateTokenFlagByUserId(args.userId, args.flag)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_UpdateTokenFlagByUserId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_UpdateTokenFlagByPriority(self, seqid, iprot, oprot):
        args = EACP_UpdateTokenFlagByPriority_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_UpdateTokenFlagByPriority_result()
        try:
            self._handler.EACP_UpdateTokenFlagByPriority(args.priority, args.flag)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_UpdateTokenFlagByPriority", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SetMessageNotifyStatus(self, seqid, iprot, oprot):
        args = EACP_SetMessageNotifyStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SetMessageNotifyStatus_result()
        try:
            self._handler.EACP_SetMessageNotifyStatus(args.status)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SetMessageNotifyStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetMessageNotifyStatus(self, seqid, iprot, oprot):
        args = EACP_GetMessageNotifyStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetMessageNotifyStatus_result()
        try:
            result.success = self._handler.EACP_GetMessageNotifyStatus()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetMessageNotifyStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_DeleteContactPermByUserID(self, seqid, iprot, oprot):
        args = EACP_DeleteContactPermByUserID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_DeleteContactPermByUserID_result()
        try:
            self._handler.EACP_DeleteContactPermByUserID(args.dbName, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_DeleteContactPermByUserID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_SetCustomApplicationConfig(self, seqid, iprot, oprot):
        args = EACP_SetCustomApplicationConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_SetCustomApplicationConfig_result()
        try:
            self._handler.EACP_SetCustomApplicationConfig(args.appConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_SetCustomApplicationConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_GetCustomApplicationConfig(self, seqid, iprot, oprot):
        args = EACP_GetCustomApplicationConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_GetCustomApplicationConfig_result()
        try:
            result.success = self._handler.EACP_GetCustomApplicationConfig()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_GetCustomApplicationConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EACP_NotifyPushWebhookThread(self, seqid, iprot, oprot):
        args = EACP_NotifyPushWebhookThread_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EACP_NotifyPushWebhookThread_result()
        try:
            self._handler.EACP_NotifyPushWebhookThread()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EACP_NotifyPushWebhookThread", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class EACP_GetOnlineUserCount_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetOnlineUserCount_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetOnlineUserCount_args)
EACP_GetOnlineUserCount_args.thrift_spec = (
)


class EACP_GetOnlineUserCount_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetOnlineUserCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetOnlineUserCount_result)
EACP_GetOnlineUserCount_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetTenantOnlineUserCount_args(object):
    """
    Attributes:
     - orgId

    """


    def __init__(self, orgId=None,):
        self.orgId = orgId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.orgId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetTenantOnlineUserCount_args')
        if self.orgId is not None:
            oprot.writeFieldBegin('orgId', TType.STRING, 1)
            oprot.writeString(self.orgId.encode('utf-8') if sys.version_info[0] == 2 else self.orgId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetTenantOnlineUserCount_args)
EACP_GetTenantOnlineUserCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'orgId', 'UTF8', None, ),  # 1
)


class EACP_GetTenantOnlineUserCount_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetTenantOnlineUserCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetTenantOnlineUserCount_result)
EACP_GetTenantOnlineUserCount_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_OnDeleteUser_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnDeleteUser_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnDeleteUser_args)
EACP_OnDeleteUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EACP_OnDeleteUser_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnDeleteUser_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnDeleteUser_result)
EACP_OnDeleteUser_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_OnDeleteGroup_args(object):
    """
    Attributes:
     - groupId

    """


    def __init__(self, groupId=None,):
        self.groupId = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnDeleteGroup_args')
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 1)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnDeleteGroup_args)
EACP_OnDeleteGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'groupId', 'UTF8', None, ),  # 1
)


class EACP_OnDeleteGroup_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnDeleteGroup_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnDeleteGroup_result)
EACP_OnDeleteGroup_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_OnDeleteDepartment_args(object):
    """
    Attributes:
     - departmentIds

    """


    def __init__(self, departmentIds=None,):
        self.departmentIds = departmentIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.departmentIds = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.departmentIds.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnDeleteDepartment_args')
        if self.departmentIds is not None:
            oprot.writeFieldBegin('departmentIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.departmentIds))
            for iter13 in self.departmentIds:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnDeleteDepartment_args)
EACP_OnDeleteDepartment_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'departmentIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class EACP_OnDeleteDepartment_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnDeleteDepartment_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnDeleteDepartment_result)
EACP_OnDeleteDepartment_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearPermOutOfScope_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearPermOutOfScope_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearPermOutOfScope_args)
EACP_ClearPermOutOfScope_args.thrift_spec = (
)


class EACP_ClearPermOutOfScope_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearPermOutOfScope_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearPermOutOfScope_result)
EACP_ClearPermOutOfScope_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearLinkOutOfScope_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearLinkOutOfScope_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearLinkOutOfScope_args)
EACP_ClearLinkOutOfScope_args.thrift_spec = (
)


class EACP_ClearLinkOutOfScope_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearLinkOutOfScope_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearLinkOutOfScope_result)
EACP_ClearLinkOutOfScope_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearFindOutOfScope_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearFindOutOfScope_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearFindOutOfScope_args)
EACP_ClearFindOutOfScope_args.thrift_spec = (
)


class EACP_ClearFindOutOfScope_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearFindOutOfScope_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearFindOutOfScope_result)
EACP_ClearFindOutOfScope_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetLicenseInfo_args(object):
    """
    Attributes:
     - license

    """


    def __init__(self, license=None,):
        self.license = license

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.license = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetLicenseInfo_args')
        if self.license is not None:
            oprot.writeFieldBegin('license', TType.STRING, 1)
            oprot.writeString(self.license.encode('utf-8') if sys.version_info[0] == 2 else self.license)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetLicenseInfo_args)
EACP_GetLicenseInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'license', 'UTF8', None, ),  # 1
)


class EACP_GetLicenseInfo_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetLicenseInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetLicenseInfo_result)
EACP_GetLicenseInfo_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_VerifyActiveCode_args(object):
    """
    Attributes:
     - license
     - machineCode
     - activeCode

    """


    def __init__(self, license=None, machineCode=None, activeCode=None,):
        self.license = license
        self.machineCode = machineCode
        self.activeCode = activeCode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.license = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.machineCode = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.activeCode = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_VerifyActiveCode_args')
        if self.license is not None:
            oprot.writeFieldBegin('license', TType.STRING, 1)
            oprot.writeString(self.license.encode('utf-8') if sys.version_info[0] == 2 else self.license)
            oprot.writeFieldEnd()
        if self.machineCode is not None:
            oprot.writeFieldBegin('machineCode', TType.STRING, 2)
            oprot.writeString(self.machineCode.encode('utf-8') if sys.version_info[0] == 2 else self.machineCode)
            oprot.writeFieldEnd()
        if self.activeCode is not None:
            oprot.writeFieldBegin('activeCode', TType.STRING, 3)
            oprot.writeString(self.activeCode.encode('utf-8') if sys.version_info[0] == 2 else self.activeCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_VerifyActiveCode_args)
EACP_VerifyActiveCode_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'license', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'machineCode', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'activeCode', 'UTF8', None, ),  # 3
)


class EACP_VerifyActiveCode_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_VerifyActiveCode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_VerifyActiveCode_result)
EACP_VerifyActiveCode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetAutolockConfig_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetAutolockConfig_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetAutolockConfig_args)
EACP_GetAutolockConfig_args.thrift_spec = (
)


class EACP_GetAutolockConfig_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTAutolockConfig()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetAutolockConfig_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetAutolockConfig_result)
EACP_GetAutolockConfig_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTAutolockConfig, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SetAutolockConfig_args(object):
    """
    Attributes:
     - config

    """


    def __init__(self, config=None,):
        self.config = config

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.config = ncTAutolockConfig()
                    self.config.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetAutolockConfig_args')
        if self.config is not None:
            oprot.writeFieldBegin('config', TType.STRUCT, 1)
            self.config.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetAutolockConfig_args)
EACP_SetAutolockConfig_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'config', [ncTAutolockConfig, None], None, ),  # 1
)


class EACP_SetAutolockConfig_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetAutolockConfig_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetAutolockConfig_result)
EACP_SetAutolockConfig_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetDevicesByUserId_args(object):
    """
    Attributes:
     - userId
     - start
     - limit

    """


    def __init__(self, userId=None, start=None, limit=None,):
        self.userId = userId
        self.start = start
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetDevicesByUserId_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetDevicesByUserId_args)
EACP_GetDevicesByUserId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class EACP_GetDevicesByUserId_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = ncTLoginDeviceInfo()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetDevicesByUserId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetDevicesByUserId_result)
EACP_GetDevicesByUserId_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTLoginDeviceInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_AddDevice_args(object):
    """
    Attributes:
     - userId
     - udid
     - osType

    """


    def __init__(self, userId=None, udid=None, osType=None,):
        self.userId = userId
        self.udid = udid
        self.osType = osType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.osType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddDevice_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 2)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        if self.osType is not None:
            oprot.writeFieldBegin('osType', TType.I32, 3)
            oprot.writeI32(self.osType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddDevice_args)
EACP_AddDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'udid', 'UTF8', None, ),  # 2
    (3, TType.I32, 'osType', None, None, ),  # 3
)


class EACP_AddDevice_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddDevice_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddDevice_result)
EACP_AddDevice_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_AddDevices_args(object):
    """
    Attributes:
     - userId
     - udids
     - osType

    """


    def __init__(self, userId=None, udids=None, osType=None,):
        self.userId = userId
        self.udids = udids
        self.osType = osType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.udids = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.udids.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.osType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddDevices_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udids is not None:
            oprot.writeFieldBegin('udids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.udids))
            for iter27 in self.udids:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.osType is not None:
            oprot.writeFieldBegin('osType', TType.I32, 3)
            oprot.writeI32(self.osType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddDevices_args)
EACP_AddDevices_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'udids', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'osType', None, None, ),  # 3
)


class EACP_AddDevices_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddDevices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter34 in self.success:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddDevices_result)
EACP_AddDevices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SearchDevicesByUserIdAndUdid_args(object):
    """
    Attributes:
     - userId
     - udid
     - start
     - limit

    """


    def __init__(self, userId=None, udid=None, start=None, limit=None,):
        self.userId = userId
        self.udid = udid
        self.start = start
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SearchDevicesByUserIdAndUdid_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 2)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 3)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 4)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SearchDevicesByUserIdAndUdid_args)
EACP_SearchDevicesByUserIdAndUdid_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'udid', 'UTF8', None, ),  # 2
    (3, TType.I32, 'start', None, None, ),  # 3
    (4, TType.I32, 'limit', None, None, ),  # 4
)


class EACP_SearchDevicesByUserIdAndUdid_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = ncTLoginDeviceInfo()
                        _elem40.read(iprot)
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SearchDevicesByUserIdAndUdid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter41 in self.success:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SearchDevicesByUserIdAndUdid_result)
EACP_SearchDevicesByUserIdAndUdid_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTLoginDeviceInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SearchDevices_args(object):
    """
    Attributes:
     - key
     - start
     - limit

    """


    def __init__(self, key=None, start=None, limit=None,):
        self.key = key
        self.start = start
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SearchDevices_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SearchDevices_args)
EACP_SearchDevices_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class EACP_SearchDevices_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SearchDevices_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter48 in self.success:
                oprot.writeString(iter48.encode('utf-8') if sys.version_info[0] == 2 else iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SearchDevices_result)
EACP_SearchDevices_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SearchUserByDeviceUdid_args(object):
    """
    Attributes:
     - udid
     - start
     - limit

    """


    def __init__(self, udid=None, start=None, limit=None,):
        self.udid = udid
        self.start = start
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SearchUserByDeviceUdid_args')
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 1)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 2)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SearchUserByDeviceUdid_args)
EACP_SearchUserByDeviceUdid_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'udid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'start', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class EACP_SearchUserByDeviceUdid_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SearchUserByDeviceUdid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter55 in self.success:
                oprot.writeString(iter55.encode('utf-8') if sys.version_info[0] == 2 else iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SearchUserByDeviceUdid_result)
EACP_SearchUserByDeviceUdid_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_DeleteDevices_args(object):
    """
    Attributes:
     - userId
     - udids

    """


    def __init__(self, userId=None, udids=None,):
        self.userId = userId
        self.udids = udids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.udids = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.udids.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_DeleteDevices_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udids is not None:
            oprot.writeFieldBegin('udids', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.udids))
            for iter62 in self.udids:
                oprot.writeString(iter62.encode('utf-8') if sys.version_info[0] == 2 else iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_DeleteDevices_args)
EACP_DeleteDevices_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'udids', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class EACP_DeleteDevices_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_DeleteDevices_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_DeleteDevices_result)
EACP_DeleteDevices_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_BindDevice_args(object):
    """
    Attributes:
     - userId
     - udid

    """


    def __init__(self, userId=None, udid=None,):
        self.userId = userId
        self.udid = udid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_BindDevice_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 2)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_BindDevice_args)
EACP_BindDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'udid', 'UTF8', None, ),  # 2
)


class EACP_BindDevice_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_BindDevice_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_BindDevice_result)
EACP_BindDevice_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_UnbindDevice_args(object):
    """
    Attributes:
     - userId
     - udid

    """


    def __init__(self, userId=None, udid=None,):
        self.userId = userId
        self.udid = udid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UnbindDevice_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 2)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UnbindDevice_args)
EACP_UnbindDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'udid', 'UTF8', None, ),  # 2
)


class EACP_UnbindDevice_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UnbindDevice_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UnbindDevice_result)
EACP_UnbindDevice_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_EnableDevice_args(object):
    """
    Attributes:
     - userId
     - udid

    """


    def __init__(self, userId=None, udid=None,):
        self.userId = userId
        self.udid = udid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_EnableDevice_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 2)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_EnableDevice_args)
EACP_EnableDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'udid', 'UTF8', None, ),  # 2
)


class EACP_EnableDevice_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_EnableDevice_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_EnableDevice_result)
EACP_EnableDevice_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_DisableDevice_args(object):
    """
    Attributes:
     - userId
     - udid

    """


    def __init__(self, userId=None, udid=None,):
        self.userId = userId
        self.udid = udid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.udid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_DisableDevice_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.udid is not None:
            oprot.writeFieldBegin('udid', TType.STRING, 2)
            oprot.writeString(self.udid.encode('utf-8') if sys.version_info[0] == 2 else self.udid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_DisableDevice_args)
EACP_DisableDevice_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'udid', 'UTF8', None, ),  # 2
)


class EACP_DisableDevice_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_DisableDevice_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_DisableDevice_result)
EACP_DisableDevice_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SetPermConfigs_args(object):
    """
    Attributes:
     - docId
     - permConfigs

    """


    def __init__(self, docId=None, permConfigs=None,):
        self.docId = docId
        self.permConfigs = permConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.docId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.permConfigs = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = ncTCustomPerm()
                        _elem68.read(iprot)
                        self.permConfigs.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetPermConfigs_args')
        if self.docId is not None:
            oprot.writeFieldBegin('docId', TType.STRING, 1)
            oprot.writeString(self.docId.encode('utf-8') if sys.version_info[0] == 2 else self.docId)
            oprot.writeFieldEnd()
        if self.permConfigs is not None:
            oprot.writeFieldBegin('permConfigs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.permConfigs))
            for iter69 in self.permConfigs:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetPermConfigs_args)
EACP_SetPermConfigs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'docId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'permConfigs', (TType.STRUCT, [ncTCustomPerm, None], False), None, ),  # 2
)


class EACP_SetPermConfigs_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetPermConfigs_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetPermConfigs_result)
EACP_SetPermConfigs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearTokenByUserId_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearTokenByUserId_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearTokenByUserId_args)
EACP_ClearTokenByUserId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EACP_ClearTokenByUserId_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearTokenByUserId_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearTokenByUserId_result)
EACP_ClearTokenByUserId_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_OnProcessChange_args(object):
    """
    Attributes:
     - processId

    """


    def __init__(self, processId=None,):
        self.processId = processId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.processId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnProcessChange_args')
        if self.processId is not None:
            oprot.writeFieldBegin('processId', TType.STRING, 1)
            oprot.writeString(self.processId.encode('utf-8') if sys.version_info[0] == 2 else self.processId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnProcessChange_args)
EACP_OnProcessChange_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'processId', 'UTF8', None, ),  # 1
)


class EACP_OnProcessChange_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_OnProcessChange_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_OnProcessChange_result)
EACP_OnProcessChange_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearAllToken_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearAllToken_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearAllToken_args)
EACP_ClearAllToken_args.thrift_spec = (
)


class EACP_ClearAllToken_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearAllToken_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearAllToken_result)
EACP_ClearAllToken_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_UpdateAllTokenFlagByOsType_args(object):
    """
    Attributes:
     - osType

    """


    def __init__(self, osType=None,):
        self.osType = osType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.osType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateAllTokenFlagByOsType_args')
        if self.osType is not None:
            oprot.writeFieldBegin('osType', TType.I32, 1)
            oprot.writeI32(self.osType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateAllTokenFlagByOsType_args)
EACP_UpdateAllTokenFlagByOsType_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'osType', None, None, ),  # 1
)


class EACP_UpdateAllTokenFlagByOsType_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateAllTokenFlagByOsType_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateAllTokenFlagByOsType_result)
EACP_UpdateAllTokenFlagByOsType_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_UpdateAllTokenFlagByIdcardStatus_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateAllTokenFlagByIdcardStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateAllTokenFlagByIdcardStatus_args)
EACP_UpdateAllTokenFlagByIdcardStatus_args.thrift_spec = (
)


class EACP_UpdateAllTokenFlagByIdcardStatus_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateAllTokenFlagByIdcardStatus_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateAllTokenFlagByIdcardStatus_result)
EACP_UpdateAllTokenFlagByIdcardStatus_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_CheckTokenId_args(object):
    """
    Attributes:
     - tokenInfo

    """


    def __init__(self, tokenInfo=None,):
        self.tokenInfo = tokenInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tokenInfo = ncTCheckTokenInfo()
                    self.tokenInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_CheckTokenId_args')
        if self.tokenInfo is not None:
            oprot.writeFieldBegin('tokenInfo', TType.STRUCT, 1)
            self.tokenInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_CheckTokenId_args)
EACP_CheckTokenId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tokenInfo', [ncTCheckTokenInfo, None], None, ),  # 1
)


class EACP_CheckTokenId_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_CheckTokenId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_CheckTokenId_result)
EACP_CheckTokenId_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearAllInvitationInfo_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearAllInvitationInfo_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearAllInvitationInfo_args)
EACP_ClearAllInvitationInfo_args.thrift_spec = (
)


class EACP_ClearAllInvitationInfo_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearAllInvitationInfo_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearAllInvitationInfo_result)
EACP_ClearAllInvitationInfo_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_ClearUserInvitationInfo_args(object):
    """
    Attributes:
     - userId

    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearUserInvitationInfo_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearUserInvitationInfo_args)
EACP_ClearUserInvitationInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class EACP_ClearUserInvitationInfo_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_ClearUserInvitationInfo_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_ClearUserInvitationInfo_result)
EACP_ClearUserInvitationInfo_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_RestartGlobalShareMgntServer_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_RestartGlobalShareMgntServer_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_RestartGlobalShareMgntServer_args)
EACP_RestartGlobalShareMgntServer_args.thrift_spec = (
)


class EACP_RestartGlobalShareMgntServer_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_RestartGlobalShareMgntServer_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_RestartGlobalShareMgntServer_result)
EACP_RestartGlobalShareMgntServer_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_RestartLocalShareMgntServer_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_RestartLocalShareMgntServer_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_RestartLocalShareMgntServer_args)
EACP_RestartLocalShareMgntServer_args.thrift_spec = (
)


class EACP_RestartLocalShareMgntServer_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_RestartLocalShareMgntServer_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_RestartLocalShareMgntServer_result)
EACP_RestartLocalShareMgntServer_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SetPushMessagesConfig_args(object):
    """
    Attributes:
     - appId

    """


    def __init__(self, appId=None,):
        self.appId = appId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.appId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetPushMessagesConfig_args')
        if self.appId is not None:
            oprot.writeFieldBegin('appId', TType.STRING, 1)
            oprot.writeString(self.appId.encode('utf-8') if sys.version_info[0] == 2 else self.appId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetPushMessagesConfig_args)
EACP_SetPushMessagesConfig_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'appId', 'UTF8', None, ),  # 1
)


class EACP_SetPushMessagesConfig_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetPushMessagesConfig_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetPushMessagesConfig_result)
EACP_SetPushMessagesConfig_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetPushMessagesConfig_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetPushMessagesConfig_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetPushMessagesConfig_args)
EACP_GetPushMessagesConfig_args.thrift_spec = (
)


class EACP_GetPushMessagesConfig_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetPushMessagesConfig_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetPushMessagesConfig_result)
EACP_GetPushMessagesConfig_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_PublishDocExchange_args(object):
    """
    Attributes:
     - params

    """


    def __init__(self, params=None,):
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.params = ncTDocExchangeProcessInfo()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_PublishDocExchange_args')
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 1)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_PublishDocExchange_args)
EACP_PublishDocExchange_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'params', [ncTDocExchangeProcessInfo, None], None, ),  # 1
)


class EACP_PublishDocExchange_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_PublishDocExchange_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_PublishDocExchange_result)
EACP_PublishDocExchange_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_AddAntivirusMessage_args(object):
    """
    Attributes:
     - msg

    """


    def __init__(self, msg=None,):
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.msg = ncTAntivirusMessage()
                    self.msg.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddAntivirusMessage_args')
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRUCT, 1)
            self.msg.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddAntivirusMessage_args)
EACP_AddAntivirusMessage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'msg', [ncTAntivirusMessage, None], None, ),  # 1
)


class EACP_AddAntivirusMessage_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddAntivirusMessage_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddAntivirusMessage_result)
EACP_AddAntivirusMessage_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_AddQuarantineMessage_args(object):
    """
    Attributes:
     - msg

    """


    def __init__(self, msg=None,):
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.msg = ncTQuarantineMessage()
                    self.msg.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddQuarantineMessage_args')
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRUCT, 1)
            self.msg.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddQuarantineMessage_args)
EACP_AddQuarantineMessage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'msg', [ncTQuarantineMessage, None], None, ),  # 1
)


class EACP_AddQuarantineMessage_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddQuarantineMessage_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddQuarantineMessage_result)
EACP_AddQuarantineMessage_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_AddAppealMessage_args(object):
    """
    Attributes:
     - msg

    """


    def __init__(self, msg=None,):
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.msg = ncTAppealMessage()
                    self.msg.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddAppealMessage_args')
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRUCT, 1)
            self.msg.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddAppealMessage_args)
EACP_AddAppealMessage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'msg', [ncTAppealMessage, None], None, ),  # 1
)


class EACP_AddAppealMessage_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddAppealMessage_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddAppealMessage_result)
EACP_AddAppealMessage_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_AddDocRemindMessage_args(object):
    """
    Attributes:
     - msg

    """


    def __init__(self, msg=None,):
        self.msg = msg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.msg = ncTDocRemindMessage()
                    self.msg.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddDocRemindMessage_args')
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRUCT, 1)
            self.msg.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddDocRemindMessage_args)
EACP_AddDocRemindMessage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'msg', [ncTDocRemindMessage, None], None, ),  # 1
)


class EACP_AddDocRemindMessage_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_AddDocRemindMessage_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_AddDocRemindMessage_result)
EACP_AddDocRemindMessage_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SetSendShareMailStatus_args(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.status = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetSendShareMailStatus_args')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.BOOL, 1)
            oprot.writeBool(self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetSendShareMailStatus_args)
EACP_SetSendShareMailStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'status', None, None, ),  # 1
)


class EACP_SetSendShareMailStatus_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetSendShareMailStatus_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetSendShareMailStatus_result)
EACP_SetSendShareMailStatus_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetSendShareMailStatus_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetSendShareMailStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetSendShareMailStatus_args)
EACP_GetSendShareMailStatus_args.thrift_spec = (
)


class EACP_GetSendShareMailStatus_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetSendShareMailStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetSendShareMailStatus_result)
EACP_GetSendShareMailStatus_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_UpdateTokenFlagByUserId_args(object):
    """
    Attributes:
     - userId
     - flag

    """


    def __init__(self, userId=None, flag=None,):
        self.userId = userId
        self.flag = flag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.flag = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateTokenFlagByUserId_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.I32, 2)
            oprot.writeI32(self.flag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateTokenFlagByUserId_args)
EACP_UpdateTokenFlagByUserId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'flag', None, None, ),  # 2
)


class EACP_UpdateTokenFlagByUserId_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateTokenFlagByUserId_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateTokenFlagByUserId_result)
EACP_UpdateTokenFlagByUserId_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_UpdateTokenFlagByPriority_args(object):
    """
    Attributes:
     - priority
     - flag

    """


    def __init__(self, priority=None, flag=None,):
        self.priority = priority
        self.flag = flag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.flag = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateTokenFlagByPriority_args')
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 1)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.I32, 2)
            oprot.writeI32(self.flag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateTokenFlagByPriority_args)
EACP_UpdateTokenFlagByPriority_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'priority', None, None, ),  # 1
    (2, TType.I32, 'flag', None, None, ),  # 2
)


class EACP_UpdateTokenFlagByPriority_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_UpdateTokenFlagByPriority_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_UpdateTokenFlagByPriority_result)
EACP_UpdateTokenFlagByPriority_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SetMessageNotifyStatus_args(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.status = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetMessageNotifyStatus_args')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.BOOL, 1)
            oprot.writeBool(self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetMessageNotifyStatus_args)
EACP_SetMessageNotifyStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'status', None, None, ),  # 1
)


class EACP_SetMessageNotifyStatus_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetMessageNotifyStatus_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetMessageNotifyStatus_result)
EACP_SetMessageNotifyStatus_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetMessageNotifyStatus_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetMessageNotifyStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetMessageNotifyStatus_args)
EACP_GetMessageNotifyStatus_args.thrift_spec = (
)


class EACP_GetMessageNotifyStatus_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetMessageNotifyStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetMessageNotifyStatus_result)
EACP_GetMessageNotifyStatus_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_DeleteContactPermByUserID_args(object):
    """
    Attributes:
     - dbName
     - userId

    """


    def __init__(self, dbName=None, userId=None,):
        self.dbName = dbName
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_DeleteContactPermByUserID_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_DeleteContactPermByUserID_args)
EACP_DeleteContactPermByUserID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class EACP_DeleteContactPermByUserID_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_DeleteContactPermByUserID_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_DeleteContactPermByUserID_result)
EACP_DeleteContactPermByUserID_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_SetCustomApplicationConfig_args(object):
    """
    Attributes:
     - appConfig

    """


    def __init__(self, appConfig=None,):
        self.appConfig = appConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.appConfig = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetCustomApplicationConfig_args')
        if self.appConfig is not None:
            oprot.writeFieldBegin('appConfig', TType.STRING, 1)
            oprot.writeString(self.appConfig.encode('utf-8') if sys.version_info[0] == 2 else self.appConfig)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetCustomApplicationConfig_args)
EACP_SetCustomApplicationConfig_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'appConfig', 'UTF8', None, ),  # 1
)


class EACP_SetCustomApplicationConfig_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_SetCustomApplicationConfig_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_SetCustomApplicationConfig_result)
EACP_SetCustomApplicationConfig_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_GetCustomApplicationConfig_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetCustomApplicationConfig_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetCustomApplicationConfig_args)
EACP_GetCustomApplicationConfig_args.thrift_spec = (
)


class EACP_GetCustomApplicationConfig_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_GetCustomApplicationConfig_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_GetCustomApplicationConfig_result)
EACP_GetCustomApplicationConfig_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class EACP_NotifyPushWebhookThread_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_NotifyPushWebhookThread_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_NotifyPushWebhookThread_args)
EACP_NotifyPushWebhookThread_args.thrift_spec = (
)


class EACP_NotifyPushWebhookThread_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EACP_NotifyPushWebhookThread_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EACP_NotifyPushWebhookThread_result)
EACP_NotifyPushWebhookThread_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

