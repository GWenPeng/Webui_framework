#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def Log(self, item):
        """
        记录日志

        Parameters:
         - item

        """
        pass

    def GetLogCount(self, param):
        """
        获取日志的条数

        Parameters:
         - param

        """
        pass

    def GetPageLog(self, param):
        """
        分页获取日志
        返回的结果默认按时间降序

        Parameters:
         - param

        """
        pass

    def ExportLog(self, param):
        """
        分块导出日志
        返回分块数据

        Parameters:
         - param

        """
        pass

    def SetLogRetentionPeriod(self, period):
        """
        设置日志保留周期 (单位：月)

        Parameters:
         - period

        """
        pass

    def GetLogRetentionPeriod(self):
        """
        获取日志保留周期 (单位：月)

        """
        pass

    def GetHistoryLogs(self, logType):
        """
        获取某个日志类型的所有日志

        Parameters:
         - logType

        """
        pass

    def GetHistoryLogCount(self, param):
        """
        获取历史日志文件的总数

        Parameters:
         - param

        """
        pass

    def GetPageHistoryLog(self, param):
        """
        分页获取历史日志文件信息
        返回的结果默认按时间降序

        Parameters:
         - param

        """
        pass

    def GetHistoryLogDownLoadInfo(self, id, reqHost, useHttps, validSeconds):
        """
        获取历史日志文件下载信息

        @param id: 历史日志文件id
        @param reqHost: 从存储服务下载的请求地址
        @param useHttps: 是否使用https下载
        @param validSeconds: 下载请求的有效时长
        @return : 下载请求的method, url, headers
        @throw 转抛内部调用异常
               若id不存在

        Parameters:
         - id
         - reqHost
         - useHttps
         - validSeconds

        """
        pass

    def ReadHistoryLog(self, fileId, offset, length):
        """
        读取历史日志文件内容
        @param fileId        文档id
        @param offset        读取开始偏移位置
        @param length        读取大小
        @return              返回日志文件内容的二进制流字符串

        Parameters:
         - fileId
         - offset
         - length

        """
        pass

    def GetLogSpaceInfo(self):
        """
        获取日志占用的空间
        @return              返回日志占用信息

        """
        pass

    def GetBufferedLogs(self):
        """
        获取缓冲区的日志信息
        @return              返回日志信息

        """
        pass

    def SetSyslogFirstPushTime(self, time):
        """
        设置syslog首次推送时间

        Parameters:
         - time

        """
        pass

    def SetLogPushPeriod(self, period):
        """
        设置日志推送周期 (单位：分钟)

        Parameters:
         - period

        """
        pass

    def GetLogPushPeriod(self):
        """
        获取日志推送周期 (单位：分钟)

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def Log(self, item):
        """
        记录日志

        Parameters:
         - item

        """
        self.send_Log(item)

    def send_Log(self, item):
        self._oprot.writeMessageBegin('Log', TMessageType.ONEWAY, self._seqid)
        args = Log_args()
        args.item = item
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def GetLogCount(self, param):
        """
        获取日志的条数

        Parameters:
         - param

        """
        self.send_GetLogCount(param)
        return self.recv_GetLogCount()

    def send_GetLogCount(self, param):
        self._oprot.writeMessageBegin('GetLogCount', TMessageType.CALL, self._seqid)
        args = GetLogCount_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLogCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLogCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLogCount failed: unknown result")

    def GetPageLog(self, param):
        """
        分页获取日志
        返回的结果默认按时间降序

        Parameters:
         - param

        """
        self.send_GetPageLog(param)
        return self.recv_GetPageLog()

    def send_GetPageLog(self, param):
        self._oprot.writeMessageBegin('GetPageLog', TMessageType.CALL, self._seqid)
        args = GetPageLog_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPageLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPageLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPageLog failed: unknown result")

    def ExportLog(self, param):
        """
        分块导出日志
        返回分块数据

        Parameters:
         - param

        """
        self.send_ExportLog(param)
        return self.recv_ExportLog()

    def send_ExportLog(self, param):
        self._oprot.writeMessageBegin('ExportLog', TMessageType.CALL, self._seqid)
        args = ExportLog_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExportLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExportLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ExportLog failed: unknown result")

    def SetLogRetentionPeriod(self, period):
        """
        设置日志保留周期 (单位：月)

        Parameters:
         - period

        """
        self.send_SetLogRetentionPeriod(period)
        self.recv_SetLogRetentionPeriod()

    def send_SetLogRetentionPeriod(self, period):
        self._oprot.writeMessageBegin('SetLogRetentionPeriod', TMessageType.CALL, self._seqid)
        args = SetLogRetentionPeriod_args()
        args.period = period
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetLogRetentionPeriod(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetLogRetentionPeriod_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def GetLogRetentionPeriod(self):
        """
        获取日志保留周期 (单位：月)

        """
        self.send_GetLogRetentionPeriod()
        return self.recv_GetLogRetentionPeriod()

    def send_GetLogRetentionPeriod(self):
        self._oprot.writeMessageBegin('GetLogRetentionPeriod', TMessageType.CALL, self._seqid)
        args = GetLogRetentionPeriod_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLogRetentionPeriod(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLogRetentionPeriod_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLogRetentionPeriod failed: unknown result")

    def GetHistoryLogs(self, logType):
        """
        获取某个日志类型的所有日志

        Parameters:
         - logType

        """
        self.send_GetHistoryLogs(logType)
        return self.recv_GetHistoryLogs()

    def send_GetHistoryLogs(self, logType):
        self._oprot.writeMessageBegin('GetHistoryLogs', TMessageType.CALL, self._seqid)
        args = GetHistoryLogs_args()
        args.logType = logType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetHistoryLogs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetHistoryLogs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHistoryLogs failed: unknown result")

    def GetHistoryLogCount(self, param):
        """
        获取历史日志文件的总数

        Parameters:
         - param

        """
        self.send_GetHistoryLogCount(param)
        return self.recv_GetHistoryLogCount()

    def send_GetHistoryLogCount(self, param):
        self._oprot.writeMessageBegin('GetHistoryLogCount', TMessageType.CALL, self._seqid)
        args = GetHistoryLogCount_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetHistoryLogCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetHistoryLogCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHistoryLogCount failed: unknown result")

    def GetPageHistoryLog(self, param):
        """
        分页获取历史日志文件信息
        返回的结果默认按时间降序

        Parameters:
         - param

        """
        self.send_GetPageHistoryLog(param)
        return self.recv_GetPageHistoryLog()

    def send_GetPageHistoryLog(self, param):
        self._oprot.writeMessageBegin('GetPageHistoryLog', TMessageType.CALL, self._seqid)
        args = GetPageHistoryLog_args()
        args.param = param
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetPageHistoryLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetPageHistoryLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetPageHistoryLog failed: unknown result")

    def GetHistoryLogDownLoadInfo(self, id, reqHost, useHttps, validSeconds):
        """
        获取历史日志文件下载信息

        @param id: 历史日志文件id
        @param reqHost: 从存储服务下载的请求地址
        @param useHttps: 是否使用https下载
        @param validSeconds: 下载请求的有效时长
        @return : 下载请求的method, url, headers
        @throw 转抛内部调用异常
               若id不存在

        Parameters:
         - id
         - reqHost
         - useHttps
         - validSeconds

        """
        self.send_GetHistoryLogDownLoadInfo(id, reqHost, useHttps, validSeconds)
        return self.recv_GetHistoryLogDownLoadInfo()

    def send_GetHistoryLogDownLoadInfo(self, id, reqHost, useHttps, validSeconds):
        self._oprot.writeMessageBegin('GetHistoryLogDownLoadInfo', TMessageType.CALL, self._seqid)
        args = GetHistoryLogDownLoadInfo_args()
        args.id = id
        args.reqHost = reqHost
        args.useHttps = useHttps
        args.validSeconds = validSeconds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetHistoryLogDownLoadInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetHistoryLogDownLoadInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetHistoryLogDownLoadInfo failed: unknown result")

    def ReadHistoryLog(self, fileId, offset, length):
        """
        读取历史日志文件内容
        @param fileId        文档id
        @param offset        读取开始偏移位置
        @param length        读取大小
        @return              返回日志文件内容的二进制流字符串

        Parameters:
         - fileId
         - offset
         - length

        """
        self.send_ReadHistoryLog(fileId, offset, length)
        return self.recv_ReadHistoryLog()

    def send_ReadHistoryLog(self, fileId, offset, length):
        self._oprot.writeMessageBegin('ReadHistoryLog', TMessageType.CALL, self._seqid)
        args = ReadHistoryLog_args()
        args.fileId = fileId
        args.offset = offset
        args.length = length
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ReadHistoryLog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ReadHistoryLog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ReadHistoryLog failed: unknown result")

    def GetLogSpaceInfo(self):
        """
        获取日志占用的空间
        @return              返回日志占用信息

        """
        self.send_GetLogSpaceInfo()
        return self.recv_GetLogSpaceInfo()

    def send_GetLogSpaceInfo(self):
        self._oprot.writeMessageBegin('GetLogSpaceInfo', TMessageType.CALL, self._seqid)
        args = GetLogSpaceInfo_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLogSpaceInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLogSpaceInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLogSpaceInfo failed: unknown result")

    def GetBufferedLogs(self):
        """
        获取缓冲区的日志信息
        @return              返回日志信息

        """
        self.send_GetBufferedLogs()
        return self.recv_GetBufferedLogs()

    def send_GetBufferedLogs(self):
        self._oprot.writeMessageBegin('GetBufferedLogs', TMessageType.CALL, self._seqid)
        args = GetBufferedLogs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetBufferedLogs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetBufferedLogs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetBufferedLogs failed: unknown result")

    def SetSyslogFirstPushTime(self, time):
        """
        设置syslog首次推送时间

        Parameters:
         - time

        """
        self.send_SetSyslogFirstPushTime(time)
        self.recv_SetSyslogFirstPushTime()

    def send_SetSyslogFirstPushTime(self, time):
        self._oprot.writeMessageBegin('SetSyslogFirstPushTime', TMessageType.CALL, self._seqid)
        args = SetSyslogFirstPushTime_args()
        args.time = time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetSyslogFirstPushTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetSyslogFirstPushTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def SetLogPushPeriod(self, period):
        """
        设置日志推送周期 (单位：分钟)

        Parameters:
         - period

        """
        self.send_SetLogPushPeriod(period)
        self.recv_SetLogPushPeriod()

    def send_SetLogPushPeriod(self, period):
        self._oprot.writeMessageBegin('SetLogPushPeriod', TMessageType.CALL, self._seqid)
        args = SetLogPushPeriod_args()
        args.period = period
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SetLogPushPeriod(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SetLogPushPeriod_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def GetLogPushPeriod(self):
        """
        获取日志推送周期 (单位：分钟)

        """
        self.send_GetLogPushPeriod()
        return self.recv_GetLogPushPeriod()

    def send_GetLogPushPeriod(self):
        self._oprot.writeMessageBegin('GetLogPushPeriod', TMessageType.CALL, self._seqid)
        args = GetLogPushPeriod_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLogPushPeriod(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLogPushPeriod_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLogPushPeriod failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["Log"] = Processor.process_Log
        self._processMap["GetLogCount"] = Processor.process_GetLogCount
        self._processMap["GetPageLog"] = Processor.process_GetPageLog
        self._processMap["ExportLog"] = Processor.process_ExportLog
        self._processMap["SetLogRetentionPeriod"] = Processor.process_SetLogRetentionPeriod
        self._processMap["GetLogRetentionPeriod"] = Processor.process_GetLogRetentionPeriod
        self._processMap["GetHistoryLogs"] = Processor.process_GetHistoryLogs
        self._processMap["GetHistoryLogCount"] = Processor.process_GetHistoryLogCount
        self._processMap["GetPageHistoryLog"] = Processor.process_GetPageHistoryLog
        self._processMap["GetHistoryLogDownLoadInfo"] = Processor.process_GetHistoryLogDownLoadInfo
        self._processMap["ReadHistoryLog"] = Processor.process_ReadHistoryLog
        self._processMap["GetLogSpaceInfo"] = Processor.process_GetLogSpaceInfo
        self._processMap["GetBufferedLogs"] = Processor.process_GetBufferedLogs
        self._processMap["SetSyslogFirstPushTime"] = Processor.process_SetSyslogFirstPushTime
        self._processMap["SetLogPushPeriod"] = Processor.process_SetLogPushPeriod
        self._processMap["GetLogPushPeriod"] = Processor.process_GetLogPushPeriod
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_Log(self, seqid, iprot, oprot):
        args = Log_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.Log(args.item)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_GetLogCount(self, seqid, iprot, oprot):
        args = GetLogCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLogCount_result()
        try:
            result.success = self._handler.GetLogCount(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLogCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPageLog(self, seqid, iprot, oprot):
        args = GetPageLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPageLog_result()
        try:
            result.success = self._handler.GetPageLog(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPageLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExportLog(self, seqid, iprot, oprot):
        args = ExportLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExportLog_result()
        try:
            result.success = self._handler.ExportLog(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExportLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetLogRetentionPeriod(self, seqid, iprot, oprot):
        args = SetLogRetentionPeriod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetLogRetentionPeriod_result()
        try:
            self._handler.SetLogRetentionPeriod(args.period)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetLogRetentionPeriod", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetLogRetentionPeriod(self, seqid, iprot, oprot):
        args = GetLogRetentionPeriod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLogRetentionPeriod_result()
        try:
            result.success = self._handler.GetLogRetentionPeriod()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLogRetentionPeriod", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetHistoryLogs(self, seqid, iprot, oprot):
        args = GetHistoryLogs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetHistoryLogs_result()
        try:
            result.success = self._handler.GetHistoryLogs(args.logType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetHistoryLogs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetHistoryLogCount(self, seqid, iprot, oprot):
        args = GetHistoryLogCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetHistoryLogCount_result()
        try:
            result.success = self._handler.GetHistoryLogCount(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetHistoryLogCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetPageHistoryLog(self, seqid, iprot, oprot):
        args = GetPageHistoryLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetPageHistoryLog_result()
        try:
            result.success = self._handler.GetPageHistoryLog(args.param)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetPageHistoryLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetHistoryLogDownLoadInfo(self, seqid, iprot, oprot):
        args = GetHistoryLogDownLoadInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetHistoryLogDownLoadInfo_result()
        try:
            result.success = self._handler.GetHistoryLogDownLoadInfo(args.id, args.reqHost, args.useHttps, args.validSeconds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetHistoryLogDownLoadInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ReadHistoryLog(self, seqid, iprot, oprot):
        args = ReadHistoryLog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ReadHistoryLog_result()
        try:
            result.success = self._handler.ReadHistoryLog(args.fileId, args.offset, args.length)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ReadHistoryLog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetLogSpaceInfo(self, seqid, iprot, oprot):
        args = GetLogSpaceInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLogSpaceInfo_result()
        try:
            result.success = self._handler.GetLogSpaceInfo()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLogSpaceInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetBufferedLogs(self, seqid, iprot, oprot):
        args = GetBufferedLogs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetBufferedLogs_result()
        try:
            result.success = self._handler.GetBufferedLogs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetBufferedLogs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetSyslogFirstPushTime(self, seqid, iprot, oprot):
        args = SetSyslogFirstPushTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetSyslogFirstPushTime_result()
        try:
            self._handler.SetSyslogFirstPushTime(args.time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetSyslogFirstPushTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SetLogPushPeriod(self, seqid, iprot, oprot):
        args = SetLogPushPeriod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SetLogPushPeriod_result()
        try:
            self._handler.SetLogPushPeriod(args.period)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SetLogPushPeriod", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetLogPushPeriod(self, seqid, iprot, oprot):
        args = GetLogPushPeriod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLogPushPeriod_result()
        try:
            result.success = self._handler.GetLogPushPeriod()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except EThriftException.ttypes.ncTException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLogPushPeriod", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class Log_args(object):
    """
    Attributes:
     - item

    """


    def __init__(self, item=None,):
        self.item = item

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.item = ncTLogItem()
                    self.item.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Log_args')
        if self.item is not None:
            oprot.writeFieldBegin('item', TType.STRUCT, 1)
            self.item.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Log_args)
Log_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'item', [ncTLogItem, None], None, ),  # 1
)


class GetLogCount_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetLogCountParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogCount_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogCount_args)
GetLogCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetLogCountParam, None], None, ),  # 1
)


class GetLogCount_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTLogCountInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogCount_result)
GetLogCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTLogCountInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetPageLog_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetPageLogParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPageLog_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPageLog_args)
GetPageLog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetPageLogParam, None], None, ),  # 1
)


class GetPageLog_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = ncTLogInfo()
                        _elem166.read(iprot)
                        self.success.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPageLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter167 in self.success:
                iter167.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPageLog_result)
GetPageLog_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTLogInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class ExportLog_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTExportLogParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExportLog_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExportLog_args)
ExportLog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTExportLogParam, None], None, ),  # 1
)


class ExportLog_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExportLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExportLog_result)
ExportLog_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class SetLogRetentionPeriod_args(object):
    """
    Attributes:
     - period

    """


    def __init__(self, period=None,):
        self.period = period

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.period = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetLogRetentionPeriod_args')
        if self.period is not None:
            oprot.writeFieldBegin('period', TType.I32, 1)
            oprot.writeI32(self.period)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetLogRetentionPeriod_args)
SetLogRetentionPeriod_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'period', None, None, ),  # 1
)


class SetLogRetentionPeriod_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetLogRetentionPeriod_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetLogRetentionPeriod_result)
SetLogRetentionPeriod_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetLogRetentionPeriod_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogRetentionPeriod_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogRetentionPeriod_args)
GetLogRetentionPeriod_args.thrift_spec = (
)


class GetLogRetentionPeriod_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogRetentionPeriod_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogRetentionPeriod_result)
GetLogRetentionPeriod_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetHistoryLogs_args(object):
    """
    Attributes:
     - logType

    """


    def __init__(self, logType=None,):
        self.logType = logType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.logType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHistoryLogs_args')
        if self.logType is not None:
            oprot.writeFieldBegin('logType', TType.I32, 1)
            oprot.writeI32(self.logType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHistoryLogs_args)
GetHistoryLogs_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'logType', None, None, ),  # 1
)


class GetHistoryLogs_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = ncTHistoryLogInfo()
                        _elem173.read(iprot)
                        self.success.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHistoryLogs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter174 in self.success:
                iter174.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHistoryLogs_result)
GetHistoryLogs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTHistoryLogInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetHistoryLogCount_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetHistoryLogCountParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHistoryLogCount_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHistoryLogCount_args)
GetHistoryLogCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetHistoryLogCountParam, None], None, ),  # 1
)


class GetHistoryLogCount_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHistoryLogCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHistoryLogCount_result)
GetHistoryLogCount_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetPageHistoryLog_args(object):
    """
    Attributes:
     - param

    """


    def __init__(self, param=None,):
        self.param = param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = ncTGetPageHistoryLogParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPageHistoryLog_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPageHistoryLog_args)
GetPageHistoryLog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [ncTGetPageHistoryLogParam, None], None, ),  # 1
)


class GetPageHistoryLog_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = ncTHistoryLogInfo()
                        _elem180.read(iprot)
                        self.success.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetPageHistoryLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter181 in self.success:
                iter181.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetPageHistoryLog_result)
GetPageHistoryLog_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTHistoryLogInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetHistoryLogDownLoadInfo_args(object):
    """
    Attributes:
     - id
     - reqHost
     - useHttps
     - validSeconds

    """


    def __init__(self, id=None, reqHost=None, useHttps=None, validSeconds=None,):
        self.id = id
        self.reqHost = reqHost
        self.useHttps = useHttps
        self.validSeconds = validSeconds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reqHost = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.useHttps = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.validSeconds = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHistoryLogDownLoadInfo_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.reqHost is not None:
            oprot.writeFieldBegin('reqHost', TType.STRING, 2)
            oprot.writeString(self.reqHost.encode('utf-8') if sys.version_info[0] == 2 else self.reqHost)
            oprot.writeFieldEnd()
        if self.useHttps is not None:
            oprot.writeFieldBegin('useHttps', TType.BOOL, 3)
            oprot.writeBool(self.useHttps)
            oprot.writeFieldEnd()
        if self.validSeconds is not None:
            oprot.writeFieldBegin('validSeconds', TType.I64, 4)
            oprot.writeI64(self.validSeconds)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHistoryLogDownLoadInfo_args)
GetHistoryLogDownLoadInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'reqHost', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'useHttps', None, None, ),  # 3
    (4, TType.I64, 'validSeconds', None, None, ),  # 4
)


class GetHistoryLogDownLoadInfo_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = EVFS.ttypes.ncTEVFSOSSRequest()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetHistoryLogDownLoadInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetHistoryLogDownLoadInfo_result)
GetHistoryLogDownLoadInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [EVFS.ttypes.ncTEVFSOSSRequest, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class ReadHistoryLog_args(object):
    """
    Attributes:
     - fileId
     - offset
     - length

    """


    def __init__(self, fileId=None, offset=None, length=None,):
        self.fileId = fileId
        self.offset = offset
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ReadHistoryLog_args')
        if self.fileId is not None:
            oprot.writeFieldBegin('fileId', TType.STRING, 1)
            oprot.writeString(self.fileId.encode('utf-8') if sys.version_info[0] == 2 else self.fileId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ReadHistoryLog_args)
ReadHistoryLog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileId', 'UTF8', None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
)


class ReadHistoryLog_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ReadHistoryLog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ReadHistoryLog_result)
ReadHistoryLog_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetLogSpaceInfo_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogSpaceInfo_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogSpaceInfo_args)
GetLogSpaceInfo_args.thrift_spec = (
)


class GetLogSpaceInfo_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncTLogSpaceInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogSpaceInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogSpaceInfo_result)
GetLogSpaceInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncTLogSpaceInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetBufferedLogs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBufferedLogs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetBufferedLogs_args)
GetBufferedLogs_args.thrift_spec = (
)


class GetBufferedLogs_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = ncTLogInfo()
                        _elem187.read(iprot)
                        self.success.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBufferedLogs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter188 in self.success:
                iter188.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetBufferedLogs_result)
GetBufferedLogs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncTLogInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class SetSyslogFirstPushTime_args(object):
    """
    Attributes:
     - time

    """


    def __init__(self, time=None,):
        self.time = time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetSyslogFirstPushTime_args')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I64, 1)
            oprot.writeI64(self.time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetSyslogFirstPushTime_args)
SetSyslogFirstPushTime_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'time', None, None, ),  # 1
)


class SetSyslogFirstPushTime_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetSyslogFirstPushTime_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetSyslogFirstPushTime_result)
SetSyslogFirstPushTime_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class SetLogPushPeriod_args(object):
    """
    Attributes:
     - period

    """


    def __init__(self, period=None,):
        self.period = period

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.period = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetLogPushPeriod_args')
        if self.period is not None:
            oprot.writeFieldBegin('period', TType.I32, 1)
            oprot.writeI32(self.period)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetLogPushPeriod_args)
SetLogPushPeriod_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'period', None, None, ),  # 1
)


class SetLogPushPeriod_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetLogPushPeriod_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SetLogPushPeriod_result)
SetLogPushPeriod_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)


class GetLogPushPeriod_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogPushPeriod_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogPushPeriod_args)
GetLogPushPeriod_args.thrift_spec = (
)


class GetLogPushPeriod_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = EThriftException.ttypes.ncTException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLogPushPeriod_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLogPushPeriod_result)
GetLogPushPeriod_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [EThriftException.ttypes.ncTException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

